# 面试题

这里仅列出概要, 一些问题具体可参看[这篇文章](https://blog.csdn.net/huangshulang1234/article/details/79480244)

## Java 基础

### Java 中的几种基本类型? 各占多少字节?

答: 

|基本类型|字节|取值范围|
|--------|---|-------|
|byte|1|-128~127（-2的7次方到2的7次方-1）|
|short|2|-32768~32767（-2的15次方到2的15次方-1）|
|int|4|-2147483648~2147483647（-2的31次方到2的31次方-1）|
|long|8|-9223372036854774808~9223372036854774807（-2的63次方到2的63次方-1）|
|char|2|前128字节编码与ASCII兼容 
字符的存储范围在\u0000~\uFFFF|
|float|4|3.402823e+38 ~ 1.401298e-45（e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方）|
|double|8|1.797693e+308~ 4.9000000e-324|
|boolean|4|true / false|

> 注意: JDK 官方文档 boolean 只定义了取值范围为 `true` 或 `false` . 但没有给出具体的占用大小. 看虚拟机的具体实现而定, 可能是4字节的 (int) , 也可能是一字节的 (boolean 数组) .

### String 能否被继承, 为什么?

答:

其定义为 `public final class String implements java.io.Serializable, Comparable<String>, CharSequence {...}` 由关键字 final 修饰, 所以不能被继承.

### String,StringBuilder,StringBuffer 的区别?

答:

三者均通过 `char[] value` 的域变量来保存字符串. String 与二者不同的是, 它的变量 `value` 是使用 `final` 修饰的, 所以其不能被重新赋值, 这也是 String 是不可变变量的原因. 

`StringBuilder` 与 `StringBuffer` API几乎相同, 不同的是 `StringBuffer` 使用了同步 `synchronized` 因此可以认为是线程安全的字符串操作类. 另外, 二者的 `toString()` 方法实现不同:

```java
// StringBuilder 的实现
@Override
public String toString() {
    // Create a copy, don't share the array
    return new String(value, 0, count);
}


// StringBuffer 的实现

/**
* A cache of the last value returned by toString. Cleared
* whenever the StringBuffer is modified.
*/
private transient char[] toStringCache;

@Override
public synchronized String toString() {
    if (toStringCache == null) {
        toStringCache = Arrays.copyOfRange(value, 0, count);
    }
    return new String(toStringCache, true);
}
```

`StringBuilder` 自1.5开始出现, 是为了提高在单线程环境下字符串操作效率. `StringBuffer` 从1.0 就有了.

三者均使用 `final` 修饰, 不能被继承.

### 下面代码的输出分别为? 

1. `String a = "hello2";  String b = "hello" + 2; 　　System.out.println((a == b));` 

答: true 原因是编译期字面量优化, `"hello" + 2` 被优化为 `"hello2"` 了. 

2. `String a = "hello2"; 　  String b = "hello";       String c = b + 2;       System.out.println((a == c));`   

答: false, 无法进行编译器优化, 认为是两个不同的对象. 

3. `String a = "hello2";   　 final String b = "hello";       String c = b + 2;       System.out.println((a == c));` 

答: true, `final` 的变量会内联执行, 所以同问题1一样. 

4. 

```java
public static void main(String[] args) {
    String a = "hello2";
    final String b = getHello();
    String c = b + 2;
    System.out.println((a == c));
}
    
public static String getHello() {
    return "hello";
}
```

答: false, 通过方法获取的值无法内联优化. 

5. 

```java
public class Main {
    public static void main(String[] args) {
        String a = "hello";
        String b =  new String("hello");
        String c =  new String("hello");
        String d = b.intern();
         
        System.out.println(a==b);
        System.out.println(b==c);
        System.out.println(b==d);
        System.out.println(a==d);
    }
}
```

答: 分别为: `false` , `false` , `false` , `true` . `b.intern()` 为本地方法, 会通过常量池查找, 因此, 因此它与 `a` 为同一对象. 

6. `String str = new String("abc")` 创建了多少对象? 

答: 在**类加载**过程中, 在常量池创建了 `"bac"` 对象, 在**代码执行**中创建了字符串对象. 因此这段代码涉及两个对象的创建, 但创建过程分别在不同的阶段. 严格讲, 代码执行过程中只有一个对象创建. 一共创建了两个对象.  

7. 1和2处的代码区别?

```java
public class Main {
    public static void main(String[] args) {
        String str1 = "I";
        //str1 += "love"+"java";        1)
        str1 = str1+"love"+"java";      //2)
         
    }
}
```

答: 1 的效率比 2 的高. 这也涉及到编译器优化, 1 会将 "love" 和 "java" 优化为 "lovejava". 

### ArrayList 和 LinkedList 的区别?

答: 

二者均实现了 `List` 接口. 

* `ArrayList` 底层基于数组实现, 可以使用下标快速访问元素, 支持随机访问(时间复杂度为O(1)), `LinkedList` 使用链表, 访问某个元素需要遍历(时间复杂度为O(n));

* `LinkedList` 因为每个节点保留了与之相邻元素的引用, 所以对于元素的增加/删除等操作更快, `ArrayList` 则因为操作后需要调整数组元素位置, 所以效率会低. 

参看[这篇文章](https://blog.csdn.net/weixin_42468526/article/details/81178698)

### 类的实例化顺序是? 

答: 类加载器实例化时的顺序为 加载 -> 连接 -> 初始化

1）父类的静态成员；静态方法块； -> 2）子类中的静态成员；静态方法块；-> 3）父类中的成员变量；方法块；-> 5）父类构造函数 -> 4）子类中的成员变量；方法块；-> 6）子类构造函数

初始化块的一个问题,参看[这篇文章](https://segmentfault.com/q/1010000008546313)

### Map 类有哪些? HashMap 是否线程安全? 原理是什么? 

答: 常用的 `HashMap`,`HashTable`,`ConcurrentHashMap`,`TreeMap` 等.

`HashMap` 并非线程安全的类. `HashTable`,`ConcurrentHashMap` 被认为是线程安全的, 但 `HashTable` 因为性能问题很少使用了. HashMap的扩容可能导致循环链表. 

`HashMap` 使用数组+链表, 1.8的话使用数组+链表+红黑树实现. 数组的每个元素称为Node或Entry, 存储key,value,hash, next; 当put元素时, 通过元素的key计算其hash值, 并与(capture-1)做 `&` 操作. 从而得到数组的下标. 1.8的实现中, 通过高16位和低16位异或运算来使hash更加分散.  扩容时, 二进制低位不变, 高位+1, 这样更容易计算新元素的下标. 所以 HashMap 的容量为2次方. map 比如有hash碰撞问题发生, 可以使用扰动函数来减少碰撞, 并将key定义为final的对象. 

参看[这篇文章](https://baijiahao.baidu.com/s?id=1618550070727689060&wfr=spider&for=pc)

### Java8的 ConcurrentHashMap 为什么放弃了分段锁, 有什么问题? 如果你来设计该如何实现?

答: 分段锁Segment继承了ReentrantLock, 使用并发度来控制Segment的数量. 所以锁的粒度可以设置, 但不灵活, 也很难保证性能和并发的平衡. Java8的锁有了更好的实现, 锁的粒度控制在只是锁一个Node, 而且只在必要的时候锁. java8并没有使用ReentrantLock, 而是使用synchronized修饰, 这种基于jvm的实现方式可能后期更有利于随着jvm升级. 

可以参看[这篇文章](https://blog.csdn.net/woaiwym/article/details/80675789)

### 有没有有顺序的 Map 实现类， 如果有， 他们是怎么保证有序的?

答: `LinkedHashTable` 或 `TreeMap`. LinkedHashTable 每个Entry节点定义了双向引用, 可以记录元素的插入顺序. TreeMap 需要一个 Comparator 来判断元素key的大小.

可以参看[这篇文章](https://uule.iteye.com/blog/1522291).

### 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么?

答: 

1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 
2、抽象类要被子类继承，接口要被类实现。 
3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现 
4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 
5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 
6、抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。 
7、抽象类里可以没有抽象方法 
8、如果一个类里有抽象方法，那么这个类只能是抽象类 
9、抽象方法要被实现，所以不能是静态的，也不能是私有的。 
10、接口可继承接口，并可多继承接口，但类只能单根继承。

### 继承和聚合的区别在哪?

答:继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性； 

聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分； 

### 讲讲你理解的 nio 和 bio 的区别是啥，谈谈 reactor 模型?

答: nio(non-blocking io 或者 new io)是同步非阻塞io, 采用多路复用机制. 

区别1: io 面向流, nio 面向缓存;Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。Java NIO:数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查该缓冲区中是否包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

区别2: Java IO的各种流是阻塞的。这意味着，当一个线程调用read()或write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

IO读写时，多路复用机制都会依赖对一个事件多路分离器，负责把源事件的IO 事件分离出来，分别到相应的read/write事件分离器。涉及到事件分离器的两种模式分别就是 Reactor和Proactor，Reactor是基于同步IO的，Proactor是基于异步IO的。

在Reactor模式中，事件分离者等待某个事件或者可应用或个操作的状态发生(比如文件描述符可读写，或者是socket可读写),事件分离者就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。

在Proactor模式中，事件处理者(或者代由事件分离者发起)直接发起一个异步读写操作(相当于请求)，而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区，读的数据大小，或者用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分离者得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。举例来说，在Windows上事件处理者投递了一个异步IO操作(称有 overlapped的技术)，事件分离者等IOCompletion事件完成. 这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。

### 反射的原理，反射创建类实例的三种方式是什么?

答: Java反射是Java被视为动态（或准动态）语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括其modifiers（诸如public, static 等）、superclass（例如Object）、实现之interfaces（例如Cloneable），也包括fields和methods的所有信息，并可于运行时改变fields内容或唤起methods。

Java反射机制容许程序在运行时加载、探知、使用编译期间完全未知的classes。

换言之，Java可以加载一个运行时才得知名称的class，获得其完整结构。

* 反射创建类的方式: 

1、调用类的Class对象的newInstance方法，该方法会调用对象的默认构造器，如果没有默认构造器，会调用失败.
2、调用默认Constructor对象的newInstance方法
3、调用带参数Constructor对象的newInstance方法

### 反射中，Class.forName 和 ClassLoader 区别? 

答: 类加载器通过三个步骤装载类, 装载、链接和初始化;

* 装载：查找和导入类或接口的二进制数据； 

链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的； 

* 校验：检查导入类或接口的二进制数据的正确性； 

* 准备：给类的静态变量分配并初始化存储空间； 

* 解析：将符号引用转成直接引用； 

* 初始化：激活类的静态变量的初始化Java代码和静态Java代码块。

Class.forName(className)方法，其实调用的方法是`forName0(className, true, ClassLoader.getClassLoader(caller), caller)`;注意看第2个boolean参数，它表示的意思，在loadClass后必须初始化。比较下我们前面准备jvm加载类的知识，我们可以清晰的看到在执行过此方法后，目标对象的 static块代码已经被执行，static参数也已经被初始化。

 再看ClassLoader.loadClass(className)方法，其实他调用的方法是`loadClass(name, false)`;还是注意看第2个 boolean参数，该参数表示目标对象被装载后不进行链接，这就意味这不会去执行该类静态块中间的内容。因此2者的区别就显而易见了。

 ### 描述动态代理的几种实现方式，分别说出相应的优缺点? (动态代理与 cglib 实现的区别?) (为什么 CGlib 方式可以对接口实现代理?)

 答: 

 * jdk : 基于反射, 必须定义要代理的借口, 且必须实现 `InvocationHandler` 接口, 使用反射效率较低, 但JDK6+已经优化了效率. JDK8的效率高于CGLib. 
 * cglib: 基于asm框架, 增强字节码. 但声明为final的方法无法代理. CGLib原理是动态生成被代理类的子类。

 ### final 的用途?

 答: final 修饰的类不能被继承, 方法不能被覆盖, 字段不能被重新赋值. 

* final 的好处:

final关键字提高了性能。JVM和Java应用都会缓存final变量。
final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
使用final关键字，JVM会对方法、变量及类进行优化。

* 关于final 的知识点: 

final关键字可以用于成员变量、本地变量、方法以及类。
final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。
你不能够对final变量再次赋值。
本地变量必须在声明时赋值。
在匿名类中所有变量都必须是final变量。
final方法不能被重写。
final类不能被继承。
final关键字不同于finally关键字，后者用于异常处理。
final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。
接口中声明的所有变量本身是final的。
final和abstract这两个关键字是反相关的，final类就不可能是abstract的。
final方法在编译阶段绑定，称为静态绑定(static binding)。
没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。
将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。
按照Java代码惯例，final变量就是常量，而且通常常量名要大写：

### 写出三种单例模式实现?

答: 参看[设计模式一: 单例模式(Singleton)](https://www.cnblogs.com/walkinhalo/p/9513118.html)

### 如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣?

答: Object 本身提供了equals 实现. 某些情况下, 并不需要对类的实例进行逻辑相等判定, 认为每个实例都是唯一的, 那么这种情况下子类就可以使用Object类的实现. 

另外, 父类如果提供了实例间逻辑相等的判定功能, 比如 AbstractSet , AbstractList 等, 则子类可以继承父类的实现. 

hashcode 和 equals 应该同时重写. 

### 请结合 OO 设计理念，谈谈访问修饰符 public、private、protected、default 在应用设计中的作用?

答: 用于隔离保护. 对于不同的作用域, 使用响应的修饰符保护, 这样可以防止代码被不恰当的调用, 同时减少代码耦合. 

### 深拷贝和浅拷贝区别?

答: 区别在于引用类型的实例域如何进行拷贝, 对于浅拷贝来说, 实例域会拷贝其上的值, 对于引用类型来说, 相当于拷贝了对象的引用, 而具体的对象由二者共享, 因此不是真正意义上的拷贝, 神拷贝除了复制引用, 同时也将对象同时拷贝一份, 两个对象之间不存在交集, 完全是两个独立的对象. 

### 数组和链表数据结构, 及其时间复杂度

答: 数组的元素在内存中是顺序存储的, 链表则每个元素有指向前一个和后一个元素的引用, 相邻元素不一定物理上也是相邻的. 

数组支持快速随机访问, 时间复杂度为O(1); 链表为O(n); 
按值查找时, 因为均需要遍历, 时间复杂度为O(n), 有序时时间复杂度可以为O(logn)
插入和删除链表要快O(1) 数组则因为要移动元素.O(n)

### error 和 exception 的区别，CheckedException，RuntimeException 的区别

答: error 是错误, 一般虚拟机在发生错误时会退出, 所以此类异常不需要被处理; Exception 是异常, 发生时说明程序代码出现错误, 需要被处理.一般是捕获处理或重新抛出.

CheckedException 是受查异常, 要求代码必须处理的异常， RuntimeException 与 error 一起被称为未受查异常, 发生RuntimeException 时说明是程序问题. 

* Checked异常, 会导致无法编译通过

Java.lang.ClassNotFoundException
Java.lang.NoSuchMetodException
java.io.IOException

* 我们比较熟悉的RumtimeException类的子类有

Java.lang.ArithmeticException
Java.lang.ArrayStoreExcetpion
Java.lang.ClassCastException
Java.lang.IndexOutOfBoundsException
Java.lang.NullPointerException

### 在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么

答: 类加载无须等到“首次使用该类”时加载，jvm允许预加载某些类

### 说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法。

答: 这两个方法用来判定两个对象是否相等. 这里的相等一般是指逻辑相等. Object 类的实现是根据引用地址来判断的, 因此如果需要通过自定义的相等逻辑, 比如集合相等需要每个元素的值都相等, 来覆盖object 的默认实现. 

### 在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题? 

答: 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率 

### hashcode() 有什么用，与 a.equals(b)有什么关系?

答: 用一个数字来标识对象。比如在HashMap、HashSet等类似的集合类中，如果用某个对象本身作为Key，即要基于这个对象实现Hash的写入和查找，那么对象本身如何实现这个呢？就是基于hashcode这样一个数字来完成的，只有数字才能完成计算和对比操作。

equals相等两个对象，则hashcode一定要相等。但是hashcode相等的两个对象不一定equals相等。 

### 有没有可能 2 个不相等的对象有相同的 hashcode?

答: 有可能

### Java 中的 HashSet 内部是如何工作的?

答: 对于 HashSet 而言，它是基于 HashMap 实现的，底层采用 HashMap 来保存元素.

### 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决?

答: 序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。

Externalizable继承了Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。由于上面的代码中，并没有在这两个方法中定义序列化实现细节，所以输出的内容为空。还有一点值得注意：在使用Externalizable进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器。

虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID).