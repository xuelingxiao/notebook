# 面试题

这里仅列出概要, 一些问题具体可参看[这篇文章](https://blog.csdn.net/huangshulang1234/article/details/79480244)

## Java 基础

### Java 中的几种基本类型? 各占多少字节?

答: 

|基本类型|字节|取值范围|
|--------|---|-------|
|byte|1|-128~127（-2的7次方到2的7次方-1）|
|short|2|-32768~32767（-2的15次方到2的15次方-1）|
|int|4|-2147483648~2147483647（-2的31次方到2的31次方-1）|
|long|8|-9223372036854774808~9223372036854774807（-2的63次方到2的63次方-1）|
|char|2|前128字节编码与ASCII兼容 
字符的存储范围在\u0000~\uFFFF|
|float|4|3.402823e+38 ~ 1.401298e-45（e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方）|
|double|8|1.797693e+308~ 4.9000000e-324|
|boolean|4|true / false|

> 注意: JDK 官方文档 boolean 只定义了取值范围为 `true` 或 `false` . 但没有给出具体的占用大小. 看虚拟机的具体实现而定, 可能是4字节的 (int) , 也可能是一字节的 (boolean 数组) .

### String 能否被继承, 为什么?

答:

其定义为 `public final class String implements java.io.Serializable, Comparable<String>, CharSequence {...}` 由关键字 final 修饰, 所以不能被继承.

### String,StringBuilder,StringBuffer 的区别?

答:

三者均通过 `char[] value` 的域变量来保存字符串. String 与二者不同的是, 它的变量 `value` 是使用 `final` 修饰的, 所以其不能被重新赋值, 这也是 String 是不可变变量的原因. 

`StringBuilder` 与 `StringBuffer` API几乎相同, 不同的是 `StringBuffer` 使用了同步 `synchronized` 因此可以认为是线程安全的字符串操作类. 另外, 二者的 `toString()` 方法实现不同:

```java
// StringBuilder 的实现
@Override
public String toString() {
    // Create a copy, don't share the array
    return new String(value, 0, count);
}


// StringBuffer 的实现

/**
* A cache of the last value returned by toString. Cleared
* whenever the StringBuffer is modified.
*/
private transient char[] toStringCache;

@Override
public synchronized String toString() {
    if (toStringCache == null) {
        toStringCache = Arrays.copyOfRange(value, 0, count);
    }
    return new String(toStringCache, true);
}
```

`StringBuilder` 自1.5开始出现, 是为了提高在单线程环境下字符串操作效率. `StringBuffer` 从1.0 就有了.

三者均使用 `final` 修饰, 不能被继承.

### 下面代码的输出分别为? 

1. `String a = "hello2";  String b = "hello" + 2; 　　System.out.println((a == b));` 

答: true 原因是编译期字面量优化, `"hello" + 2` 被优化为 `"hello2"` 了. 

2. `String a = "hello2"; 　  String b = "hello";       String c = b + 2;       System.out.println((a == c));`   

答: false, 无法进行编译器优化, 认为是两个不同的对象. 

3. `String a = "hello2";   　 final String b = "hello";       String c = b + 2;       System.out.println((a == c));` 

答: true, `final` 的变量会内联执行, 所以同问题1一样. 

4. 

```java
public static void main(String[] args) {
    String a = "hello2";
    final String b = getHello();
    String c = b + 2;
    System.out.println((a == c));
}
    
public static String getHello() {
    return "hello";
}
```

答: false, 通过方法获取的值无法内联优化. 

5. 

```java
public class Main {
    public static void main(String[] args) {
        String a = "hello";
        String b =  new String("hello");
        String c =  new String("hello");
        String d = b.intern();
         
        System.out.println(a==b);
        System.out.println(b==c);
        System.out.println(b==d);
        System.out.println(a==d);
    }
}
```

答: 分别为: `false` , `false` , `false` , `true` . `b.intern()` 为本地方法, 会通过常量池查找, 因此, 因此它与 `a` 为同一对象. 

6. `String str = new String("abc")` 创建了多少对象? 

答: 在**类加载**过程中, 在常量池创建了 `"bac"` 对象, 在**代码执行**中创建了字符串对象. 因此这段代码涉及两个对象的创建, 但创建过程分别在不同的阶段. 严格讲, 代码执行过程中只有一个对象创建. 一共创建了两个对象.  

7. 1和2处的代码区别?

```java
public class Main {
    public static void main(String[] args) {
        String str1 = "I";
        //str1 += "love"+"java";        1)
        str1 = str1+"love"+"java";      //2)
         
    }
}
```

答: 1 的效率比 2 的高. 这也涉及到编译器优化, 1 会将 "love" 和 "java" 优化为 "lovejava". 

### ArrayList 和 LinkedList 的区别?

答: 

二者均实现了 `List` 接口. 

* `ArrayList` 底层基于数组实现, 可以使用下标快速访问元素, 支持随机访问(时间复杂度为O(1)), `LinkedList` 使用链表, 访问某个元素需要遍历(时间复杂度为O(n));

* `LinkedList` 因为每个节点保留了与之相邻元素的引用, 所以对于元素的增加/删除等操作更快, `ArrayList` 则因为操作后需要调整数组元素位置, 所以效率会低. 

参看[这篇文章](https://blog.csdn.net/weixin_42468526/article/details/81178698)

### 类的实例化顺序是? 

答: 类加载器实例化时的顺序为 加载 -> 连接 -> 初始化

1）父类的静态成员；静态方法块； -> 2）子类中的静态成员；静态方法块；-> 3）父类中的成员变量；方法块；-> 5）父类构造函数 -> 4）子类中的成员变量；方法块；-> 6）子类构造函数

初始化块的一个问题,参看[这篇文章](https://segmentfault.com/q/1010000008546313)

### Map 类有哪些? HashMap 是否线程安全? 原理是什么? 

答: 常用的 `HashMap`,`HashTable`,`ConcurrentHashMap`,`TreeMap` 等.

`HashMap` 并非线程安全的类. `HashTable`,`ConcurrentHashMap` 被认为是线程安全的, 但 `HashTable` 因为性能问题很少使用了. HashMap的扩容可能导致循环链表. 

`HashMap` 使用数组+链表, 1.8的话使用数组+链表+红黑树实现. 数组的每个元素称为Node或Entry, 存储key,value,hash, next; 当put元素时, 通过元素的key计算其hash值, 并与(capture-1)做 `&` 操作. 从而得到数组的下标. 1.8的实现中, 通过高16位和低16位异或运算来使hash更加分散.  扩容时, 二进制低位不变, 高位+1, 这样更容易计算新元素的下标. 所以 HashMap 的容量为2次方. map 比如有hash碰撞问题发生, 可以使用扰动函数来减少碰撞, 并将key定义为final的对象. 

参看[这篇文章](https://baijiahao.baidu.com/s?id=1618550070727689060&wfr=spider&for=pc)

### Java8的 ConcurrentHashMap 为什么放弃了分段锁, 有什么问题? 如果你来设计该如何实现?

答: 分段锁Segment继承了ReentrantLock, 使用并发度来控制Segment的数量. 所以锁的粒度可以设置, 但不灵活, 也很难保证性能和并发的平衡. Java8的锁有了更好的实现, 锁的粒度控制在只是锁一个Node, 而且只在必要的时候锁. java8并没有使用ReentrantLock, 而是使用synchronized修饰, 这种基于jvm的实现方式可能后期更有利于随着jvm升级. 

可以参看[这篇文章](https://blog.csdn.net/woaiwym/article/details/80675789)

### 有没有有顺序的 Map 实现类， 如果有， 他们是怎么保证有序的?

答: `LinkedHashTable` 或 `TreeMap`. LinkedHashTable 每个Entry节点定义了双向引用, 可以记录元素的插入顺序. 

可以参看[这篇文章](https://uule.iteye.com/blog/1522291).

### 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么?

答: 

1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 
2、抽象类要被子类继承，接口要被类实现。 
3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现 
4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 
5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 
6、抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。 
7、抽象类里可以没有抽象方法 
8、如果一个类里有抽象方法，那么这个类只能是抽象类 
9、抽象方法要被实现，所以不能是静态的，也不能是私有的。 
10、接口可继承接口，并可多继承接口，但类只能单根继承。

### 继承和聚合的区别在哪?

答:继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性； 

聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分； 

### 讲讲你理解的 nio和 bio 的区别是啥，谈谈 reactor 模型?

答: 

