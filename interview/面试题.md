# 面试题

参看: 

[2017 Java面试题](https://blog.csdn.net/huangshulang1234/article/details/79480244)

## Java 基础

### Java 中的几种基本类型? 各占多少字节?

答: 

|基本类型|字节|取值范围|
|--------|---|-------|
|byte|1|-128~127（-2的7次方到2的7次方-1）|
|short|2|-32768~32767（-2的15次方到2的15次方-1）|
|int|4|-2147483648~2147483647（-2的31次方到2的31次方-1）|
|long|8|-9223372036854774808~9223372036854774807（-2的63次方到2的63次方-1）|
|char|2|前128字节编码与ASCII兼容,字符的存储范围在\u0000~\uFFFF|
|float|4|3.402823e+38 ~ 1.401298e-45（e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方）|
|double|8|1.797693e+308~ 4.9000000e-324|
|boolean|4|true / false|

> 注意: JDK 官方文档 boolean 只定义了取值范围为 `true` 或 `false` . 但没有给出具体的占用大小. 看虚拟机的具体实现而定, 可能是4字节的 (int) , 也可能是一字节的 (boolean 数组) .

### String 能否被继承, 为什么?

答:

其定义为 `public final class String implements java.io.Serializable, Comparable<String>, CharSequence {...}` 由关键字 final 修饰, 所以不能被继承.

### String,StringBuilder,StringBuffer 的区别? 什么是常量池? 

答:

三者均通过 `char[] value` 的域变量来保存字符串. String 与二者不同的是, 它的变量 `value` 是使用 `final` 修饰的, 所以其不能被重新赋值, 这也是 String 是不可变变量的原因. 

`StringBuilder` 与 `StringBuffer` API几乎相同, 不同的是 `StringBuffer` 使用了同步 `synchronized` 因此可以认为是线程安全的字符串操作类. 另外, 二者的 `toString()` 方法实现不同, `StringBuffer` 缓存了结果.

```java
// StringBuilder 的实现
@Override
public String toString() {
    // Create a copy, don't share the array
    return new String(value, 0, count);
}


// StringBuffer 的实现

/**
* A cache of the last value returned by toString. Cleared
* whenever the StringBuffer is modified.
*/
private transient char[] toStringCache;

@Override
public synchronized String toString() {
    if (toStringCache == null) {
        toStringCache = Arrays.copyOfRange(value, 0, count);
    }
    return new String(toStringCache, true);
}
```

`StringBuilder` 自1.5开始出现, 是为了提高在单线程环境下字符串操作效率. `StringBuffer` 从1.0 就有了.

三者均使用 `final` 修饰, 不能被继承.

### 下面代码输出结果为?

```java
Double i1 = 100.0;
Double i2 = 100.0;
Double i3 = 200.0;
Double i4 = 200.0;

System.out.println(i1==i2);
System.out.println(i3==i4);

Boolean i1 = false;
Boolean i2 = false;
Boolean i3 = true;
Boolean i4 = true;

System.out.println(i1==i2);
System.out.println(i3==i4);
```

答: Double 装箱类型, 返回的是一个新实例对象, 所以结果均为`false`. 使用了 `valueOf()` 方法

```java
public static Double valueOf(double d) {
   return new Double(d);
}
```

Boolean 装箱类型, 但返回结果均为 `true` . 查看 `valueOf()` 可知返回的字段是两个静态初始化的变量. 

```java
public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false);

public static Boolean valueOf(boolean b) {
   return (b ? TRUE : FALSE);
}
```

### 下面代码的输出分别为? 

1. `String a = "hello2";  String b = "hello" + 2; 　　System.out.println((a == b));` 

答: true 原因是编译期字面量优化, `"hello" + 2` 被优化为 `"hello2"` 了. 

2. `String a = "hello2"; 　  String b = "hello";       String c = b + 2;       System.out.println((a == c));`   

答: false, 无法进行编译器优化, 认为是两个不同的对象. 

3. `String a = "hello2";   　 final String b = "hello";       String c = b + 2;       System.out.println((a == c));` 

答: true, `final` 的变量会内联执行, 所以同问题1一样. 

4. 

```java
public static void main(String[] args) {
    String a = "hello2";
    final String b = getHello();
    String c = b + 2;
    System.out.println((a == c));
}
    
public static String getHello() {
    return "hello";
}
```

答: false, 通过方法获取的值无法内联优化. 

5. 

```java
public class Main {
    public static void main(String[] args) {
        String a = "hello";
        String b =  new String("hello");
        String c =  new String("hello");
        String d = b.intern();
         
        System.out.println(a==b);
        System.out.println(b==c);
        System.out.println(b==d);
        System.out.println(a==d);
    }
}
```

答: 分别为: `false` , `false` , `false` , `true` . `b.intern()` 为本地方法, 会通过常量池查找, 因此, 因此它与 `a` 为同一对象. 

6. `String str = new String("abc")` 创建了多少对象? 

答: 在**类加载**过程中, 在常量池创建了 `"abc"` 对象, 在**代码执行**中创建了字符串对象. (加载-连接(检查-准备-解析)-初始化) 因此这段代码涉及两个对象的创建, 但创建过程分别在不同的阶段. 严格讲, 代码执行过程中只有一个对象创建. 一共创建了两个对象.  

7. 1和2处的代码区别?

```java
public class Main {
    public static void main(String[] args) {
        String str1 = "I";
        //str1 += "love"+"java";        1)
        str1 = str1+"love"+"java";      //2)
         
    }
}
```

答: 1 的效率比 2 的高. 这也涉及到编译器优化, 1 会将 "love" 和 "java" 优化为 "lovejava". 

### ArrayList 和 LinkedList 的区别? 使用场景? 

答: 

二者均实现了 `List` 接口. 

* `ArrayList` 底层基于数组实现, 可以使用下标快速访问元素, 支持随机访问(时间复杂度为O(1)), `LinkedList` 使用链表, 访问某个元素需要遍历(时间复杂度为O(n));

* `LinkedList` 因为每个节点保留了与之相邻元素的引用, 所以对于元素的增加/删除等操作更快, `ArrayList` 则因为操作后需要调整数组元素位置, 所以效率会低. 

* `LinkedList` 因为需要多存储节点之间的引用关系, 所以占用空间会大一点.

参看[这篇文章](https://blog.csdn.net/weixin_42468526/article/details/81178698)

### ArrayList 扩容的原理是什么? 

答: 

`ArryList` 底层使用数组实现, 当容量超过数组大小时会发生扩容, 这个数组又叫做动态数组.    

```java
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

最终调用 native 方法 `public static native void arraycopy(Object src,  int  srcPos,Object dest, int destPos,int length);`

### 类的实例化顺序是? 

答: 类加载器实例化时的顺序为 加载 -> 连接 -> 初始化

1）父类的静态成员；静态方法块； -> 2）子类中的静态成员；静态方法块；-> 3）父类中的成员变量；方法块；-> 5）父类构造函数 -> 4）子类中的成员变量；方法块；-> 6）子类构造函数

初始化块的一个问题,参看[这篇文章](https://segmentfault.com/q/1010000008546313)

### Map 类有哪些? HashMap 是否线程安全? 原理是什么? 自定义对象做 key 需要注意什么? 

答: 常用的 `HashMap`,`HashTable`,`ConcurrentHashMap`,`TreeMap` 等.

`HashMap` 并非线程安全的类. `HashTable`,`ConcurrentHashMap` 被认为是线程安全的(但 `ConcurrentHashMap` 放弃了若一致性要求), 但 `HashTable` 因为性能问题很少使用了. HashMap的扩容可能导致循环链表(1.7). 

`HashMap` 使用数组+链表, 1.8的话使用数组+链表+红黑树实现. 数组称为 Hash 桶, 的每个元素称为Node或Entry, 存储key,value,hash, next; 当put元素时, 通过元素的key计算其hash值, 并与(capture-1)做 `&` 操作. 从而得到数组的下标. 1.8的实现中, 通过高16位和低16位异或运算来使hash更加分散.

扩容原理需要注意两个变量 `threshold` 和 `loadFactor`, threshold = length * LoadFactor. HashTable 扩容一般以容量的2次方增加, 这样设计对重新 hash 效率有好处. 重新Hash 时二进制低位不变, 高位+1, 这样更容易计算新元素的下标. map 有 hash 碰撞问题发生, 可以使用扰动函数来减少碰撞, 并将key定义为final的对象. 

自定义 key 需要同时重写 `hashCode` 和 `equals` 方法, 并保持对象的 hashCode 不可变. 如参与 hashCode 的字段定义为 final. 

> 与HashMap不同的是，ConcurrentHashMap并不允许key或者value为null，按照Doug Lea的说法，这么设计的原因是在ConcurrentHashMap中，一旦value出现null，则代表HashEntry的key/value没有映射完成就被其他线程所见，需要特殊处理。

参看[这篇文章](https://baijiahao.baidu.com/s?id=1618550070727689060&wfr=spider&for=pc)

### Java8的 ConcurrentHashMap 为什么放弃了分段锁, 有什么问题? 还有什么优化? 

答: 

* 分段锁Segment继承了 `ReentrantLock`, 使用并发度来控制Segment的数量. 所以锁的粒度可以设置, 但不灵活, 也很难保证性能和并发的平衡. Java8的锁有了更好的实现, 锁的粒度控制在只是锁一个Node, 而且只在必要的时候加锁. java8并没有使用 `ReentrantLock`, 而是使用 `synchronized` 修饰, 这种基于jvm的实现方式可能后期更有利于随着jvm升级而得到优化. 

`TreeBin` 是包装很多 `TreeNode` 节点的对象. 这个类带有读写锁. 

* 大量使用 CAS 算法. 

* 设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize。

* 使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。

* sizeCtl的不同值来代表不同含义，起到了控制的作用。

可以参看[这篇文章](https://blog.csdn.net/woaiwym/article/details/80675789)

### 有没有有顺序的 Map 实现类， 如果有， 他们是怎么保证有序的?

答: `LinkedHashTable` 或 `TreeMap`. LinkedHashTable 每个Entry节点定义了双向引用, 可以记录元素的插入顺序. TreeMap 需要一个 Comparator 来判断元素key的大小.

可以参看[这篇文章](https://uule.iteye.com/blog/1522291).

### 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么?

答: 

1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 
2、抽象类要被子类继承，接口要被类实现。 
3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现 
4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 
5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 
6、抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。 
7、抽象类里可以没有抽象方法 
8、如果一个类里有抽象方法，那么这个类只能是抽象类 
9、抽象方法要被实现，所以不能是静态的，也不能是私有的。 
10、接口可继承接口，并可多继承接口，但类只能单根继承。

### 继承和聚合的区别在哪?

答:继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性； 

聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分； 

### 讲讲你理解的 nio 和 bio 的区别是啥，谈谈 reactor 模型?

答: nio(non-blocking io 或者 new io)是同步非阻塞io, 采用多路复用机制. 

* 区别1: io 面向流, nio 面向缓存;Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。Java NIO:数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查该缓冲区中是否包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

* 区别2: Java IO的各种流是阻塞的。这意味着，当一个线程调用read()或write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

#### Reactor 模型

IO读写时，多路复用机制都会依赖对一个事件多路分离器，负责把源事件的IO 事件分离出来，分别到相应的read/write事件分离器。涉及到事件分离器的两种模式分别就是 `Reactor` 和 `Proactor` ， Reactor 是基于同步IO的，Proactor是基于异步IO的。Reactor 关注是否可用, Proactor 关注是否完成.

在Reactor模式中，事件分离者等待某个事件或者可应用或个操作的状态发生(比如文件描述符可读写，或者是socket可读写),事件分离者就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。

在Proactor模式中，事件处理者(或者代由事件分离者发起)直接发起一个异步读写操作(相当于请求)，而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区，读的数据大小，或者用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分离者得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。举例来说，在Windows上事件处理者投递了一个异步IO操作(称有 overlapped的技术)，事件分离者等IOCompletion事件完成. 这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。

### 反射的原理，反射创建类实例的三种方式是什么?

答: 

Java反射是Java被视为动态（或准动态）语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括其modifiers（诸如public, static 等）、superclass（例如Object）、实现之interfaces（例如Cloneable），也包括fields和methods的所有信息，并可于运行时改变fields内容或唤起methods。

Java反射机制容许程序在运行时加载、探知、使用编译期间完全未知的classes。

换言之，Java可以加载一个运行时才得知名称的class，获得其完整结构。

* 反射创建类实例的方式: 

1. 调用类的Class对象的newInstance方法，该方法会调用对象的默认构造器，如果没有默认构造器，会调用失败.
2. 调用默认Constructor对象的newInstance方法
3. 调用带参数Constructor对象的newInstance方法

* 获取类的 `Class` 对象的方法?

1. `instance.getClass()`
2. `ClassName.class`
3. `Class.forName("classNameString")`
4. 包装类对象返回原生类: `Boolean.TYPE`

### 反射中，Class.forName 和 ClassLoader 区别? 

答: 

类加载器通过三个步骤装载类, 装载、链接和初始化;

* 装载：查找和导入类或接口的二进制数据； 
* 链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的； 
    * 校验：检查导入类或接口的二进制数据的正确性； 
    * 准备：给类的静态变量分配并初始化存储空间； 
    * 解析：将符号引用转成直接引用； 
* 初始化：激活类的静态变量的初始化Java代码和静态Java代码块。

Class.forName(className)方法，其实调用的方法是`forName0(className, true, ClassLoader.getClassLoader(caller), caller)`;注意看第2个boolean参数，它表示的意思，在loadClass后必须初始化。比较下我们前面准备jvm加载类的知识，我们可以清晰的看到在执行过此方法后，目标对象的 static块代码已经被执行，static参数也已经被初始化。

 再看ClassLoader.loadClass(className)方法，其实他调用的方法是`loadClass(name, false)`;还是注意看第2个 boolean参数，该参数表示目标对象被装载后不进行链接，这就意味这不会去执行该类静态块中间的内容。因此二者的区别就显而易见了。

 ### 描述动态代理的几种实现方式，分别说出相应的优缺点? (动态代理与 cglib 实现的区别?) (为什么 CGlib 方式可以对接口实现代理?)

 答: 

 * jdk : 基于反射, 必须定义要代理的借口, 且必须实现 `InvocationHandler` 接口, 使用反射效率较低, 但JDK6+已经优化了效率. JDK8的效率高于CGLib. 
 * cglib: 基于asm框架, 增强字节码. 但声明为 `final` 的方法无法代理. CGLib原理是动态生成被代理类的子类。

 ### final 的用途?

 答: 
 
 final 修饰的类不能被继承, 方法不能被覆盖, 字段不能被重新赋值. 

* final 的好处:

    * final 关键字提高了性能。JVM 和 Java 应用都会缓存 final 变量。
    * final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
    * 使用final关键字，JVM会对方法、变量及类进行优化。

> 关于final 的知识点: 

> * `final` 关键字可以用于成员变量、本地变量、方法以及类。
> * `final` 成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。
> * 你不能够对 `final` 变量再次赋值。
> * 本地变量必须在声明时赋值。
> * 在匿名类中所有变量都必须是 `final` 变量。
> * `final` 方法不能被重写。
> * `final` 类不能被继承。
> * `final` 关键字不同于 `finally` 关键字，后者用于异常处理。
> * `final` 关键字容易与 `finalize()` 方法搞混，后者是在 `Object` 类中定义的方法，是在垃圾回收之前被 JVM 调用的方法。
> * 接口中声明的所有变量本身是 `final` 的。
> * `final` 和 `abstract` 这两个关键字是反相关的， `final` 类就不可能是 `abstract` 的。
> * `final` 方法在编译阶段绑定，称为静态绑定(static binding)。
> * 没有在声明时初始化 `final` 变量的称为空白 `final` 变量(blank final variable)，它们必须在构造器中初始化，或者调用 `this()` 初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。
> * 将类、方法、变量声明为 `final` 能够提高性能，这样JVM就有机会进行估计，然后优化。
> * 按照 Java 代码惯例， `final` 变量就是常量，而且通常常量名要大写：

### 写出三种单例模式实现?

答: 

参看[设计模式一: 单例模式(Singleton)](https://www.cnblogs.com/walkinhalo/p/9513118.html)

### 如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣?

答: 

Object 本身提供了equals 实现. 某些情况下, 并不需要对类的实例进行逻辑相等判定, 认为每个实例都是唯一的, 那么这种情况下子类就可以使用Object类的实现. 

另外, 父类如果提供了实例间逻辑相等的判定功能, 比如 AbstractSet , AbstractList 等, 则子类可以继承父类的实现. 

hashcode 和 equals 应该同时重写. 

### 请结合 OO 设计理念，谈谈访问修饰符 public、private、protected、default 在应用设计中的作用?

答: 

用于隔离保护. 对于不同的作用域, 使用响应的修饰符保护, 这样可以防止代码被不恰当的调用, 同时减少代码耦合. 

### 深拷贝和浅拷贝区别?

答: 

区别在于引用类型的实例域如何进行拷贝, 对于浅拷贝来说, 实例域会拷贝其上的值, 对于引用类型来说, 相当于拷贝了对象的引用, 而具体的对象由二者共享, 因此不是真正意义上的拷贝, 神拷贝除了复制引用, 同时也将对象同时拷贝一份, 两个对象之间不存在交集, 完全是两个独立的对象. 

### 数组和链表数据结构, 及其时间复杂度

答: 

数组的元素在内存中是顺序存储的, 链表则每个元素有指向前一个和后一个元素的引用, 相邻元素不一定物理上也是相邻的. 

数组支持快速随机访问, 时间复杂度为O(1); 链表为O(n); 
按值查找时, 因为均需要遍历, 时间复杂度为O(n), 有序时时间复杂度可以为O(logn)
插入和删除链表要快O(1) 数组则因为要移动元素.O(n)

### error 和 exception 的区别，CheckedException，RuntimeException 的区别

答: 

error 是错误, 一般虚拟机在发生错误时会退出, 所以此类异常不需要被处理; Exception 是异常, 发生时说明程序代码出现错误, 需要被处理.一般是捕获处理或重新抛出.

CheckedException 是受查异常, 要求代码必须处理的异常， RuntimeException 与 error 一起被称为未受查异常, 发生RuntimeException 时说明是程序问题. 

* Checked异常, 会导致无法编译通过

    * `Java.lang.ClassNotFoundException`
    * `Java.lang.NoSuchMetodException`
    * `java.io.IOException`

* 我们比较熟悉的RumtimeException类的子类有

    * `Java.lang.ArithmeticException`
    * `Java.lang.ArrayStoreExcetpion`
    * `Java.lang.ClassCastException`
    * `Java.lang.IndexOutOfBoundsException`
    * `Java.lang.NullPointerException`

### 在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么

答: 

类加载无须等到“首次使用该类”时加载，jvm允许预加载某些类

### 说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法。

答: 

这两个方法用来判定两个对象是否相等. 这里的相等一般是指逻辑相等. Object 类的实现是根据引用地址来判断的, 因此如果需要通过自定义的相等逻辑, 比如集合相等需要每个元素的值都相等, 来覆盖object 的默认实现. 

### 在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题? 

答: 

泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，泛型的好处是在编译的时候检查类型安全,并且所有的强制转换都是自动和隐式的，以提高代码的重用率 

### hashcode() 有什么用，与 a.equals(b)有什么关系?

答: 

用一个数字来标识对象。比如在HashMap、HashSet等类似的集合类中，如果用某个对象本身作为Key，即要基于这个对象实现Hash的写入和查找，那么对象本身如何实现这个呢？就是基于hashcode这样一个数字来完成的，只有数字才能完成计算和对比操作。

equals相等两个对象，则hashcode一定要相等。但是hashcode相等的两个对象不一定equals相等。 

### 有没有可能 2 个不相等的对象有相同的 hashcode?

答: 有可能

### Java 中的 HashSet 内部是如何工作的?

答: 

对于 HashSet 而言，它是基于 HashMap 实现的，底层采用 HashMap 来保存元素.

### 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决?

答: 

序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。

> `Externalizable` 继承了 `Serializable` ，该接口中定义了两个抽象方法：`writeExternal()` 与 `readExternal()` 。当使用 `Externalizable` 接口来进行序列化与反序列化的时候需要开发人员重写 `writeExternal()` 与` readExternal()` 方法。由于上面的代码中，并没有在这两个方法中定义序列化实现细节，所以输出的内容为空。还有一点值得注意：在使用 `Externalizable` 进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现 `Externalizable` 接口的类必须要提供一个 `public` 的无参的构造器。

虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 `private static final long serialVersionUID`).

## JVM

### 什么情况下会发生栈内存溢出? 什么是内存泄漏?

答: 

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 `StackOverflowError` 异常。
如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出 `OutOfMemoryError` 异常。

当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是 `StackOverflowError` 异常，而不会得到 `OutOfMemoryError` 异常。而在多线程环境下，则会抛出 `OutOfMemoryError` 异常。

### JVM 的内存结构，Eden 和 Survivor 比例?

答: 

HotSpot JVM 把年轻代分为了三部分：1个 Eden 区和2个 Survivor 区（分别叫 from 和 to）。默认比例为8：1. 

### jvm 中一次完整的 GC 流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的 jvm 参数

答:

在 GC 开始的时候，对象只会存在于 Eden 区和名为 “From” 的 Survivor 区，Survivor 区 “To” 是空的。紧接着进行 GC，Eden 区中所有存活的对象都会被复制到 “To”，而在 “From” 区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过`-XX:MaxTenuringThreshold` 来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到 “To” 区域。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，“From” 和 “To” 会交换他们的角色，也就是新的 “To” 就是上次GC前的 “From”，新的 “From” 就是上次 GC 前的 “To”。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

有关年轻代的JVM参数

1. `-XX:NewSize` 和 `-XX:MaxNewSize`

用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。

2. `-XX:SurvivorRatio`

用于设置Eden和其中一个Survivor的比值，这个值也比较重要。

3. `-XX:+PrintTenuringDistribution`

这个参数用于显示每次 Minor GC 时 Survivor 区中各个年龄段的对象的大小。

4. `-XX:InitialTenuringThreshold` 和 `-XX:MaxTenuringThreshold`

用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次 Minor GC 之后，年龄就加1。

参看[这篇文章](https://wangkang007.gitbooks.io/jvm/content/jvmcan_shu_xiang_jie.html)

### 垃圾回收算法? 垃圾标记算法? 你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms，包括原理，流程，优缺点?

答:

#### 标记算法: 

* 引用计数器算法(JDK1.1后淘汰);
* 可达性分析算法;

        GC Roots对象包括：

            1. 虚拟机栈（栈帧中的本地变量表）中的引用的对象。
            2. 方法区域中的类静态属性引用的对象。
            3. 方法区域中常量引用的对象。
            4. 本地方法栈中JNI（Native方法）的引用的对象。

#### 垃圾收集算法: 

1. 标记—清除算法: 标记和清除阶段的效率不高，而且清除后回产生大量的不连续空间

2. 复制算法: 复制算法实现简单，运行效率高，但是由于每次只能使用其中的一半，造成内存的利用率不高。现在的JVM用复制方法收集新生代，由于新生代中大部分对象（98%）都是朝生夕死的，所以两块内存的比例不是1:1(大概是8:1)，也就是常提到的一块Eden(80%)和两块Survivor(20%)。当然也会存在10%不够用的情况，会有一个补偿机制，也就是分配担保

3. 标记—整理算法: 根据老年代的特点提出了标记—整理算法。 标记—整理算法和标记—清除算法一样，但是标记—整理算法不是把存活对象复制到另一块内存，而是把存活对象往内存的一端移动，然后直接回收边界以外的内存

4. 分代收集: 根据各代对象的存活特点，每个代采用不同的垃圾回收算法。新生代采用标记—复制算法，老年代采用标记—整理算法.

#### 收集器:

1. Serial 收集器: 新生代收集器，单线程执行，使用复制算法

2. ParNew 收集器: 多条线程进行垃圾收集之外，其余行为与 Serial 收集器一样; 可以使用 `-XX:+UseParNewGC` 来强制开启，可以通过`-XX:ParallelGCThreads` 来调整或者限制垃圾收集的线程数量

3. Parallel Scavenge 收集器: 是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器; parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 parallel Scavenge 收集器的目标则是达到一个**可控制的吞吐量**。吞吐量=程序运行时间/(程序运行时间 + 垃圾收集时间)，虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。

控制最大垃圾收集停顿时间的`-XX:MaxGCPauseMillis` 参数以及直接设置吞吐量大小的 `-XX:GCTimeRatio` 参数.还有一个参数`-XX:+UseAdaptiveSizePolicy` 值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（`-Xmn`）、Eden与Survivor区的比例（`-XX:SurvivorRatio`）、晋升老年代对象年龄（`-XX:PretenureSizeThreshold`）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）

4. Serial Old 收集器: Serial收集器的老年代版本. 使用“标记－整理”算法,这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途就是作为 CMS 收集器的后备预案，在并发收集发生Concurrent Mode Failure 时使用。这两点都将在后面的内容中详细讲解。

5. Parallel Old 收集器: Parallel Old是Parallel Scavenge 收集器的老年代版本，使用多线程和“标记－整理”算法。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器.

6. CMS (Concurrent Mark Sweep) 收集器:是一种以获取最短回收停顿时间为目标的收集器。

是基于“标记—清除”算法实现的, 分四个步骤: 

    1. 初始标记（CMS initial mark）
    2. 并发标记（CMS concurrent mark）
    3. 重新标记（CMS remark）
    4. 并发清除（CMS concurrent sweep）

初始标记、重新标记这两个步骤仍然需要“Stop The World”. 

CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。

`-XX:+UseCMSCompactAtFullCollection` 开关参数（默认就是开启的）用于在CMS收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。另外一个参数 `-XX:CMSFullGCsBeforeCompaction`，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。

7. G1 收集器: 

具有如下特点:

* 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。

* 分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。

* 空间整合：与 CMS 的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。

* 可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

> 在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。

### g1 和 cms 区别,吞吐量优先和响应优先的垃圾收集器选择?

答: 

Cms是以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现。比较占用cpu资源，切易造成碎片。 
G1是面向服务端的垃圾收集器，是jdk9默认的收集器，基于标记-整理算法实现。可利用多核、多cpu，保留分代，实现可预测停顿，可控。 

CMS是一款优秀的收集器，主要优点：并发收集、低停顿。

缺点：

1. CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。

2. CMS收集器无法处理浮动垃圾，可能会出现“Concurrent Mode Failure（并发模式故障）”失败而导致Full GC产生。

浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随着程序运行自然就会有新的垃圾不断产生，这部分垃圾出现的标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC中再清理。这些垃圾就是“浮动垃圾”。

3. CMS是一款“标记--清除”算法实现的收集器，容易出现大量空间碎片。当空间碎片过多，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。

G1的特点:

G1是一款面向服务端应用的垃圾收集器。G1具备如下特点：

1. 并行于并发：
2. 分代收集：
3. 空间整合：
4. 可预测的停顿：

G1 运作步骤：

1. 初始标记；
2. 并发标记；
3. 最终标记；
4. 筛选回收

上面几个步骤的运作过程和 CMS 有很多相似之处。初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程，但是耗时很短，并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remenbered Set Logs里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到Remembered Set Logs 里面，最终标记阶段需要把Remembered Set Logs 的数据合并到Remembered Set中，这一阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。

CMS 收集器和 G1 收集器的区别: 

* 区别一： 使用范围不一样

CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用
G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用

* 区别二： STW的时间

CMS收集器以最小的停顿时间为目标的收集器。
G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）

* 区别三： 垃圾碎片

CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

* 区别四： 垃圾回收的过程不一样

|步骤|CMS收集器|G1收集器|
|----|---------|-------|
|1|初始标记|初始标记|
|2|并发标记|并发标记|
|3|重新标记|最终标记|
|4|并发清除|筛选回收|

### 当出现了内存溢出，你怎么排错? 如何解决?

答: 

常见的内存溢出问题:

1. 年老代堆空间被占满: 

所有堆空间都被无法回收的垃圾对象占满，虚拟机无法再在分配新空间。这种情况一般来说是因为内存泄漏或者内存不足造成的。

某些情况因为长期的无法释放对象，运行时间长了以后导致对象数量增多，从而导致的内存泄漏.

另外一种就是因为系统的原因，大并发加上大对象，Survivor Space区域内存不够，大量的对象进入到了老年代,然而老年代的内存也不足时，从而产生了Full GC，但是这个时候Full GC也无发回收。这个时候就会产生java.lang.OutOfMemoryError: Java heap space

解决方案如下：

* 代码内的内存泄漏可以通过一些分析工具进行分析，然后找出泄漏点进行改善。
* 第二种原因导致的 `OutOfMemoryError` 可以通过，优化代码和增加 Survivor Space 等方式去优化。

2. 持久代被占满: 

在Java反射大量使用的今天这个异常比较常见了。主要原因就是大量动态反射生成的类不断被加载，最终导致Perm区被占满.

解决方案：

* 增加持久代的空间 `-XX:MaxPermSize=100M`。
* 如果有自定义类加载的需要排查下自己的代码问题。

3. 堆栈溢出

一般就是递归没返回，或者循环调用造成

4. 线程堆栈满

java中一个线程的空间大小是有限制的。JDK5.0以后这个值是1M。与这个线程相关的数据将会保存在其中。但是当线程空间满了以后，将会出现上面异常。 

解决方案：

* 增加线程栈大小。`-Xss2m`。但这个配置无法解决根本问题，还要看代码部分是否有造成泄漏的部分。

5. 系统内存被占满

这个异常是由于操作系统没有足够的资源来产生这个线程造成的。系统创建线程时，除了要在Java堆中分配内存外，操作系统本身也需要分配资源来创建线程。

解决：

* 重新设计系统减少线程数量。
* 线程数量不能减少的情况下，通过`-Xss`减小单个线程大小。以便能生产更多的线程。

### JVM 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等?

答: 

内存屏障：为了保障执行顺序和可见性的一条cpu指令; store load
重排序：为了提高性能，编译器和处理器会对执行进行重排, 编译器重排序; 处理器并行重排序; 内存系统重排序
happen-before：操作间执行的顺序关系。有些操作先发生。 
主内存：共享变量存储的区域即是主内存 
工作内存：每个线程copy的本地内存，存储了该线程以读/写共享变量的副本

参看[这篇文章](https://www.infoq.cn/article/java-memory-model-1)

### 简单说说你了解的类加载器。

答: 

1. Bootstrap ClassLoader

负责加载 `$JAVA_HOME` 中 `jre/lib/rt.jar` 里所有的class，由C++实现，不是ClassLoader子类

2. Extension ClassLoader

负责加载java平台中扩展功能的一些jar包，包括 `$JAVA_HOME` 中 `jre/lib/*.jar` 或 `-Djava.ext.dirs` 指定目录下的jar包

3. App ClassLoader

负责记载classpath中指定的jar包及目录中class

4. Custom ClassLoader

属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader

双亲委派模式: 加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader 到 BootStrap ClassLoader 逐层检查，只要某个 classloader 已加载就视为已加载此类，保证此类只所有 ClassLoader 加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

### 线上应用的 JVM 参数有哪些?

答: 

-server 
-Xms6000M 
-Xmx6000M 
-Xmn500M 
-XX:PermSize=500M 
-XX:MaxPermSize=500M 
-XX:SurvivorRatio=8 
-XX:MaxTenuringThreshold=0 
-Xnoclassgc 
-XX:+DisableExplicitGC 
-XX:+UseParNewGC 
-XX:+UseConcMarkSweepGC 
-XX:+UseCMSCompactAtFullCollection 
-XX:CMSFullGCsBeforeCompaction=0 
-XX:+CMSClassUnloadingEnabled 
-XX:-CMSParallelRemarkEnabled 
-XX:CMSInitiatingOccupancyFraction=90 
-XX:SoftRefLRUPolicyMSPerMB=0 
-XX:+PrintClassHistogram 
-XX:+PrintGCDetails 
-XX:+PrintGCTimeStamps 
-XX:+PrintHeapAtGC 
-Xloggc:log/gc.log

## 开源框架

### 简单讲讲 tomcat 结构，以及其类加载器流程?

### tomcat 如何调优，涉及哪些参数?

