1. 使用FutureTask时候需要注意什么?

答: 线程池使用FutureTask的时候如果拒绝策略设置为了  DiscardPolicy 和 DiscardOldestPolicy 并且在被拒绝的任务的Future对象上调用无参get方法那么调用线程会一直被阻塞。

尽量使用有超时时间参数的get()方法, 或者通过实现`RejectedExecutionHandler`接口自定义拒绝策略.

2. Redis为什么那么快?

答: (1). 基于内存, 无磁盘IO导致的延迟, 使用hash时查找和操作复杂度都是O(1);(2). 数据结构简单, 操作也很简单;(3). 采用单线程, 这样就减少了上下文切换和锁争用, 避免死锁,提高了性能;(4).多路复用IO, 非阻塞;(5). 实现了自己的VM,减少调用系统函数的时间浪费;

3. 微服务架构的缺点:

答: 这些都是相对而言的 (1). 服务相互调用增加数据不一致性; (2). 增加运维成本;(3).增加服务器成本(也可能降低成本);(4). 微服务切分需要更多经验和能力,需要综合业务以及后续业务的发展给出合适的拆分方案.

4. 实际开发中, 用户登陆验证模块遇到的问题?

答: 单点登录（Single Sign On），简称为 SSO

    1. 验证接口受到攻击, 同时有大量同一IP请求进入, 导致接口乃至整个服务器被挂掉, 攻击者是一个创业公司,动机不详; 
        解决方法: 增加白名单, 所有验证走前端, 所有服务端验证方式被禁用, 对于app接口服务器放行; 
    2. 结构混乱, 房天下用户按角色分为C端(广大网友, 购房者卖房者)和B端(经纪人经纪公司)用户, 细分的化还包括S端(搜房内部客服). 同时按层次分为两级, 第一级是通行证用户, 是所有注册搜房的用户大集合, 第二级是子系统账户, 具体就是前面所说的三端用户. 因为历史等诸多方面原因, 各系统分别持有一份用户数据, 其中极容易导致数据不一致, 另外, 对于目前通用的使用手机号和身份证做用户验证来说, 存在一个手机号码对应多个身份证的问题或者反之. 或者存在身份证重复问题. 
        解决方案: 从技术和业务两方面解决: 技术上, 合并用户数据, 使用统一的用户中心, 合并原各自分治的系统模块, 统一由用户中心提供服务; 业务上, 对于提到的多用户问题, 身份证重复问题, 在用户(特别是B端)登陆到系统后给出提示, 综合使用短信验证等方式将问题账号进行合并. 对于涉及的账户余额也进行合并, 余额全部折算成房币的形式. 对于涉及具体业务比如B端用户的客户等, 各系统给出各自方案, 也进行合并. 这样对于活跃用户来说一个月时间可以完成, 剩余未合并的非活用户, 按重要性分别几级, 余额用户为其保留验证入口, 非余额用户系统合并, 对于长时间不活跃且在列举原因外的可以销户处理. 
    
5. 下面代码打印出什么?

```java
public class Test {
    public static void main(String[] args) {
        int j =0;
        for (int i = 0; i < 100; i++) {
            j=j++;
        }
        System.out.println(j);
    }
}
```

答: 答案是0, j++是在运算之前就把j的值复制的=左边的变量了; 从内存模型上理解, 对于 `j=j++` JVM有两个存储区, 一个堆栈, 一个是变量区, 先将j存入堆栈, 然后再将变量区j++, 此时j=1, 但随后将堆栈中的值赋值给变量j,此时j=0. 

6. 下面代码结果是几?

```java
int[] tst = new int[] {1,2,3,4};
List list = Arrays.asList(tst);
System.out.println(list.size());
```

答: 1 原因是基本类型的数组会作为一个对象传入, 而这个对象将称为list的元素. asList的方法签名如下 `public static <T> List<T> asList(T... a)` 其中使用了泛型, 而基本类型不能应用于泛型.

7. switch 语句支持的数据类型?

答: JDK1.7之后开始支持String类型, 之前支持long之外的整形, 如Byte, int, short, char, Enum

8. 缓存击穿的解决方法? 

答: 

* 数据库中不存在的对象查询后也缓存. 

```java
if(objJson!=null){
    redisService.expire("key",timeout:3*60);
} else {
    redisService.expire("key",timeout:5); //5秒内不查询数据库
}
```

* `synchronized` 方法, 不理想, 排队影响性能
* 同步块, 需要双重判定, 否则阻塞的线程均会查询数据库

```java
String value = redisService.get("key");
if(value==null){
    synchronized(lock){
        value = redisService.get("key"); //多线程再次查询,防止数据库多次查询
        if(value==null){
            value = dao.get();
            redisService.set("key",value);
            if(objJson!=null){
                redisService.expire("key",timeout:3*60);
            } else {
                redisService.expire("key",timeout:5); //5秒内不查询数据库
            }
        }
    }
}
```
* 使用`ReentrantLock`的`tryLock()`,else中线程等待一段时间,  这样不阻塞进程

* 使用分布式锁
```java
if(redisService.setNx("key")==true){
    //查询数据库
}
```

* 不设超时时间或设置一个较长的超时时间, 然后判断当前时间是否超过缓存时间, 结合分布式锁, 超过则刷新缓存.

9. 什么是rest? 有什么特征?

答: rest是一种程序架构风格, 为web服务定义了一组约束. 这些约束包括:(1). C/S架构; (2). 无状态;(3). 可缓存;(4).分层系统;(5).按需编码;(6).统一接口. 其中后面三个是rest的比较明显的特征.

10. spring boot 生成随机端口配置?

答: `server.port=0` 或者 `server.port=${random.int[7000,9000]}`

11. ubuntu设置初始密码?

答: `sudo passwd` 按提示设置.

12. 关闭linux防火墙命令?

答: `systemctl stop firewalld`

13. 数据库事务隔离级别如何查看?

答: SQLServer `DBCC USEROPTIONS `  ;   MySQL: `seleect @@tx_isolation`

14. linux`apt`命令相关的?

答: apt的源信息在`/etc/apt/`目录下. sources.list文件保存仓库信息.同目录下的`sources.list.d`文件下的各种.list文件后缀. 

修改源, 1. 备份`sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak` ; 2.修改sources.list内容

15. 修改sh命令dash为bash?

答: 使用命令`ln -sf bash /bin/sh`

16. chrome浏览器无法访问6666端口?

答: chrome默认屏蔽了一些端口, 但开发中可能会指定这些端口, 可以使用参数启动chrome `--explicitly-allowed-ports=6666`

17. 如何解决 RabbitMQ,Kafka 等中间件的消息重复消费问题?

答: RabbitMQ 会在一些极端条件下触发重复消费, 比如: 任务超时, 没有及时返回状态引起任务重新入队列; 另外, 连接 RabbitMQ 的断开也会导致消息重复入队. 

比如Kafka, 消费客户端会在服务端维护一个offset, 但这个值并不是每次都会回写, 而是按一定频率写入服务端, 但如果消费一部分任务后客户端挂掉了, 那再次重启就会出现消费的任务重新消费. 

解决重复消费的问题: 

1. 最佳的方式是消费端做幂等性(最佳方式), 比如数据库唯一约束, redis等key的唯一性. 做处理前检查等.
2. 一致性 hash , 让任务对应于特定的消费端, 并于消费的存储任务执行map, 做状态检测.

18. 如何使 RabbitMQ 的消息顺序执行?

答: 从发布/订阅两个角色都可能导致乱序, 订阅角色看,消息中间件乱序的本质原因是什么, 是多个消费端对一系列有顺序的消息任务处理的并行性, 也就是说, 有顺序的任务被分配到不同的消费端, 而消费端各自消费无法保证有序了. 

RabbitMQ 就是因为上述原因, 另外, Kafka 消费者与分区配置数量不匹配可能也会导致顺序错乱, 除此之外, Kafka消费者如果使用多线程并发处理, 也可能导致乱序问题. 

此外发布角色看, 重试次数大于1时, 也可能导致乱序. 如果第一个批次写入消息失败，而第二个批次写入消息成功，broker会重试写入第一个批次。如果此时第一个批次也写入成功，那么这两个批次的顺序就会跟生产者发送的顺序相反`max.in.flight.requests.per.connection=1`会避免此问题, 但吞吐量下降.

解决方案: 

* 一组有序消息分配给同一个queue, 这个queue由同一个消费者处理. 
* 对于单消费者, 天然不存在这个问题, 但可以使用多线程加快处理速度, 当然每个线程要对应一个有序消息队列. 

19. MQ 消息丢失的问题?

答: 消息丢失可能发生在producer, 消息broker, consumer的任意环节.

解决方案(RabbitMQ):

* RabbitMQ 可以使用其事务功能, `channel.txSelect` ,`channel.txCommit` , `channel.txRollback` 但这种方式会消耗性能.

* 使用 `confirm` 模式. 生产者一般使用此模式避免消息丢失. 

* 开启 RabbitMQ 的持久化队列. 需要两步(1)开启持久化队列;(2)`deleveryMode`设置为2. 此方式可以防止broker导致的丢失.

* 关闭自动`ack`, 手工调用. 此方式可以解决消费端导致的消息丢失. 

解决方案(Kafka):

* (生产者)kafka一般部署为集群, 一般不会丢, 特别设置了`ack=all`
* (消费端)关闭自动提交`offset` , 手工提交; 同时要做好幂等性验证.
* (kafka)

    1. 设置`replication.factor`:副本数大于1
    2. 设置`min.insync.replicas`:最小同步副本大于1
    3. 设置`ack=all` 要求所有副本写入确认才成功
    4. 设置`retries=MAX` 重试次数无限, 不过此项要谨慎使用

20. MQ 中间件的缺点?

答: 

* 增加系统复杂度, 比如重复,顺序,丢失等问题
* 增加系统风险,比如MQ宕机导致的问题
* 一致性问题

21. 各种消息中间件比较?

答:

|特性|ActiveMQ|RabbitMQ|RocketMQ|Kafka|
|----|--------|--------|--------|-----|
|单机吞吐量|万级，比 RocketMQ、Kafka 低一个数量级|同 ActiveMQ|10 万级，支撑高吞吐|10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景|
|topic 数量对吞吐量的影响|||topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic|topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源|
|时效性|ms 级|微秒级，这是 RabbitMQ 的一大特点，延迟最低|ms 级|延迟在 ms 级以内|
|可用性|高，基于主从架构实现高可用|同 ActiveMQ|非常高，分布式架构|非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用|
|消息可靠性|有较低的概率丢失数据|基本不丢|经过参数优化配置，可以做到 0 丢失|同 RocketMQ|
|功能支持|MQ 领域的功能极其完备|基于 erlang 开发，并发能力很强，性能极好，延时很低|MQ 功能较为完善，还是分布式的，扩展性好|功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用|

22. MQ 的高可用?

答: RabbitMQ 主要通过主从实现高可用.  有三种模式：单机模式、普通集群模式、镜像集群模式。

普通集群模式的queue只存在于同一个节点, 其他实例只保留queue的元数据, 当请求到达时从queue所在实例拉取. 缺点很明显, 单实例存储的节点存在宕机不可用风险, 拉取存在性能问题. 

镜像集群模式除了保留queue元数据, 也保留了queue, 也就是各节点间存在消息同步. 这种方式实现了高可用, 但缺点是扩展新节点变得困难. 

Kafka 使用分区和副本实现高可用. 每个topic都有leader和follow角色, leader宕机后会重新选举出新的leader, 因为有副本, 可以保证数据和服务可用. 

23. 修改mysql的root密码?

答: 参看[这篇文章](https://blog.csdn.net/qq_40877422/article/details/79950150);







