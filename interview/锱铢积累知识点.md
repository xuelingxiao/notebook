1. 使用FutureTask时候需要注意什么?

答: 线程池使用FutureTask的时候如果拒绝策略设置为了  DiscardPolicy和 DiscardOldestPolicy并且在被拒绝的任务的Future对象上调用无参get方法那么调用线程会一直被阻塞。参看[线程池使用FutureTask时候需要注意的一点事](https://www.jianshu.com/p/a9f4f4478a00)

尽量使用有超时时间参数的get()方法, 或者通过实现`RejectedExecutionHandler`接口自定义拒绝策略.

2. Redis为什么那么快?

答: (1). 基于内存, 无磁盘IO导致的延迟, 使用hash时查找和操作复杂度都是O(1);(2). 数据结构简单, 操作也很简单;(3). 采用单线程, 这样就减少了上下文切换和锁争用, 避免死锁,提高了性能;(4).多路复用IO, 非阻塞;(5). 实现了自己的VM,减少调用系统函数的时间浪费;

3. 微服务架构的缺点:

答: 这些都是相对而言的 (1). 服务相互调用增加数据不一致性; (2). 增加运维成本;(3).增加服务器成本(也可能降低成本);(4). 微服务切分需要更多经验和能力,需要综合业务以及后续业务的发展给出合适的拆分方案.

4. 实际开发中, 用户登陆验证模块遇到的问题?

答: 单点登录（Single Sign On），简称为 SSO

    1. 验证接口受到攻击, 同时有大量同一IP请求进入, 导致接口乃至整个服务器被挂掉, 攻击者是一个创业公司,动机不详; 
        解决方法: 增加白名单, 所有验证走前端, 所有服务端验证方式被禁用, 对于app接口服务器放行; 
    2. 结构混乱, 房天下用户按角色分为C端(广大网友, 购房者卖房者)和B端(经纪人经纪公司)用户, 细分的化还包括S端(搜房内部客服). 同时按层次分为两级, 第一级是通行证用户, 是所有注册搜房的用户大集合, 第二级是子系统账户, 具体就是前面所说的三端用户. 因为历史等诸多方面原因, 各系统分别持有一份用户数据, 其中极容易导致数据不一致, 另外, 对于目前通用的使用手机号和身份证做用户验证来说, 存在一个手机号码对应多个身份证的问题或者反之. 或者存在身份证重复问题. 
        解决方案: 从技术和业务两方面解决: 技术上, 合并用户数据, 使用统一的用户中心, 合并原各自分治的系统模块, 统一由用户中心提供服务; 业务上, 对于提到的多用户问题, 身份证重复问题, 在用户(特别是B端)登陆到系统后给出提示, 综合使用短信验证等方式将问题账号进行合并. 对于涉及的账户余额也进行合并, 余额全部折算成房币的形式. 对于涉及具体业务比如B端用户的客户等, 各系统给出各自方案, 也进行合并. 这样对于活跃用户来说一个月时间可以完成, 剩余未合并的非活用户, 按重要性分别几级, 余额用户为其保留验证入口, 非余额用户系统合并, 对于长时间不活跃且在列举原因外的可以销户处理. 
    
5. 下面代码打印出什么?

```java
public class Test {
    public static void main(String[] args) {
        int j =0;
        for (int i = 0; i < 100; i++) {
            j=j++;
        }
        System.out.println(j);
    }
}
```

答: 答案是0, j++是在运算之前就把j的值复制的=左边的变量了; 从内存模型上理解, 对于 `j=j++` JVM有两个存储区, 一个堆栈, 一个是变量区, 先将j存入堆栈, 然后再将变量区j++, 此时j=1, 但随后将堆栈中的值赋值给变量j,此时j=0. 

6. 下面代码结果是几?

```java
int[] tst = new int[] {1,2,3,4};
List list = Arrays.asList(tst);
System.out.println(list.size());
```

答: 1 原因是基本类型的数组会作为一个对象传入, 而这个对象将称为list的元素. asList的方法签名如下 `public static <T> List<T> asList(T... a)` 其中使用了泛型, 而基本类型不能应用于泛型.

7. switch 语句支持的数据类型?

答: JDK1.7之后开始支持String类型, 之前支持long之外的整形, 如Byte, int, short, char, Enum

8. 缓存击穿的解决方法? 

答: 

* 数据库中不存在的对象查询后也缓存. 

```java
if(objJson!=null){
    redisService.expire("key",timeout:3*60);
} else {
    redisService.expire("key",timeout:5); //5秒内不查询数据库
}
```

* `synchronized` 方法, 不理想, 排队影响性能
* 同步块, 需要双重判定, 否则阻塞的线程均会查询数据库

```java
String value = redisService.get("key");
if(value==null){
    synchronized(lock){
        value = redisService.get("key"); //多线程再次查询,防止数据库多次查询
        if(value==null){
            value = dao.get();
            redisService.set("key",value);
            if(objJson!=null){
                redisService.expire("key",timeout:3*60);
            } else {
                redisService.expire("key",timeout:5); //5秒内不查询数据库
            }
        }
    }
}
```
* 使用`ReentrantLock`的`tryLock()`,else中线程等待一段时间,  这样不阻塞进程

* 使用分布式锁
```java
if(redisService.setNx("key")==true){
    //查询数据库
}
```

* 不设超时时间或设置一个较长的超时时间, 然后判断当前时间是否超过缓存时间, 结合分布式锁, 超过则刷新缓存.

9. 什么是rest? 有什么特征?

答: rest是一种程序架构风格, 为web服务定义了一组约束. 这些约束包括:(1). C/S架构; (2). 无状态;(3). 可缓存;(4).分层系统;(5).按需编码;(6).统一接口. 其中后面三个是rest的比较明显的特征.

10. spring boot 生成随机端口配置?

答: `server.port=0` 或者 `server.port=${random.int[7000,9000]}`

11. ubuntu设置初始密码?

答: `sudo passwd` 按提示设置.

12. 关闭linux防火墙命令?

答: `systemctl stop firewalld`

13. 数据库事务隔离级别如何查看?

答: SQLServer `DBCC USEROPTIONS `  ;   MySQL: `seleect @@tx_isolation`

14. linux`apt`命令相关的?

答: apt的源信息在`/etc/apt/`目录下. sources.list文件保存仓库信息.同目录下的`sources.list.d`文件下的各种.list文件后缀. 

修改源, 1. 备份`sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak` ; 2.修改sources.list内容

15. 修改sh命令dash为bash?

答: 使用命令`ln -sf bash /bin/sh`
















