# 集合框架的几个问题

*来自小马哥公开课*

## 线程安全的集合

### 将普通的集合转化为线程安全的集合?

通过集合辅助类 `Collections#synchronizedXXX()` 系列方法返回的集合均为线程安全的集合. 此类方法实现了Wrapper模式. 

java9 中可以使用`of()`工厂方法返回不可变对象. 如`Set<Integer> set = Set.of(1,2,3,4,5)`;

## 线程安全List

### List,Vector,CopyOnWriteArrayList比较

`List` 是接口, `Vector` 是实现类, `Vector` 实现了 `List`; `Vector` 是所有方法都同步的, `CopyOnWriteArrayList` 读的方法不加锁, 添加写入等加锁. 

### Arrays.asList() 是否线程安全的

并非线程安全. 可以使用线程安全的方法, 如`Collections.synchronizedList()`, 或者java9 的of()工厂.

## 线程安全的Set

### 如何生成线程安全的Set

* `Collections.synchronizedSet()`
* java9 `of()`
* `CopyOnWriteSet`

### JUC中是否存在线程安全的Set

JUC中不存在相关的Set类. 可以自定义类实现.

### Set#iterator() 方法返回 Iterator 后, 是否可以添加元素

JUC 的 `Iterator` 实现不严格要求fail-fast, 普通的Set的实现则是fail-fast的, 也就不允许添加元素. 

## 线程安全的Map

### `HashTable` , `HashMap` , `ConcurrentHashMap` 区别?

`HashTable` 线程安全, key, value 不能为null  数组+链表
`HashMap` key value都可以为空 链表+红黑树
`ConcurrentHashMap` key value 不能为null  链表+红黑树  JDK6读部分锁 JDK7,8读不需要锁 写都需要锁

### `ConcurrentHashMap` 和 `ConcurrentSkipListMap`

ConcurrentSkipListMap 写的时候不加锁, 内存占用较大, 但效率快. 


## 线程安全的Queue

### `LinkedTransferQueue` 和 `LinkedBlockingQueue` 区别

`LinkedTransferQueue` jdk7 加入的, 性能较高.

### `PriorityBlokingQueue`

`offer()` 和 `add()` 方法不阻塞, queue最大容量是为最大整数. 另外, 正如它的名字一样, `take()`方法将按优先级取出元素,优先级按Comparable实现.

### `SynchronizedQueue`

`offer()` 永远返回false
`take()` 阻塞, 必须被其他线程调用

