# 第八章 泛型程序设计

## 为什么要使用泛型

* 泛型的魅力是使程序有更好的安全性和可读性

## 泛型类型限定

* 使用extends关键字限定泛型必须是某个接口的子类, 可以有多个类型如 `T extends Comparable & Serializable`, 规定限定中至多有一个类, 且这个类必须出现在列表的第一个位置.
* 方法的类型擦除会生成仅返回值类型不同的方法, 在java代码中这是不允许的, 但编译器可以处理这种情况.
* 1.泛型发生在编译阶段;2.所有的类型参数都用他们的限定类型替换,没有则替换为Object;3.桥方法被合成来保持多态;4.为保证安全性必要时插入强制类型转换

## 约束和局限

* 所有的约束均由类型擦除引起

1. 不能用基本类型
2. 运行时的类型查询只适用于原始类型, 如使用instanceof是会编译错误, getCalss()时不同泛型参数返回的Class对象是一样的
3. 不能创建参数化类型的数组, 但是可以声明, 如`MyClass<String> array;`是可以的. 使用泛型的Arraylist吧.
4. 对于可变数量的参数列表, 它的实质是个数组, 所以也受上述约束, 但不会有编译错误, 只会得到一个警告; 除了用`@SuppressWarning("unchecked")`消除警告, java7提供了`@SafeVarargs`标注来标注泛型方法.
5. 不能实例化类型变量, Java8之后最好的解决方式是让调用者提供一个构造器表达式, 使用到了函数式接口`Supplier<T>`;Java8之前使用反射
6. 同样不能构造泛型数组
7. 泛型类的静态上下文类型变量无效
8. 不能抛出或捕获泛型类的实例, 这意味着无法定义Excption的子类
9. 可以消除对受查异常的检查,如`@SuppressWarning("unchecked")`
10. 注意擦除后的冲突, 如泛型的`equals(T t)`方法将于擦除后的Object的同名方法冲突.

