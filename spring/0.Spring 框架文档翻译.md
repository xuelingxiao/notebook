# Spring 框架文档
### Version 5.1.3.RELEASE

---

> 最新的, 更新的笔记, 支持的版本和其他主题,独立的发布版本等, 是在Github Wiki 项目维护的.


* **总览**  历史, 设计哲学, 反馈, 入门. 

* **核心**  IoC容器, 事件, 资源, 国际化(i18n), 验证, 数据绑定, 类型转化, Spring表达式语言(SpEL), 面向切面编程(AOP).

* **测试**  Mock对象, 测试上下文框架(TestContext framework), Spring MVC 测试, WebTestClient.

* **数据访问**  事务, DAO支持, JDBC, ORM, 编组XML.

* **Web Servlet** Spring MVC, WebSocket, SockJS, STOMP 消息. 

* **Web Reactive** Spring WebFlux, WebClient, WebSocket.

* **集成** Remoting, JMS, JCA, JMX, Email, Tasks, Scheduling, Cache.

* **语言** Kotlin, Groovy, 动态语言(Dynamic languages).



*****



# 第一部分 总览

内容:

1. 我们为什么以"Spring"命名
2. Spring及Spring框架的历史
3. 设计哲学
4. 反馈和贡献
5. 入门

**Spring 简化了Java企业应用的创建. 可以提供在企业应用环境下Java生态所需的一切, 同时也支持Kotlin和Groovy作为JVM的替代语言, 根据实际需要,也可以创建多种不同的架构.(architecture). 从Spring Framwork 5.0 开始, Spring需要JDK 8+ 并且已经为JDK9提供开箱即用支持**

Spring提供了广泛的应用场景. 在大型企业应用中,应用往往要存在很长一段时间,并且不得不运行在一个升级周期超出开发人员控制的JDK和服务器上. 而其他的应用则使用内嵌服务器单独运行jar包,或者部署在云环境. 还有一些应用可能独立部署, 根本不需要服务器(例如批处理或集成负载). 

Spring是开源的.背后有长期大量而活跃的根据实际应用案例而提交的反馈.这将帮助Spring成功长期进化.

## 1. 命名"Spring"的含义

"Spring"意思是在不同环境中不同的东西. 能够用来指代Spring项目本身(这是它的发端起始点). 随着时间推移, 其他建立在Spring之上的项目被创建出来. 通常我们称"Spring", 其实是指所有这些项目. 本文档主要聚焦基础: 也就是Spring框架本身.

Spring框架分模块. 可以根据情况选择需要的模块. 核心模块是核心容器, 包含配置模型和依赖注入机制. 还有更多,Spring 框架提供了对不同应用架构的基础支持. 包含消息,事务和持久化,还有Web. 它还包含基于Servlet的MVC框架, 同时提供了对应的交互式框架Web Flux. 

关于模块的提醒: Spring框架jar文件允许JDK9支持的模块路径("Jigsaw"). 在此类应用中, Spring Framework 5 的jar文件带有自动模块名称清单. 它定义了独立于jar工件的语言级别的模块名称（“spring.core”，“spring.context”等）. 当然, Spring在JDK8和9的类路径上都可以正常工作. 

## 2. Spring 和 Spring Framework 的历史

Spring 是为了回应早期复杂的J2EE规范于2003年诞生. 有人认为 Java EE 和 Spring 是竞争关系,实际上,Spring是Java EE 的补充. Spring的编程模型并不是完全拥抱Java EE平台规范, 而是小心地有选择地从EE生态中集成了独立的规范:

1. Servlet API ([JSR 340](https://jcp.org/en/jsr/detail?id=340))

2. WebSocket API ([JSR 356](https://www.jcp.org/en/jsr/detail?id=356))

3. Concurrency Utilities ([JSR 236](https://www.jcp.org/en/jsr/detail?id=236))

4. JSON Binding API ([JSR 367](https://jcp.org/en/jsr/detail?id=367))

5. Bean Validation ([JSR 303](https://jcp.org/en/jsr/detail?id=303))

6. JPA ([JSR 338](https://jcp.org/en/jsr/detail?id=338))

7. JMS ([JSR 914](https://jcp.org/en/jsr/detail?id=914))

8. 如果需要的话,还有 JTA/JCA 做事务协调

Spring Framework 还支持依赖注入([JSR 330](https://www.jcp.org/en/jsr/detail?id=330))和普通注解([JSR 250](https://jcp.org/en/jsr/detail?id=250))规范. 这些规范的实现由开发人员可以用来替换Spring默认提供的机制.

Spring Framework 5.0 开始起, Spring要求Java EE 7以上(e.g. Servlet 3.1+, JPA 2.1+).同时使用新的Java EE 8(e.g. Servlet 4.0, JSON Binding API)以上的新api提供开箱即用.这就保证了Spring完全兼容Timcat8和9, WebSphere9, 还有JBoss EAP 7.

慢慢的,Java EE 在开发中的角色发生了变化. 早期Java EE 和 Spring创建的程序是被部署到应用程序服务器上. 而今天, 归功于Spring Boot, 应用程序以devops或云的方式创建,使用内嵌的Servlet容器, 而且经常变化.自从Spring Framework 5 , WebFlux程序甚至都不需要直接调用Servlet Api了, 它可以运行在非Servlet规范的容器(如Netty)中.

Spring是持续革新和进化的. 超出Spring Framework, 有很多其他项目如Spring Boot, Spring Security,Spring Data,Spring Cload, Spring Batch,还有很多. 每个项目都有它自己的源码仓库, 问题跟踪和发布周期. 从[spring.io/projects](https://spring.io/projects) 可以看到所有项目的列表.

## 3. 设计哲学

当你学习一个框架的时候, 不仅要知道它能干什么, 更重要的是知道它所遵循的原则. 下面是Spring Framework遵循的指导原则.

* 在所有层面提供选择权. Spring允许你尽量延迟设计选择. 例如, 你可以通过配置而不是修改代码就替换掉数据持久化的提供程序.这也同样适用于其他基础设施概念并能集成很多三方API.

* 容纳不同的观点. Spring 拥抱伸缩性, 它并不坚持认为事情应该就这样做. 根据观点不同, 它提供了广泛的应用选择.

* 保持强大的向后兼容性. Spring演化经过精心设计和管理, 可以防止版本之间出现破坏性改变. Spring支持一定范围版本的JDK和第三方库. 便于维护依赖于Spring的程序和库. 

* 关心API设计. Spring团队花费大量精力和时间设计API, 使其直观并且能保持多个版本和持续很多年.

* 高质量的编码, Spring强调有意义的, 实时的,准确的javadoc. 是极少数声称代码简洁且包之间没有循环依赖的项目之一.

## 4. 反馈和贡献

对于如何操作或诊断或调试问题, 我们强烈建议使用StackOverflow, 并且我们有一个问题页清单, 列出了使用建议. 如果你完全确定Spring Framework有问题或者想提交特性, 请使用JIRA问题跟踪.

如果你解决了问题或者修正了建议, 你可以在GitHub上发起PR. 总之,请记住, 除了微不足道的问题,我们希望有个问题存根进行讨论并记录下来供未来参考. 

更多问题请参看顶级页面"贡献"页上的指南.

## 5 入门

如果你刚开始使用Spring, 你可能想要通过创建一个Spring Boot的项目开始Spring之旅. Spring Boot提供了一个快速(也是固化的)方式创建生产就绪的 Spring 程序, 它基于Spring 框架, 信奉约定优于配置,并且设计为快速启动运行. 

你可以使用start.spring.io来生成基础项目, 或者按照"入门"指南一步步创建, 例如"Getting Started Building a RESTful Web Service". 这些指南只关注于当前主题任务, 可以比较容易的理解, 很多都是Spring Boot项目. Spring portfolio还包含其他项目, 当你解决特定问题时你可能会考虑关注下相关的项目.



***



# 核心技术

**这部分指导文档涵盖了Spring Framework不可或缺的所有技术**

这些技术中最重要的,是Spring Framework的Ioc容器. 在吃透了Spring Framework 的IoC容器之后,紧接着是理解Spring的AOP技术. Spring Framework有其自身的AOP框架, 概念上很好理解并且能够满足实际应用中80%的热点需要.

Spring提供了AspectJ集成(这是目前特性最为丰富,当然也是Java企业领域最成熟的AOP实现).

## 1. IoC容器

本章涵盖Spring的IoC容器.

### 1.1 介绍Spring IoC容器和Beans

本节涵盖了Spring Framework对IoC原则的实现. DI是与其密切相关的另一个概念. IoC是一个处理过程,通过这个过程,对象只能通过构造函数参数, 工厂方法参数或在从工厂方法构造或返回的对象实例上设置的属性来定义他们的依赖关系. 当创建这些bean时, 容器去注入这些依赖. 这个过程从根本上反转了由对象自身去控制它所需依赖的方式, 通过直接类构造或类似Service Locator模式的机制.

`org.springframework.beans` 和 `org.springframework.context` 这两个包是IoC容器的基础. `BeanFactory` 接口提供了能够管理任何对象类型的高级配置机制. `ApplicationContext` 是 `BeanFactory` 的一个子类接口. 增加以下功能:

* 易于与Spring的AOP特性集成.
* 消息资源处理(国际化)
* 事件发布
* 应用程序层次的特定上下文,例如:在Web程序中的`WebApplicationContext`.

简言之, `BeanFactory` 提供了配置框架和基本的功能, `ApplicationContext` 增加了诸多企业特性功能.  `ApplicationContext` 是 `BeanFactory` 的一个完整超集, 在本章中专门用于Spring IoC容器的描述. 如果想用`BeanFactory`代替`ApplicationContext`可以参看后面有关`BeanFactory`的内容.

Spring中,构成你程序的骨架并且被Spring IoC容器管理的对象被称为beans. bean就是一个被Spring IoC容器实例化,装配和管理的对象. bean也可以简单的是应用中诸多对象中的一个.bean和他们之间的依赖被映射到容器的配置元数据中.

## 1.2 容器概览

`org.springframework.context.ApplicationContext` 接口代表了Spring IoC容器并且负责实例化,配置,组装bean. 容器通过读取配置元数据获取指令来实例化,配置,组装bean.配置元数据使用XML,Java注解或者Java代码的方式表现.它允许您表达组成应用程序的对象以及这些对象之间丰富的依赖.

Spring提供了`ApplicationContext` 接口的几个实现. 在独立应用中, 通常会创建一个`ClassPathXmlApplicationContext`或`FileSystemXmlApplicationContext`的实例.XML是传统的定义配置的格式, 你也可以通过一小段XML配置来启用这些支持的格式, 指定容器使用Java注解或者代码格式配置. 

在很多的应用场景下, 并不需要显式的实例化一个或多个Spring的IoC容器. 例如, 在Web应用中,`web.xml`文件中大概八行类似的样板化的XML描述就足够了(参看Web程序中便捷的ApplicationContext实例). 如果你使用Spring Tool Suite(一种Eclipse增强开发环境), 能够很轻松地用几次点击鼠标和几个按键生成这样的样板配置.

下图从较高层次展示了Spring如何工作. 你的程序类和配置元数据时结合在一起的, 因此,当`ApplicationContext`创建并实例化后, 你就有了一个可执行系统或程序.
![The Spring Ioc Container](https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/images/container-magic.png)

### 1.2.1 配置元数据

如同上图展示的, Spring IoC 容器使用配置元数据. 配置元数据表现了你作为开发者如何告知Spring容器去实例化,配置并组装程序中的对象.

配置元数据以传统而直观的XML格式提供, 这是本节大部分内容传达的关于Spring IoC容器的关键概念和特性.

*XML不是唯一允许描述元数据的格式. Spring IoC 容器已经弱化了配置以何种格式书写. 当今,许多开发人员更愿意在程序中选择Java配置的方式.*

如何使用其他格式的配置,可以参考下面的信息:

* 注解配置: Spring 2.5引入了注解配置支持
* Java配置: 从Spring3.0开始, Spring JavaConfig项目中的一些特性已经成为Spring Framework的核心. 因此,你可以使用Java而不是XML文件扩展你的应用. 要使用这些新特性, 请参看`@Configuration`,`@Bean`,`@Import`,`@DependsOn`注解.

Spring配置由至少一个,或典型的超过一个由容器管理的bean的定义. XML格式使用`<bean/>`元素配置这些beans, 它嵌套在顶层`<beans/>`元素里面. Java配置则包含在使用`@Configuration`注解的class中,并使用`@Bean`注解方法.

这些bean定义与构成你程序的对象相吻合. 例如, 你定义服务层对象,数据访问层对象,变现层对象如Struts `Action` 实例, 基础对象如Hibernate `SessionFactories`, JMS 队列等. 一般不会在容器中定义细粒度的域对象.因为这通常是DAO或业务逻辑层的任务去创建和加载这些对象. 尽管如此, 你可以使用AspectJ去配置在容器之外创建对象.参看在Spring中使用AspectJ依赖注入领域对象.

下面例子展示了XML配置的基本格式:

``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="..." class="...">   
        <!-- collaborators and configuration for this bean go here
        1. id是区分bean的一个字符串标识符
        2. class 定义bean的类型,使用全限定类名
         -->
    </bean>

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions go here -->

</beans>
```

`id`属性的值指向协作的对象. 本例中没有明确写出.可参看依赖项.

### 1.2.2 实例化容器

`ApplicationContext` 构造参数中的定位参数字符串是让容器从外部变量加载配置. 参数可以是多种资源格式, 例如本地文件系统, Java `CLASSPATH`等.

``` Java
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
```

*学习Spring容器后, 你可能想要了解下Spring的`Resource`抽象, 它提供了一种便捷的从URI格式的资源中读取流的机制. 尤其是,`Resource`路径通常用来构建程序上下文, 这点可参看"程序上下文和资源路径"*

下面例子展示了服务层对象的配置文件:

``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- services -->

    <bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
        <property name="accountDao" ref="accountDao"/>
        <property name="itemDao" ref="itemDao"/>
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for services go here -->

</beans>
```

接下来的例子展示了数据访问层配置:

``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="accountDao"
        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for data access objects go here -->

</beans>
```

前面例子中, 服务层由`PetStoreServiceImpl`类和两个数据读取对象`JpaAccountDao`和`JpaItemDao`(根据JPA对象关系映射标准). `name`指类中的属性,表示bean的名称, `ref`元素指向另一个bean定义. 在`id`与`ref`元素之间的联系表明了对象间的协作依赖关系. 关于对象依赖配置的更多细节, 参看"依赖项".

####　结合XML格式的配置

使用多个xml文件定义bean是有用的. 通常各自的xml文件能分别表示逻辑层或架构中的一个模块.

你可以使用程序上下文构造器从所有这些XML片段中加载bean的定义. 构造器获取多个`resource`资源位置, 就像我们在上节展示的那样. 或者, 使用一个或多个`<import/>`元素从其他文件中加载bean定义. 下面展示了如何这样做:

``` xml
<beans>
    <import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>

    <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>
</beans>
```

上面的例子中, 外部bean定义是从这几个文件加载的: `services.xml`,`messageSource.xml`,`themeSource.xml`. 这些文件的路径相对于导入他们的文件, 因此`services.xml` 必须是与导入文件处在相同路径目录下. 就像你看到的, '/'可以忽略. 虽然路径是相对的,但尽量不要使用'/'. 导入的这些文件的格式必须符合Spring的Schema, 需要有顶级`<beans/>`元素. 必须是有效的XML的bean定义.

*可以但不提倡在父级目录中使用'../'引用文件. 这样会在当前应用程序外创建依赖文件.特别不提倡使用`classpath:`URLs(例如,`classpath:../services.xml`),运行时解析时会选择最近的根路径并且转到它的父目录.Classpath的配置可能会错误地引导到其他的目录下.*
*可以使用绝对路径替代相对路径,例如`file:C:/config/services.xml`或` classpath:/config/services.xml`. 但这样就不灵活地将路径耦合到程序配置中了.一般的做法是可以使用一种间接方式-例如占位符"${...}",  这样系统JVM可以在运行时解析到正确路径上*

命名空间本身提供了导入指令特性. 比纯bean定义更高级的配置特性Spring也有提供. 例如`context`和`util`命名空间.

#### Groovy的Bean定义DSL

外部化元数据配置的更高级例子, bean定义也可以使用Spring的Groovy Bean Definition DSL, 因Gails框架而熟知. 下面演示了".groovy"文件中典型的配置的方式:

``` groovy
beans {
    dataSource(BasicDataSource) {
        driverClassName = "org.hsqldb.jdbcDriver"
        url = "jdbc:hsqldb:mem:grailsDB"
        username = "sa"
        password = ""
        settings = [mynew:"setting"]
    }
    sessionFactory(SessionFactory) {
        dataSource = dataSource
    }
    myService(MyService) {
        nestedBean = { AnotherBean bean ->
            dataSource = dataSource
        }
    }
}
```

这种配置的风格大体上与XML配置相同, 甚至支持XML命名空间. 可以通过`importBeans`指令从XML文件导入bean定义.

### 1.2.3 使用容器

`ApplicationContext`接口是一个能管理注册的bean以及他们之间依赖的高级工厂. 通过方法`T getBean(String name, Class<T> requiredType)` , 可以获取Bean的实例.

`ApplicationContext`允许读取bean定义并访问他们, 如下所示

``` java
// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// retrieve configured instance
PetStoreService service = context.getBean("petStore", PetStoreService.class);

// use configured instance
List<String> userList = service.getUsernameList();
```

Groovy配置的启动也类似. 不过它有Groovy风格的不同上下文实现(同时也支持XML). 下面展示了Groovy配置:

```java
ApplicationContext context = new GenericGroovyApplicationContext("services.groovy", "daos.groovy");
```

最灵活的变量是`GenericApplicationContext`, 其中包含读取器代理, 例如: 对于XML文件, 它使用`XmlBeanDefinitionReader`读取. 如下例:

```java
GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
context.refresh();
```

对于Groovy, 可是使用`GroovyBeanDefinitionReader`, 如下所示:

``` java
GenericApplicationContext context = new GenericApplicationContext();
new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
context.refresh();
```

在相同的`ApplicationContext`中可以混合使用这些读取代理器, 从而从不同资源中读取配置.

可以使用`getBean`获取bean的实例. `ApplicationContext`接口还有一些其他的方法获取bean, 但是理想状态下, 你的程序应该永远不要使用它们. 确实, 你的程序代码压根不应该调用`getBean`方法,因此就一点也不会依赖Spring API. 例如, Spring为多种Web框架的组件集成提供DI功能, 例如controller和JSF管理的Bean, 允许你通过元数据声明依赖的bean(类似包装(autowiring)注解). 

## 1.3 Bean 概览

Spring IoC 容器管理一到多个bean. 这些bean是根据你提供给容器的配置创建的. (例如, 通过XML格式的`<bean />`定义)

在容器内部, 这些bean定义表现为`BeanDefinition`对象. 其包含如下信息 :

* 包含包名的类名: 典型地,bean定义的实际实现类;
* Bean行为配置元素, 标记bean在容器中行为(作用域scope, 生命周期回调等);
* bean的协同或依赖的其他bean的引用.
* 最近创建对象的其他配置信息,例如当使用bean时连接池的池大小或链接数

元数据被解析为一系列组成bean定义的属性, 下面表格列出了这些属性:

Table 1. The bean definition
| 属性 | 参看 |
| ------ | ------ |
| Class | 初始化bean |
| Name | 命名bean |
| Scope | Bean的作用域 |
| Constructor arguments | 依赖注入 |
| Properties | 依赖注入 |
| Autowiring mode | 自动装配协作对象 |
| Lazy initialization mode | 懒加载Bean |
| Initialization method | 初始化回调 |
| Destruction method | 销毁回调 |

bean定义包含如何创建特定bean, 除此之外`ApplicationContext`的实现允许将容器外创建的bean注册进来. 这是通过`getBeanFactory()`方法访问ApplicationContext的 BeanFactory , 该方法默认返回`DefaultListableBeanFactory` 实现. `DefaultListableBeanFactory`支持通过`registerSingleton(..)` 和 `registerBeanDefinition(..)` 方法注册. 尽管可以这样做,应用程序一般还是单纯使用规则的bean定义元数据. 

*bean元数据和单例的手工支持必须尽早注册, 这是为了容器能够在自动装配和其他自省阶段合理解析.重写已经存在的元数据以及已经存在的单例在某些级别上是支持的, 但运行时注册新的bean(与工厂的并发访问)没有得到正式的支持,而且可能导致并发访问异常或bean状态不一致,或两者都有.*

### 1.3.1 命名Bean

每个bean都有一个或多个标识符. 容器内这些标识符必须是唯一的. 一般一个bean只有一个标识符. 但是也可以有多个,多出来的标识符是别名.

XML配置中,`id`或`name`属性用来做标识符. `id`用来精确指定一个id. 按照习惯, 这些名称是字母数字组成的('myBean', 'someService', etc.), 但他们也可以包含特殊字符. 如果你想给bean指定别名,你可以将他们赋值给`name`属性, 用逗号,分号或者空格分割. 在Spring3.1之前, `id`是定义为一个`xsd:ID`类型, 只能是字母. 自从3.1开始将其定义为`xsd:string`类型. 注意`id`的唯一性依然是容器强制的, 而不是XML解析器.

给bean`name`或`id`属性不是必须的. 如果没有指定, 容器会为bean生成一个唯一名称. 尽管这样, 如果你想通过名称引用bean, 或者通过`ref`元素或者是Service Locator风格的查找, 你就必须给bean指定名称. 不给bean指定名称的动机是使用内部类和自动装配. 

> **bean命名约定**

> 给bean命名遵循与给实例域命名相同的约定. 也就是,使用小写字母开头的骆驼命名法. 例如: `accountManager`, `accountService`, `userDao`, `loginController`等.

> 坚持命名bean可以使你的配置易读易理解. 还有, 如果使用Spring AOP, 当给名字相关的一些列bean应用通知时也会有很大帮助. 

*扫描类路径时, Spring会给未命名组件生成名称, 遵循前面描述的规则: 本质上是取类名,然后将首字符小写. 当有多余一个字母并且第一个和第二个字母都是大写时将保留大小写. 这些规则定义在`java.beans.Introspector.decapitalize`(Spring使用)*

#### 在Bean定义之外添加别名

在bean定义内, 你可以给它指定多个名称, 可以使用给`id`指定一个名称, 同时也可以给`name`指定多个(使用分隔符).使用这些名称指定的bean都是等效的, 在某些情况下也是有用的, 例如: 让应用程序中的每个组件通过使用特定于该组件本身的bean名称来引用公共依赖项。

然而在定义bean的时候为其指定别名有时候并不够. 有时候需要将别名bean定义外的其他地方指定. 通常的例子是, 在大型系统内各个子系统分别有各自配置, 每个子系统有一组其bean的定义. XML的配置中,你可以使用`<alias/>`元素实现. 如下:

```xml
<alias name="fromName" alias="toName"/>
```

本例中, bean的名称(同一容器)被命名为`fromName`, 在使用别名定义后, 这个bean通过`toName`也可以引用. 

例如, 子系统A引用了一个数据源叫`subsystemA-dataSource`. 子系统B引用数据源叫`subsystemB-dataSource`. 当主程序都使用这两个系统时, 主程序引用了数据源`myApp-dataSource`. 这三个数据源都指向相同的对象, 你可以将下面的别名配置添加到元数据:

```xml
<alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
<alias name="myApp-dataSource" alias="subsystemB-dataSource"/>
```

现在, 虽然每个组件和主程序都通过一个名称引用了各自唯一的数据源, 并且能保证不会与其他定义冲突(有效创建了命名空间), 然而实际上他们引用的同一个对象.

> **Java 配置**

> 如果使用Java配置, `@Bean`注解可以提供别名, 参看:如何使用`@Bean`注解.

### 1.3.2 实例化Bean

bean定义的本质是创建对象的配方. 当需要时容器将查看bean的配方, 并使用该bean的定义封装的配置元数据来创建(或获取)实际对象.

如果使用XML配置, 要实例化的对象的类型是通过`<bean/>`节点的`class`属性来指定的. `class`属性(对应到`BeanDefinition`实例是`Class`属性)通常是强制的. (例外的情况请参看:使用工厂方法实例化,和Bean定义的继承.) 有两种使用`Class`属性的方法:

* 典型的, 直接指定class, 由容器通过构造器反射的形式直接创建bean. 有点等同于java代码的`new`操作.
* 为包含创建对象的静态工厂方法指定对象的实际类, 少数情况下容器通过静态工厂方法创建bean. 被静态工厂方法创建出来的对象可能是相同的类型或者压根是另一个类型.

> *内部类名称*

> 如果你想要为一个静态内部类配置bean, 你就必须使用内部类的双名称.

> 例如, 你有个类定义为`SomeThing`,在`com.example`包下. `SomeThing`有个静态内部类为`OtherThing`, 那它的`class`属性的值将是`com.example.SomeThing$OtherThing`

> 注意内部类和外部类之间需要使用`$`字母分割.

#### 使用构造器实例化

当使用构造器创建bean时. 所有标准类都可用且都是可与Spring兼容的. 也就是开发时不需要实现任何接口或者遵循特定的编程风格. 简单定义为一个class即可. 尽管如此, 根据使用的IoC容器, 可能你需要定义一个默认构造器.

IoC容器可以管理任何你想要被托管的类. 它不仅限于管理JavaBeans. 大多数Spring用户喜欢在属性后定义getter和sertter模块. 你也可以在容器中定义非bean风格的类. 例如, 如果你想使用遗留代码中完全不遵循JavaBean规范的连接池, Spring也是可以管理的.

使用XML配置指定bean定义 如下:

``` xml
<bean id="exampleBean" class="examples.ExampleBean"/>

<bean name="anotherExample" class="examples.ExampleBeanTwo"/>
```

更多关于构造函数参数和对象构造后属性的赋值, 参看:依赖注入.

#### 静态工厂方法实例化

当定义使用静态工厂构建的bean时, 需要使用`class`属性指定包含静态工厂方法的类, 并且使用`factory-method`属性指定工厂方法.你可以调用该方法(带可选参数, 后面有表述)返回一个对象, 接着这个对象就可以像使用构造器创建出来的一样使用了. 一种这么使用bean定义的场景是在遗留代码中调用静态工厂. 

下面指定了通过调用静态工厂方法创建bean的配置. 这个定义没有指定返回类型, 只是指定了这个类包含静态方法. 在本例中, `createInstance()`方法必须是静态方法. 下面例子展示了如何指定静态方法:

```xml
<bean id="clientService"
    class="examples.ClientService"
    factory-method="createInstance"/>
```

下面展示了使用上述定义的类的代码:

```java
public class ClientService {
    private static ClientService clientService = new ClientService();
    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}
```

有关静态方法的参数和对象从工厂返回后属性的赋值, 参看: 依赖和配置细节. 

#### 使用对象工厂方法实例化

与静态工厂方法实例化类似.容器可以通过调用已存在的bean的非静态工厂方法去创建bean. 要使用这种机制, 可以将`class`留空, 并且在`factory-bean`属性指定当前(或父或祖先)容器中包含用来创建对象的工厂方法的bean. 使用`factory-method`属性设置工厂方法的名称. 下面展示了怎么配置:

```xml
<!-- the factory bean, which contains a method called createInstance() -->
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<!-- the bean to be created via the factory bean -->
<bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/>
```

下面代码展示了对应的java类:

```java
public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }
}
```

工厂类可以有多个工厂方法的定义, 如下所示:

```xml
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/>

<bean id="accountService"
    factory-bean="serviceLocator"
    factory-method="createAccountServiceInstance"/>
```

下面是对应的java类:

```java
public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    private static AccountService accountService = new AccountServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }

    public AccountService createAccountServiceInstance() {
        return accountService;
    }
}
```

关于工厂bean本身如何通过DI管理和配置, 参看:依赖和配置细节.

*Spring文档中,"factory bean"(工厂bean)是指Spring容器中配置的用来通过实例或静态工厂方法创建对象的bean. 相比而言, `FactoryBean`(注意大小写)指Spring特有的`FactoryBean`*

## 1.4 依赖

> 从此处开始升级到5.2.0版本

典型的企业应用不是由单个对象组成的(或用Spring语法来说的bean).就算是最简单的程序也有一些终端用户看起来相互合作的对象来呈现.接下来的这节阐述如何在一个真实的系统中定义一系列的bean, 从而让他们协作达成目标.

### 1.4.1 依赖注入

依赖注入是一个处理过程, 在对象被构造后或者从工厂返回后, 仅仅通过构造函数参数, 工厂方法的参数或者属性赋值的方式来定义他们的依赖(也就是与其他对象协作). 容器在创建bean后注入他们的依赖. 这个处理过程本质上是bean自己去使用类构造和服务定位模式管理初始化和定位它的依赖项的反转(因此叫控制反转).

使用DI原则的代码是清晰的, 并且做到了与提供的依赖项更有效地解耦. 对象不自己定位查找依赖项, 也不知道依赖项的位置和类型.因此, 你的类就更容易被测试, 特别是依赖于接口和抽象类的情况下, 允许你单元测试中使用桩对象或模拟实现.

DI有两个主要的变种: 构造函数依赖注入和属性Setter依赖注入.

#### 构造函数依赖注入

构造函数注入是通过容器调用有若干参数的构造函数完成的, 每个参数代表一个依赖项. 调用带参的静态工厂方法构造bean与此十分类似, 这里讨论对待构造函数构造和静态工厂方法构造是相似的. 下例展示了构造器注入的类定义:

```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

注意这个类没啥特别之处. 它本身就是一个没有实现容器相关接口,基类或使用注解的普通POJO.

#### 构造参数解析

构造参数是通过类型解析匹配的. 如果bean的构造参数没有潜在的二义性, 那么在bean中定义的参数顺序就是bean初始化时的参数顺序. 看下面的代码:

```java
package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}
```

假设`ThingTwo`和`ThingThree`没有继承关系, 没有潜在的二义性. 因此, 下面的配置能很好的起作用, 在`<constructor-arg/>`元素中你不需要制定构造参数的索引或明确制定其类型.

```xml
<beans>
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg ref="beanTwo"/>
        <constructor-arg ref="beanThree"/>
    </bean>

    <bean id="beanTwo" class="x.y.ThingTwo"/>

    <bean id="beanThree" class="x.y.ThingThree"/>
</beans>
```

当另一个bean被引用时, 类型是已知的,匹配能发生(就像前面例子中的处理过程). 当使用简单类型时,例如`<value>true</value>`, Spring不能决定值的类型, 因此无法自动匹配. 再看下面的类:

```java
package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

**构造参数类型匹配**

上述场景中, 如果使用`type`属性给参数指定了类型, 容器就能通过类型匹配. 如下所示:

``` xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```

**构造参数索引**

可以使用`index`属性指定构造函数的参数, 如下:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
```

另外, 如果参数有多个简单类型, 可以使用索引解决多个简单类型参数的二义性.

> 参数是从0开始的.

**构造参数名称**

也可以使用指定构造参数名称消除二义性, 如下:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
```

记住, 要不受限制的使用此功能, 你的代码必须要启用debug标记编译, 这样Spring才能从构造函数查找参数名称. 如果不能或不想启用debug标记, 可以使用`@ConstructorProperties`JDK注解显式添加到构造函数的参数上. 看起来如同下面例子:

```java
package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

#### Setter方式的依赖注入

Setter方式的注入是调用无参构造函数实例化bean或静态工厂方法返回bean之后, 再由容器调用bean的setter方法. 

下例展示了只能用纯setter方式进行注入的类定义. 这个类是传统的java. 是一个没有实现容器相关的接口,基类或添加注解的POJO.

```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

`ApplicationContext`支持构造函数注入和Setter注入. 也支持通过构造函数注入部分依赖后再由Setter注入. 你使用`BeanDefinition`类的形式配置依赖, 这个类与`PropertyEditor`实例协作将属性从一种格式转化为另一种格式. 尽管如此, 大多Spring用户不会直接使用这些类(在编程方面), 而是使用XML `bean`定义, 或者注解注释组件(也就是使用`@Component`,`@Controller`等),或者用`@Configuration`注解的类中使用`@Bean`的java代码配置. 这些资源将在内部转化为`BeanDefinition`实例并用于在IoC容器实例加载. 

> **构造器注入还是Setter注入**

> 因为可以同时混用构造器和Setter注入, 一种比较好的原则是: 强制的依赖使用构造器注入, 可选的依赖则可以使用setter或配置方法. 注意: setter方法上使用`@Required`注解将使得对应属性成为必须的依赖.

> Spring团队提倡构造器注入, 这会让你实现的程序组件是不可变对象并且可以保证依赖不是`null`. 更多的好处是, 构造器注入返回给客户端的组件总是完全被初始化的状态. 还有个边缘效应, 就是大量的构造函数参数是一种不好的代码味道, 暗示着这个类承载了太多的责任并且需要被合理的重构, 实现关注点分离.

> Setter注入应该在依赖是可选的前提下优先使用, 这些依赖可以被赋以合理的默认值. 另外, 非null验证必须要在代码使用依赖的所有地方进行.  使用setter注入的一个好处是: setter方法使得对象的重配置和重注入更易于控制. 通过JMX MBeans管理就是一种setter注入的案例. 

> 使用DI使得特定类更加有意义. 有时候, 当你使用三方类库时, 你并没有源代码, 此时你将手握DI选择权. 例如, 如果三方类没有暴露任何setter方法, 那么使用构造器注入将是唯一途径.

#### 依赖解析过程

容器按照下面阐述的对bean依赖进行解析:

* `ApplicationContext`被创建, 并且使用配置的bean元数据进行初始化. 配置元数据可以是XML,Java code或注解.
* 对于每个bean, 它的依赖以属性,构造函数参数或者静态工厂的参数(如果使用代替普通的构造函数)形式表现. 这些依赖将在bean被创建后提供给bean.
* 每个属性或参数是要被设置的值的定义, 或者是容器中另一个bean的引用.
* 每个属性或参数的值是由特定的格式转换到实际类型的. 默认情况下, Spring能够将字符串格式转化为所有内置类型如: `int`, `long`, `String`, `boolean`等.

Spring容器在创建后对每个bean的配置进行校验. 尽管如此, 在bean被创建后bean的属性才会被赋值. 单例域的并且设置为预实例化(默认情况)的bean在容器创建后被创建. 域的定义参看bean的作用域. 除此之外, bean只有在被请求时才创建. 一个bean的创建会潜在地导致bean的整个图被创建, 也就是bean的依赖,它的依赖的依赖等都被创建和分配. 注意: 依赖解析的不匹配可能会后期表现出来, 也就是第一次创建受影响的bean时. 

> **循环依赖**

> 如果用占主导地位的构造器注入, 就可能会导致无法解析的循环依赖.

> 例如: 类A需要类B,通过构造器参数注入, 相反类B也需要类A,通过构造器注入. 如果配置A,B相互注入给对方, Spring的IoC容器就会在运行时检测到循环引用, 并抛出`BeanCurrentlyInCreationException`. 

> 一种处理这种情况的方法是编辑源代码, 将一个的setter注入改为构造器注入. 相应地避免使用构造器注入而仅仅使用setter. 换句话说, 虽然不提倡, 但可以使用setter注入配置循环依赖. 

> 不同于典型的案例(即没有循环依赖), 在bean A和bean B之间的循环依赖将迫使bean在完全实例化自身前将其注入给对方(这是典型的鸡生蛋蛋生鸡的场景).

总体上你可以信任Spring去做正确的事情. 它在容器加载期间检测配置问题, 如不存在的bean或循环依赖.当bean被真正创建后, Spring会尽量延后设置属性和解析依赖. 这意味着在容器正确加载后, 如果你请求的bean有问题或它的依赖有问题,可能会抛出异常--例如, bean抛出缺失或无效属性的异常. 这种潜在的配置问题的延迟导致的不可见性就是为什么`ApplicationContext`的实现默认会预实例化单例bean. 这种会导致前期一些时间和内存消耗的代价能换来配置问题的及时发现, 就是在`ApplicationContext`被创建时, 而不是以后调用bean时. 你也可以覆盖这种预初始化的配置为延迟初始化.

如果没有循环依赖, 当一个或多个协作的bean被注入到依赖的bean里面, 每个协作bean其实是优先于依赖bean就被完全配置好了. 这意味着如果A依赖B, 容器会在调用A的setter方法之前完全配置好B. 换句话说,这个bean被实例化了(如果它不是预实例化的),它的依赖被设置了, 并且他的生命周期函数(如配置的初始化函数或初始化bean回调函数)也被调用了. 

####　DI的例子

下例使用XML配置setter形式的DI. 一小段bean的定义如下:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- setter injection using the nested ref element -->
    <property name="beanOne">
        <ref bean="anotherExampleBean"/>
    </property>

    <!-- setter injection using the neater ref attribute -->
    <property name="beanTwo" ref="yetAnotherBean"/>
    <property name="integerProperty" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

下面展示了对应的`ExampleBean`类:

```java
public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }
}
```

上例中, setter声明为匹配xml文件中指定的属性, 下面例子使用构造函数注入:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- constructor injection using the nested ref element -->
    <constructor-arg>
        <ref bean="anotherExampleBean"/>
    </constructor-arg>

    <!-- constructor injection using the neater ref attribute -->
    <constructor-arg ref="yetAnotherBean"/>

    <constructor-arg type="int" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

下面展示了对应的`ExampleBean`类定义:

```java
public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}
```

在bean定义的构造函数参数用来通过类`ExampleBean`的构造函数参数注入.

现在改变下例子, 不用构造函数注入, 而使用静态工厂方法返回对象实例:

```xml
<bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance">
    <constructor-arg ref="anotherExampleBean"/>
    <constructor-arg ref="yetAnotherBean"/>
    <constructor-arg value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

下面展示了对应的`ExampleBean`类:

```java
public class ExampleBean {

    // a private constructor
    private ExampleBean(...) {
        ...
    }

    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        // some other operations...
        return eb;
    }
}
```

给静态工厂方法的参数是`<constructor-arg/>`元素提供的, 就像使用构造函数一样. 工厂方法返回的实例类型不需要与包含静态工厂的类的类型一致(本例一致). 一个(非静态)实例工厂本质上使用相同方式(除了使用`factory-bean`而不是`class`属性),所以我们不讨论这些细节.

###　1.4.2 依赖和配置细节