# Spring 框架文档
### Version 5.1.3.RELEASE

---

> 最新的, 更新的笔记, 支持的版本和其他主题,独立的发布版本等, 是在Github Wiki 项目维护的.


* **总览**  历史, 设计哲学, 反馈, 入门. 

* **核心**  IoC容器, 事件, 资源, 国际化(i18n), 验证, 数据绑定, 类型转化, Spring表达式语言(SpEL), 面向切面编程(AOP).

* **测试**  Mock对象, 测试上下文框架(TestContext framework), Spring MVC 测试, WebTestClient.

* **数据访问**  事务, DAO支持, JDBC, ORM, 编组XML.

* **Web Servlet** Spring MVC, WebSocket, SockJS, STOMP 消息. 

* **Web Reactive** Spring WebFlux, WebClient, WebSocket.

* **集成** Remoting, JMS, JCA, JMX, Email, Tasks, Scheduling, Cache.

* **语言** Kotlin, Groovy, 动态语言(Dynamic languages).



*****



# 第一部分 总览

内容:

1. 我们为什么以"Spring"命名
2. Spring及Spring框架的历史
3. 设计哲学
4. 反馈和贡献
5. 入门

**Spring 简化了Java企业应用的创建. 可以提供在企业应用环境下Java生态所需的一切, 同时也支持Kotlin和Groovy作为JVM的替代语言, 根据实际需要,也可以创建多种不同的架构.(architecture). 从Spring Framwork 5.0 开始, Spring需要JDK 8+ 并且已经为JDK9提供开箱即用支持**

Spring提供了广泛的应用场景. 在大型企业应用中,应用往往要存在很长一段时间,并且不得不运行在一个升级周期超出开发人员控制的JDK和服务器上. 而其他的应用则使用内嵌服务器单独运行jar包,或者部署在云环境. 还有一些应用可能独立部署, 根本不需要服务器(例如批处理或集成负载). 

Spring是开源的.背后有长期大量而活跃的根据实际应用案例而提交的反馈.这将帮助Spring成功长期进化.

## 1. 命名"Spring"的含义

"Spring"意思是在不同环境中不同的东西. 能够用来指代Spring项目本身(这是它的发端起始点). 随着时间推移, 其他建立在Spring之上的项目被创建出来. 通常我们称"Spring", 其实是指所有这些项目. 本文档主要聚焦基础: 也就是Spring框架本身.

Spring框架分模块. 可以根据情况选择需要的模块. 核心模块是核心容器, 包含配置模型和依赖注入机制. 还有更多,Spring 框架提供了对不同应用架构的基础支持. 包含消息,事务和持久化,还有Web. 它还包含基于Servlet的MVC框架, 同时提供了对应的交互式框架Web Flux. 

关于模块的提醒: Spring框架jar文件允许JDK9支持的模块路径("Jigsaw"). 在此类应用中, Spring Framework 5 的jar文件带有自动模块名称清单. 它定义了独立于jar工件的语言级别的模块名称（“spring.core”，“spring.context”等）. 当然, Spring在JDK8和9的类路径上都可以正常工作. 

## 2. Spring 和 Spring Framework 的历史

Spring 是为了回应早期复杂的J2EE规范于2003年诞生. 有人认为 Java EE 和 Spring 是竞争关系,实际上,Spring是Java EE 的补充. Spring的编程模型并不是完全拥抱Java EE平台规范, 而是小心地有选择地从EE生态中集成了独立的规范:

1. Servlet API ([JSR 340](https://jcp.org/en/jsr/detail?id=340))

2. WebSocket API ([JSR 356](https://www.jcp.org/en/jsr/detail?id=356))

3. Concurrency Utilities ([JSR 236](https://www.jcp.org/en/jsr/detail?id=236))

4. JSON Binding API ([JSR 367](https://jcp.org/en/jsr/detail?id=367))

5. Bean Validation ([JSR 303](https://jcp.org/en/jsr/detail?id=303))

6. JPA ([JSR 338](https://jcp.org/en/jsr/detail?id=338))

7. JMS ([JSR 914](https://jcp.org/en/jsr/detail?id=914))

8. 如果需要的话,还有 JTA/JCA 做事务协调

Spring Framework 还支持依赖注入([JSR 330](https://www.jcp.org/en/jsr/detail?id=330))和普通注解([JSR 250](https://jcp.org/en/jsr/detail?id=250))规范. 这些规范的实现由开发人员可以用来替换Spring默认提供的机制.

Spring Framework 5.0 开始起, Spring要求Java EE 7以上(e.g. Servlet 3.1+, JPA 2.1+).同时使用新的Java EE 8(e.g. Servlet 4.0, JSON Binding API)以上的新api提供开箱即用.这就保证了Spring完全兼容Timcat8和9, WebSphere9, 还有JBoss EAP 7.

慢慢的,Java EE 在开发中的角色发生了变化. 早期Java EE 和 Spring创建的程序是被部署到应用程序服务器上. 而今天, 归功于Spring Boot, 应用程序以devops或云的方式创建,使用内嵌的Servlet容器, 而且经常变化.自从Spring Framework 5 , WebFlux程序甚至都不需要直接调用Servlet Api了, 它可以运行在非Servlet规范的容器(如Netty)中.

Spring是持续革新和进化的. 超出Spring Framework, 有很多其他项目如Spring Boot, Spring Security,Spring Data,Spring Cload, Spring Batch,还有很多. 每个项目都有它自己的源码仓库, 问题跟踪和发布周期. 从[spring.io/projects](https://spring.io/projects) 可以看到所有项目的列表.

## 3. 设计哲学

当你学习一个框架的时候, 不仅要知道它能干什么, 更重要的是知道它所遵循的原则. 下面是Spring Framework遵循的指导原则.

* 在所有层面提供选择权. Spring允许你尽量延迟设计选择. 例如, 你可以通过配置而不是修改代码就替换掉数据持久化的提供程序.这也同样适用于其他基础设施概念并能集成很多三方API.

* 容纳不同的观点. Spring 拥抱伸缩性, 它并不坚持认为事情应该就这样做. 根据观点不同, 它提供了广泛的应用选择.

* 保持强大的向后兼容性. Spring演化经过精心设计和管理, 可以防止版本之间出现破坏性改变. Spring支持一定范围版本的JDK和第三方库. 便于维护依赖于Spring的程序和库. 

* 关心API设计. Spring团队花费大量精力和时间设计API, 使其直观并且能保持多个版本和持续很多年.

* 高质量的编码, Spring强调有意义的, 实时的,准确的javadoc. 是极少数声称代码简洁且包之间没有循环依赖的项目之一.

## 4. 反馈和贡献

对于如何操作或诊断或调试问题, 我们强烈建议使用StackOverflow, 并且我们有一个问题页清单, 列出了使用建议. 如果你完全确定Spring Framework有问题或者想提交特性, 请使用JIRA问题跟踪.

如果你解决了问题或者修正了建议, 你可以在GitHub上发起PR. 总之,请记住, 除了微不足道的问题,我们希望有个问题存根进行讨论并记录下来供未来参考. 

更多问题请参看顶级页面"贡献"页上的指南.

## 5 入门

如果你刚开始使用Spring, 你可能想要通过创建一个Spring Boot的项目开始Spring之旅. Spring Boot提供了一个快速(也是固化的)方式创建生产就绪的 Spring 程序, 它基于Spring 框架, 信奉约定优于配置,并且设计为快速启动运行. 

你可以使用start.spring.io来生成基础项目, 或者按照"入门"指南一步步创建, 例如"Getting Started Building a RESTful Web Service". 这些指南只关注于当前主题任务, 可以比较容易的理解, 很多都是Spring Boot项目. Spring portfolio还包含其他项目, 当你解决特定问题时你可能会考虑关注下相关的项目.



***



# 核心技术

**这部分指导文档涵盖了Spring Framework不可或缺的所有技术**

这些技术中最重要的,是Spring Framework的Ioc容器. 在吃透了Spring Framework 的IoC容器之后,紧接着是理解Spring的AOP技术. Spring Framework有其自身的AOP框架, 概念上很好理解并且能够满足实际应用中80%的热点需要.

Spring提供了AspectJ集成(这是目前特性最为丰富,当然也是Java企业领域最成熟的AOP实现).

## 1. IoC容器

本章涵盖Spring的IoC容器.

### 1.1 介绍Spring IoC容器和Beans

本节涵盖了Spring Framework对IoC原则的实现. DI是与其密切相关的另一个概念. IoC是一个处理过程,通过这个过程,对象只能通过构造函数参数, 工厂方法参数或在从工厂方法构造或返回的对象实例上设置的属性来定义他们的依赖关系. 当创建这些bean时, 容器去注入这些依赖. 这个过程从根本上反转了由对象自身去控制它所需依赖的方式, 通过直接类构造或类似Service Locator模式的机制.

`org.springframework.beans` 和 `org.springframework.context` 这两个包是IoC容器的基础. `BeanFactory` 接口提供了能够管理任何对象类型的高级配置机制. `ApplicationContext` 是 `BeanFactory` 的一个子类接口. 增加以下功能:

* 易于与Spring的AOP特性集成.
* 消息资源处理(国际化)
* 事件发布
* 应用程序层次的特定上下文,例如:在Web程序中的`WebApplicationContext`.

简言之, `BeanFactory` 提供了配置框架和基本的功能, `ApplicationContext` 增加了诸多企业特性功能.  `ApplicationContext` 是 `BeanFactory` 的一个完整超集, 在本章中专门用于Spring IoC容器的描述. 如果想用`BeanFactory`代替`ApplicationContext`可以参看后面有关`BeanFactory`的内容.

Spring中,构成你程序的骨架并且被Spring IoC容器管理的对象被称为beans. bean就是一个被Spring IoC容器实例化,装配和管理的对象. bean也可以简单的是应用中诸多对象中的一个.bean和他们之间的依赖被映射到容器的配置元数据中.

## 1.2 容器概览

`org.springframework.context.ApplicationContext` 接口代表了Spring IoC容器并且负责实例化,配置,组装bean. 容器通过读取配置元数据获取指令来实例化,配置,组装bean.配置元数据使用XML,Java注解或者Java代码的方式表现.它允许您表达组成应用程序的对象以及这些对象之间丰富的依赖.

Spring提供了`ApplicationContext` 接口的几个实现. 在独立应用中, 通常会创建一个`ClassPathXmlApplicationContext`或`FileSystemXmlApplicationContext`的实例.XML是传统的定义配置的格式, 你也可以通过一小段XML配置来启用这些支持的格式, 指定容器使用Java注解或者代码格式配置. 

在很多的应用场景下, 并不需要显式的实例化一个或多个Spring的IoC容器. 例如, 在Web应用中,`web.xml`文件中大概八行类似的样板化的XML描述就足够了(参看Web程序中便捷的ApplicationContext实例). 如果你使用Spring Tool Suite(一种Eclipse增强开发环境), 能够很轻松地用几次点击鼠标和几个按键生成这样的样板配置.

下图从较高层次展示了Spring如何工作. 你的程序类和配置元数据时结合在一起的, 因此,当`ApplicationContext`创建并实例化后, 你就有了一个可执行系统或程序.
![The Spring Ioc Container](https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/images/container-magic.png)

### 1.2.1 配置元数据

如同上图展示的, Spring IoC 容器使用配置元数据. 配置元数据表现了你作为开发者如何告知Spring容器去实例化,配置并组装程序中的对象.

配置元数据以传统而直观的XML格式提供, 这是本节大部分内容传达的关于Spring IoC容器的关键概念和特性.

*XML不是唯一允许描述元数据的格式. Spring IoC 容器已经弱化了配置以何种格式书写. 当今,许多开发人员更愿意在程序中选择Java配置的方式.*

如何使用其他格式的配置,可以参考下面的信息:

* 注解配置: Spring 2.5引入了注解配置支持
* Java配置: 从Spring3.0开始, Spring JavaConfig项目中的一些特性已经成为Spring Framework的核心. 因此,你可以使用Java而不是XML文件扩展你的应用. 要使用这些新特性, 请参看`@Configuration`,`@Bean`,`@Import`,`@DependsOn`注解.

Spring配置由至少一个,或典型的超过一个由容器管理的bean的定义. XML格式使用`<bean/>`元素配置这些beans, 它嵌套在顶层`<beans/>`元素里面. Java配置则包含在使用`@Configuration`注解的class中,并使用`@Bean`注解方法.

这些bean定义与构成你程序的对象相吻合. 例如, 你定义服务层对象,数据访问层对象,变现层对象如Struts `Action` 实例, 基础对象如Hibernate `SessionFactories`, JMS 队列等. 一般不会在容器中定义细粒度的域对象.因为这通常是DAO或业务逻辑层的任务去创建和加载这些对象. 尽管如此, 你可以使用AspectJ去配置在容器之外创建对象.参看在Spring中使用AspectJ依赖注入领域对象.

下面例子展示了XML配置的基本格式:

``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="..." class="...">   
        <!-- collaborators and configuration for this bean go here
        1. id是区分bean的一个字符串标识符
        2. class 定义bean的类型,使用全限定类名
         -->
    </bean>

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions go here -->

</beans>
```

`id`属性的值指向协作的对象. 本例中没有明确写出.可参看依赖项.

### 1.2.2 实例化容器

`ApplicationContext` 构造参数中的定位参数字符串是让容器从外部变量加载配置. 参数可以是多种资源格式, 例如本地文件系统, Java `CLASSPATH`等.

``` Java
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
```

*学习Spring容器后, 你可能想要了解下Spring的`Resource`抽象, 它提供了一种便捷的从URI格式的资源中读取流的机制. 尤其是,`Resource`路径通常用来构建程序上下文, 这点可参看"程序上下文和资源路径"*

下面例子展示了服务层对象的配置文件:

``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- services -->

    <bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
        <property name="accountDao" ref="accountDao"/>
        <property name="itemDao" ref="itemDao"/>
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for services go here -->

</beans>
```

接下来的例子展示了数据访问层配置:

``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="accountDao"
        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for data access objects go here -->

</beans>
```

前面例子中, 服务层由`PetStoreServiceImpl`类和两个数据读取对象`JpaAccountDao`和`JpaItemDao`(根据JPA对象关系映射标准). `name`指类中的属性,表示bean的名称, `ref`元素指向另一个bean定义. 在`id`与`ref`元素之间的联系表明了对象间的协作依赖关系. 关于对象依赖配置的更多细节, 参看"依赖项".

####　结合XML格式的配置

使用多个xml文件定义bean是有用的. 通常各自的xml文件能分别表示逻辑层或架构中的一个模块.

你可以使用程序上下文构造器从所有这些XML片段中加载bean的定义. 构造器获取多个`resource`资源位置, 就像我们在上节展示的那样. 或者, 使用一个或多个`<import/>`元素从其他文件中加载bean定义. 下面展示了如何这样做:

``` xml
<beans>
    <import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>

    <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>
</beans>
```

上面的例子中, 外部bean定义是从这几个文件加载的: `services.xml`,`messageSource.xml`,`themeSource.xml`. 这些文件的路径相对于导入他们的文件, 因此`services.xml` 必须是与导入文件处在相同路径目录下. 就像你看到的, '/'可以忽略. 虽然路径是相对的,但尽量不要使用'/'. 导入的这些文件的格式必须符合Spring的Schema, 需要有顶级`<beans/>`元素. 必须是有效的XML的bean定义.

*可以但不提倡在父级目录中使用'../'引用文件. 这样会在当前应用程序外创建依赖文件.特别不提倡使用`classpath:`URLs(例如,`classpath:../services.xml`),运行时解析时会选择最近的根路径并且转到它的父目录.Classpath的配置可能会错误地引导到其他的目录下.*
*可以使用绝对路径替代相对路径,例如`file:C:/config/services.xml`或` classpath:/config/services.xml`. 但这样就不灵活地将路径耦合到程序配置中了.一般的做法是可以使用一种间接方式-例如占位符"${...}",  这样系统JVM可以在运行时解析到正确路径上*

命名空间本身提供了导入指令特性. 比纯bean定义更高级的配置特性Spring也有提供. 例如`context`和`util`命名空间.

#### Groovy的Bean定义DSL

外部化元数据配置的更高级例子, bean定义也可以使用Spring的Groovy Bean Definition DSL, 因Gails框架而熟知. 下面演示了".groovy"文件中典型的配置的方式:

``` groovy
beans {
    dataSource(BasicDataSource) {
        driverClassName = "org.hsqldb.jdbcDriver"
        url = "jdbc:hsqldb:mem:grailsDB"
        username = "sa"
        password = ""
        settings = [mynew:"setting"]
    }
    sessionFactory(SessionFactory) {
        dataSource = dataSource
    }
    myService(MyService) {
        nestedBean = { AnotherBean bean ->
            dataSource = dataSource
        }
    }
}
```

这种配置的风格大体上与XML配置相同, 甚至支持XML命名空间. 可以通过`importBeans`指令从XML文件导入bean定义.

### 1.2.3 使用容器

`ApplicationContext`接口是一个能管理注册的bean以及他们之间依赖的高级工厂. 通过方法`T getBean(String name, Class<T> requiredType)` , 可以获取Bean的实例.

`ApplicationContext`允许读取bean定义并访问他们, 如下所示

``` java
// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// retrieve configured instance
PetStoreService service = context.getBean("petStore", PetStoreService.class);

// use configured instance
List<String> userList = service.getUsernameList();
```

Groovy配置的启动也类似. 不过它有Groovy风格的不同上下文实现(同时也支持XML). 下面展示了Groovy配置:

```java
ApplicationContext context = new GenericGroovyApplicationContext("services.groovy", "daos.groovy");
```

最灵活的变量是`GenericApplicationContext`, 其中包含读取器代理, 例如: 对于XML文件, 它使用`XmlBeanDefinitionReader`读取. 如下例:

```java
GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
context.refresh();
```

对于Groovy, 可是使用`GroovyBeanDefinitionReader`, 如下所示:

``` java
GenericApplicationContext context = new GenericApplicationContext();
new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
context.refresh();
```

在相同的`ApplicationContext`中可以混合使用这些读取代理器, 从而从不同资源中读取配置.

可以使用`getBean`获取bean的实例. `ApplicationContext`接口还有一些其他的方法获取bean, 但是理想状态下, 你的程序应该永远不要使用它们. 确实, 你的程序代码压根不应该调用`getBean`方法,因此就一点也不会依赖Spring API. 例如, Spring为多种Web框架的组件集成提供DI功能, 例如controller和JSF管理的Bean, 允许你通过元数据声明依赖的bean(类似包装(autowiring)注解). 

## 1.3 Bean 概览

Spring IoC 容器管理一到多个bean. 这些bean是根据你提供给容器的配置创建的. (例如, 通过XML格式的`<bean />`定义)

在容器内部, 这些bean定义表现为`BeanDefinition`对象. 其包含如下信息 :

* 包含包名的类名: 典型地,bean定义的实际实现类;
* Bean行为配置元素, 标记bean在容器中行为(作用域scope, 生命周期回调等);
* bean的协同或依赖的其他bean的引用.
* 最近创建对象的其他配置信息,例如当使用bean时连接池的池大小或链接数

元数据被解析为一系列组成bean定义的属性, 下面表格列出了这些属性:

Table 1. The bean definition
| 属性 | 参看 |
| ------ | ------ |
| Class | 初始化bean |
| Name | 命名bean |
| Scope | Bean的作用域 |
| Constructor arguments | 依赖注入 |
| Properties | 依赖注入 |
| Autowiring mode | 自动装配协作对象 |
| Lazy initialization mode | 懒加载Bean |
| Initialization method | 初始化回调 |
| Destruction method | 销毁回调 |

bean定义包含如何创建特定bean, 除此之外`ApplicationContext`的实现允许将容器外创建的bean注册进来. 这是通过`getBeanFactory()`方法访问ApplicationContext的 BeanFactory , 该方法默认返回`DefaultListableBeanFactory` 实现. `DefaultListableBeanFactory`支持通过`registerSingleton(..)` 和 `registerBeanDefinition(..)` 方法注册. 尽管可以这样做,应用程序一般还是单纯使用规则的bean定义元数据. 

*bean元数据和单例的手工支持必须尽早注册, 这是为了容器能够在自动装配和其他自省阶段合理解析.重写已经存在的元数据以及已经存在的单例在某些级别上是支持的, 但运行时注册新的bean(与工厂的并发访问)没有得到正式的支持,而且可能导致并发访问异常或bean状态不一致,或两者都有.*

### 1.3.1 命名Bean

每个bean都有一个或多个标识符. 容器内这些标识符必须是唯一的. 一般一个bean只有一个标识符. 但是也可以有多个,多出来的标识符是别名.

XML配置中,`id`或`name`属性用来做标识符. `id`用来精确指定一个id. 按照习惯, 这些名称是字母数字组成的('myBean', 'someService', etc.), 但他们也可以包含特殊字符. 如果你想给bean指定别名,你可以将他们赋值给`name`属性, 用逗号,分号或者空格分割. 在Spring3.1之前, `id`是定义为一个`xsd:ID`类型, 只能是字母. 自从3.1开始将其定义为`xsd:string`类型. 注意`id`的唯一性依然是容器强制的, 而不是XML解析器.

给bean`name`或`id`属性不是必须的. 如果没有指定, 容器会为bean生成一个唯一名称. 尽管这样, 如果你想通过名称引用bean, 或者通过`ref`元素或者是Service Locator风格的查找, 你就必须给bean指定名称. 不给bean指定名称的动机是使用内部类和自动装配. 

> **bean命名约定**

> 给bean命名遵循与给实例域命名相同的约定. 也就是,使用小写字母开头的骆驼命名法. 例如: `accountManager`, `accountService`, `userDao`, `loginController`等.

> 坚持命名bean可以使你的配置易读易理解. 还有, 如果使用Spring AOP, 当给名字相关的一些列bean应用通知时也会有很大帮助. 

*扫描类路径时, Spring会给未命名组件生成名称, 遵循前面描述的规则: 本质上是取类名,然后将首字符小写. 当有多余一个字母并且第一个和第二个字母都是大写时将保留大小写. 这些规则定义在`java.beans.Introspector.decapitalize`(Spring使用)*

#### 在Bean定义之外添加别名

在bean定义内, 你可以给它指定多个名称, 可以使用给`id`指定一个名称, 同时也可以给`name`指定多个(使用分隔符).使用这些名称指定的bean都是等效的, 在某些情况下也是有用的, 例如: 让应用程序中的每个组件通过使用特定于该组件本身的bean名称来引用公共依赖项。

然而在定义bean的时候为其指定别名有时候并不够. 有时候需要将别名bean定义外的其他地方指定. 通常的例子是, 在大型系统内各个子系统分别有各自配置, 每个子系统有一组其bean的定义. XML的配置中,你可以使用`<alias/>`元素实现. 如下:

```xml
<alias name="fromName" alias="toName"/>
```

本例中, bean的名称(同一容器)被命名为`fromName`, 在使用别名定义后, 这个bean通过`toName`也可以引用. 

例如, 子系统A引用了一个数据源叫`subsystemA-dataSource`. 子系统B引用数据源叫`subsystemB-dataSource`. 当主程序都使用这两个系统时, 主程序引用了数据源`myApp-dataSource`. 这三个数据源都指向相同的对象, 你可以将下面的别名配置添加到元数据:

```xml
<alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
<alias name="myApp-dataSource" alias="subsystemB-dataSource"/>
```

现在, 虽然每个组件和主程序都通过一个名称引用了各自唯一的数据源, 并且能保证不会与其他定义冲突(有效创建了命名空间), 然而实际上他们引用的同一个对象.

> **Java 配置**

> 如果使用Java配置, `@Bean`注解可以提供别名, 参看:如何使用`@Bean`注解.

### 1.3.2 实例化Bean

bean定义的本质是创建对象的配方. 当需要时容器将查看bean的配方, 并使用该bean的定义封装的配置元数据来创建(或获取)实际对象.

如果使用XML配置, 要实例化的对象的类型是通过`<bean/>`节点的`class`属性来指定的. `class`属性(对应到`BeanDefinition`实例是`Class`属性)通常是强制的. (例外的情况请参看:使用工厂方法实例化,和Bean定义的继承.) 有两种使用`Class`属性的方法:

* 典型的, 直接指定class, 由容器通过构造器反射的形式直接创建bean. 有点等同于java代码的`new`操作.
* 为包含创建对象的静态工厂方法指定对象的实际类, 少数情况下容器通过静态工厂方法创建bean. 被静态工厂方法创建出来的对象可能是相同的类型或者压根是另一个类型.

> *内部类名称*

> 如果你想要为一个静态内部类配置bean, 你就必须使用内部类的双名称.

> 例如, 你有个类定义为`SomeThing`,在`com.example`包下. `SomeThing`有个静态内部类为`OtherThing`, 那它的`class`属性的值将是`com.example.SomeThing$OtherThing`

> 注意内部类和外部类之间需要使用`$`字母分割.

#### 使用构造器实例化

当使用构造器创建bean时. 所有标准类都可用且都是可与Spring兼容的. 也就是开发时不需要实现任何接口或者遵循特定的编程风格. 简单定义为一个class即可. 尽管如此, 根据使用的IoC容器, 可能你需要定义一个默认构造器.

IoC容器可以管理任何你想要被托管的类. 它不仅限于管理JavaBeans. 大多数Spring用户喜欢在属性后定义getter和sertter模块. 你也可以在容器中定义非bean风格的类. 例如, 如果你想使用遗留代码中完全不遵循JavaBean规范的连接池, Spring也是可以管理的.

使用XML配置指定bean定义 如下:

``` xml
<bean id="exampleBean" class="examples.ExampleBean"/>

<bean name="anotherExample" class="examples.ExampleBeanTwo"/>
```

更多关于构造函数参数和对象构造后属性的赋值, 参看:依赖注入.

#### 静态工厂方法实例化

当定义使用静态工厂构建的bean时, 需要使用`class`属性指定包含静态工厂方法的类, 并且使用`factory-method`属性指定工厂方法.你可以调用该方法(带可选参数, 后面有表述)返回一个对象, 接着这个对象就可以像使用构造器创建出来的一样使用了. 一种这么使用bean定义的场景是在遗留代码中调用静态工厂. 

下面指定了通过调用静态工厂方法创建bean的配置. 这个定义没有指定返回类型, 只是指定了这个类包含静态方法. 在本例中, `createInstance()`方法必须是静态方法. 下面例子展示了如何指定静态方法:

```xml
<bean id="clientService"
    class="examples.ClientService"
    factory-method="createInstance"/>
```

下面展示了使用上述定义的类的代码:

```java
public class ClientService {
    private static ClientService clientService = new ClientService();
    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}
```

有关静态方法的参数和对象从工厂返回后属性的赋值, 参看: 依赖和配置细节. 

#### 使用对象工厂方法实例化

与静态工厂方法实例化类似.容器可以通过调用已存在的bean的非静态工厂方法去创建bean. 要使用这种机制, 可以将`class`留空, 并且在`factory-bean`属性指定当前(或父或祖先)容器中包含用来创建对象的工厂方法的bean. 使用`factory-method`属性设置工厂方法的名称. 下面展示了怎么配置:

```xml
<!-- the factory bean, which contains a method called createInstance() -->
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<!-- the bean to be created via the factory bean -->
<bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/>
```

下面代码展示了对应的java类:

```java
public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }
}
```

工厂类可以有多个工厂方法的定义, 如下所示:

```xml
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/>

<bean id="accountService"
    factory-bean="serviceLocator"
    factory-method="createAccountServiceInstance"/>
```

下面是对应的java类:

```java
public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    private static AccountService accountService = new AccountServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }

    public AccountService createAccountServiceInstance() {
        return accountService;
    }
}
```

关于工厂bean本身如何通过DI管理和配置, 参看:依赖和配置细节.

*Spring文档中,"factory bean"(工厂bean)是指Spring容器中配置的用来通过实例或静态工厂方法创建对象的bean. 相比而言, `FactoryBean`(注意大小写)指Spring特有的`FactoryBean`*

## 1.4 依赖

> 从此处开始升级到5.2.0版本

典型的企业应用不是由单个对象组成的(或用Spring语法来说的bean).就算是最简单的程序也有一些终端用户看起来相互合作的对象来呈现.接下来的这节阐述如何在一个真实的系统中定义一系列的bean, 从而让他们协作达成目标.

### 1.4.1 依赖注入

依赖注入是一个处理过程, 在对象被构造后或者从工厂返回后, 仅仅通过构造函数参数, 工厂方法的参数或者属性赋值的方式来定义他们的依赖(也就是与其他对象协作). 容器在创建bean后注入他们的依赖. 这个处理过程本质上是bean自己去使用类构造和服务定位模式管理初始化和定位它的依赖项的反转(因此叫控制反转).

使用DI原则的代码是清晰的, 并且做到了与提供的依赖项更有效地解耦. 对象不自己定位查找依赖项, 也不知道依赖项的位置和类型.因此, 你的类就更容易被测试, 特别是依赖于接口和抽象类的情况下, 允许你单元测试中使用桩对象或模拟实现.

DI有两个主要的变种: 构造函数依赖注入和属性Setter依赖注入.

#### 构造函数依赖注入

构造函数注入是通过容器调用有若干参数的构造函数完成的, 每个参数代表一个依赖项. 调用带参的静态工厂方法构造bean与此十分类似, 这里讨论对待构造函数构造和静态工厂方法构造是相似的. 下例展示了构造器注入的类定义:

```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

注意这个类没啥特别之处. 它本身就是一个没有实现容器相关接口,基类或使用注解的普通POJO.

#### 构造参数解析

构造参数是通过类型解析匹配的. 如果bean的构造参数没有潜在的二义性, 那么在bean中定义的参数顺序就是bean初始化时的参数顺序. 看下面的代码:

```java
package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}
```

假设`ThingTwo`和`ThingThree`没有继承关系, 没有潜在的二义性. 因此, 下面的配置能很好的起作用, 在`<constructor-arg/>`元素中你不需要制定构造参数的索引或明确制定其类型.

```xml
<beans>
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg ref="beanTwo"/>
        <constructor-arg ref="beanThree"/>
    </bean>

    <bean id="beanTwo" class="x.y.ThingTwo"/>

    <bean id="beanThree" class="x.y.ThingThree"/>
</beans>
```

当另一个bean被引用时, 类型是已知的,匹配能发生(就像前面例子中的处理过程). 当使用简单类型时,例如`<value>true</value>`, Spring不能决定值的类型, 因此无法自动匹配. 再看下面的类:

```java
package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

**构造参数类型匹配**

上述场景中, 如果使用`type`属性给参数指定了类型, 容器就能通过类型匹配. 如下所示:

``` xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```

**构造参数索引**

可以使用`index`属性指定构造函数的参数, 如下:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
```

另外, 如果参数有多个简单类型, 可以使用索引解决多个简单类型参数的二义性.

> 参数是从0开始的.

**构造参数名称**

也可以使用指定构造参数名称消除二义性, 如下:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
```

记住, 要不受限制的使用此功能, 你的代码必须要启用debug标记编译, 这样Spring才能从构造函数查找参数名称. 如果不能或不想启用debug标记, 可以使用`@ConstructorProperties`JDK注解显式添加到构造函数的参数上. 看起来如同下面例子:

```java
package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

#### Setter方式的依赖注入

Setter方式的注入是调用无参构造函数实例化bean或静态工厂方法返回bean之后, 再由容器调用bean的setter方法. 

下例展示了只能用纯setter方式进行注入的类定义. 这个类是传统的java. 是一个没有实现容器相关的接口,基类或添加注解的POJO.

```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

`ApplicationContext`支持构造函数注入和Setter注入. 也支持通过构造函数注入部分依赖后再由Setter注入. 你使用`BeanDefinition`类的形式配置依赖, 这个类与`PropertyEditor`实例协作将属性从一种格式转化为另一种格式. 尽管如此, 大多Spring用户不会直接使用这些类(在编程方面), 而是使用XML `bean`定义, 或者注解注释组件(也就是使用`@Component`,`@Controller`等),或者用`@Configuration`注解的类中使用`@Bean`的java代码配置. 这些资源将在内部转化为`BeanDefinition`实例并用于在IoC容器实例加载. 

> **构造器注入还是Setter注入**

> 因为可以同时混用构造器和Setter注入, 一种比较好的原则是: 强制的依赖使用构造器注入, 可选的依赖则可以使用setter或配置方法. 注意: setter方法上使用`@Required`注解将使得对应属性成为必须的依赖.

> Spring团队提倡构造器注入, 这会让你实现的程序组件是不可变对象并且可以保证依赖不是`null`. 更多的好处是, 构造器注入返回给客户端的组件总是完全被初始化的状态. 还有个边缘效应, 就是大量的构造函数参数是一种不好的代码味道, 暗示着这个类承载了太多的责任并且需要被合理的重构, 实现关注点分离.

> Setter注入应该在依赖是可选的前提下优先使用, 这些依赖可以被赋以合理的默认值. 另外, 非null验证必须要在代码使用依赖的所有地方进行.  使用setter注入的一个好处是: setter方法使得对象的重配置和重注入更易于控制. 通过JMX MBeans管理就是一种setter注入的案例. 

> 使用DI使得特定类更加有意义. 有时候, 当你使用三方类库时, 你并没有源代码, 此时你将手握DI选择权. 例如, 如果三方类没有暴露任何setter方法, 那么使用构造器注入将是唯一途径.

#### 依赖解析过程

容器按照下面阐述的对bean依赖进行解析:

* `ApplicationContext`被创建, 并且使用配置的bean元数据进行初始化. 配置元数据可以是XML,Java code或注解.
* 对于每个bean, 它的依赖以属性,构造函数参数或者静态工厂的参数(如果使用代替普通的构造函数)形式表现. 这些依赖将在bean被创建后提供给bean.
* 每个属性或参数是要被设置的值的定义, 或者是容器中另一个bean的引用.
* 每个属性或参数的值是由特定的格式转换到实际类型的. 默认情况下, Spring能够将字符串格式转化为所有内置类型如: `int`, `long`, `String`, `boolean`等.

Spring容器在创建后对每个bean的配置进行校验. 尽管如此, 在bean被创建后bean的属性才会被赋值. 单例域的并且设置为预实例化(默认情况)的bean在容器创建后被创建. 域的定义参看bean的作用域. 除此之外, bean只有在被请求时才创建. 一个bean的创建会潜在地导致bean的整个图被创建, 也就是bean的依赖,它的依赖的依赖等都被创建和分配. 注意: 依赖解析的不匹配可能会后期表现出来, 也就是第一次创建受影响的bean时. 

> **循环依赖**

> 如果用占主导地位的构造器注入, 就可能会导致无法解析的循环依赖.

> 例如: 类A需要类B,通过构造器参数注入, 相反类B也需要类A,通过构造器注入. 如果配置A,B相互注入给对方, Spring的IoC容器就会在运行时检测到循环引用, 并抛出`BeanCurrentlyInCreationException`. 

> 一种处理这种情况的方法是编辑源代码, 将一个的setter注入改为构造器注入. 相应地避免使用构造器注入而仅仅使用setter. 换句话说, 虽然不提倡, 但可以使用setter注入配置循环依赖. 

> 不同于典型的案例(即没有循环依赖), 在bean A和bean B之间的循环依赖将迫使bean在完全实例化自身前将其注入给对方(这是典型的鸡生蛋蛋生鸡的场景).

总体上你可以信任Spring去做正确的事情. 它在容器加载期间检测配置问题, 如不存在的bean或循环依赖.当bean被真正创建后, Spring会尽量延后设置属性和解析依赖. 这意味着在容器正确加载后, 如果你请求的bean有问题或它的依赖有问题,可能会抛出异常--例如, bean抛出缺失或无效属性的异常. 这种潜在的配置问题的延迟导致的不可见性就是为什么`ApplicationContext`的实现默认会预实例化单例bean. 这种会导致前期一些时间和内存消耗的代价能换来配置问题的及时发现, 就是在`ApplicationContext`被创建时, 而不是以后调用bean时. 你也可以覆盖这种预初始化的配置为延迟初始化.

如果没有循环依赖, 当一个或多个协作的bean被注入到依赖的bean里面, 每个协作bean其实是优先于依赖bean就被完全配置好了. 这意味着如果A依赖B, 容器会在调用A的setter方法之前完全配置好B. 换句话说,这个bean被实例化了(如果它不是预实例化的),它的依赖被设置了, 并且他的生命周期函数(如配置的初始化函数或初始化bean回调函数)也被调用了. 

####　DI的例子

下例使用XML配置setter形式的DI. 一小段bean的定义如下:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- setter injection using the nested ref element -->
    <property name="beanOne">
        <ref bean="anotherExampleBean"/>
    </property>

    <!-- setter injection using the neater ref attribute -->
    <property name="beanTwo" ref="yetAnotherBean"/>
    <property name="integerProperty" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

下面展示了对应的`ExampleBean`类:

```java
public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }
}
```

上例中, setter声明为匹配xml文件中指定的属性, 下面例子使用构造函数注入:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- constructor injection using the nested ref element -->
    <constructor-arg>
        <ref bean="anotherExampleBean"/>
    </constructor-arg>

    <!-- constructor injection using the neater ref attribute -->
    <constructor-arg ref="yetAnotherBean"/>

    <constructor-arg type="int" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

下面展示了对应的`ExampleBean`类定义:

```java
public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}
```

在bean定义的构造函数参数用来通过类`ExampleBean`的构造函数参数注入.

现在改变下例子, 不用构造函数注入, 而使用静态工厂方法返回对象实例:

```xml
<bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance">
    <constructor-arg ref="anotherExampleBean"/>
    <constructor-arg ref="yetAnotherBean"/>
    <constructor-arg value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

下面展示了对应的`ExampleBean`类:

```java
public class ExampleBean {

    // a private constructor
    private ExampleBean(...) {
        ...
    }

    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        // some other operations...
        return eb;
    }
}
```

给静态工厂方法的参数是`<constructor-arg/>`元素提供的, 就像使用构造函数一样. 工厂方法返回的实例类型不需要与包含静态工厂的类的类型一致(本例一致). 一个(非静态)实例工厂本质上使用相同方式(除了使用`factory-bean`而不是`class`属性),所以我们不讨论这些细节.

###　1.4.2 依赖和配置细节

在前面的章节中提到, 你可以定义bean的属性或者通过构造函数参数去引用另外的bean(协作者)或者在行内书写数据值. 为了能这样做, Spring的XML配置可以使用`<property/>`和`<constructor-arg/>`元素包含在bean定义元素中.

#### 纯值数据(原始数据,String等类型)

元素`<property/>`的属性`value`可以指定为书写或构造参数的纯值数据. Spring的转化服务用来将这些值从`String`转化为合适的类型. 下例展示了一组这样的配置:

```xml
<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <!-- results in a setDriverClassName(String) call -->
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
    <property name="username" value="root"/>
    <property name="password" value="masterkaoli"/>
</bean>
```

下例使用`p-`命名空间展示更简洁的XML配置:

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
        destroy-method="close"
        p:driverClassName="com.mysql.jdbc.Driver"
        p:url="jdbc:mysql://localhost:3306/mydb"
        p:username="root"
        p:password="masterkaoli"/>

</beans>
```

上面的XML更为精简. 类型转化是发生在运行时而不是设计时, 除非你使用能够在定义bean时支持属性自动完成的IDE(就像IntelliJ IDEA 或 Spring Tool Suite). 而这样的IDE辅助是我们提倡的.

也可以配置`java.util.Properties`类型的实例, 如下:

``` xml
<bean id="mappings"
    class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">

    <!-- typed as a java.util.Properties -->
    <property name="properties">
        <value>
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        </value>
    </property>
</bean>
```

Spring 容器转化内部`<value/>`元素的内容为`java.util.Properties`的实例, 这是通过使用JavaBeans的`PropertyEditor`机制来实现的. 这是一个捷径, 也是几种Spring团队喜欢使用嵌套`<value/>`而不是`value`属性风格的情况之一. 

#### `idref`元素

`idref`元素仅是一种防止错误的方法, 可以将容器中的另一个bean的id(一个字符串,不是引用)传递给属性或构造参数. 如下所示:

```xml
<bean id="theTargetBean" class="..."/>

<bean id="theClientBean" class="...">
    <property name="targetName">
        <idref bean="theTargetBean"/>
    </property>
</bean>
```

上面bean的定义完全等效于(在运行时)下面的片段:

```xml
<bean id="theTargetBean" class="..." />

<bean id="client" class="...">
    <property name="targetName" value="theTargetBean"/>
</bean>
```

第一种形式优于第二种, 因为使用`idref`标签能够让容器在部署期间检查引用的bean是不是真的存在. 第二种情况下, 传递给bean名为`client`的`targetName`属性的值不会被校验. 仅仅是在`client`被实际实例化的时候会发生类型转化(大多数情况下是严重错误). 如果`client`bean是个原型bean, 则只有在部署容器很久之后才会发现错误和由此产生的异常.  

> `diref`元素的`local`属性不再支持4.0版本的beans XSD, 因为它不再提供常规`bean`引用的值. 当升级到4.0时, 请修改现有的`idref local`引用, 修改为`idref bean`.

`<idref/>`元素带值的一个地方(至少在Spring2.0之前的版本中)是在`ProxyFactoryBean`定义中AOP拦截器的配置. 当你为了防止拼写错拦截器ID而指定拦截器名称时使用`<idref/>`元素.

#### 引用其他bean(协作者)

`ref`元素是在`<constructor-arg/>` 或者 `<property/>`中的不可更改的元素. 在这里, 你将另一个由容器管理的bean(协作者)作为引用的值赋给一个bean的属性. 被引用的bean作为引用被赋值给这个bean的属性, 并且它是在被赋值前就按需初始化的. (如果这个协作者是个单例的话,它已经被容器初始化了).所有引用最终都是另一个对象的引用. 作用域和校验则取决于你是否通过`bean`,`local`,`partent`属性为另一个对象指定ID或名称.

通过`<ref/>`tag的`bean`属性指定目标bean是常见的方式, 并且允许其在同一个容器或父容器中创建任何bean的引用. 不管是不是配置在XML格式的文件. `bean`属性的值可以是目标bean的ID后者是name中的任一值. 下面展示了`ref`元素:

```xml
<ref bean="someBean"/>
```

通过`parent`属性创建的引用指定目标bean是在当前容器的父容器. 其值可能是目标bean的id或name的其中任一值. 目标bean必须在当前容器的父容器中. 主要使用这个属性的场景是: 当你使用了有层次的容器并且在父容器中通过代理proxy包装了一个同名的父bean. 下面是一对使用`parent`的例子:

```xml
<!-- in the parent context -->
<bean id="accountService" class="com.something.SimpleAccountService">
    <!-- insert dependencies as required as here -->
</bean>
```

```xml
<!-- in the child (descendant) context -->
<bean id="accountService" <!-- bean name is the same as the parent bean -->
    class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target">
        <ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
    </property>
    <!-- insert other configuration and dependencies as required here -->
</bean>
```

> 4.0的beans XSD 后`ref`元素的`local`属性不再支持, 因此不需要用它为一个正常的`bean`引用提供值了. 当升级到4.0时请注意修改现有的`ref local`到`ref bean`.

#### 内部的bean

`<bean/>`元素如果定义在`<property/>`或者`<constructor-arg/>`内部, 则表示定义了内部bean, 如下所示:

```xml
<bean id="outer" class="...">
    <!-- instead of using a reference to a target bean, simply define the target bean inline -->
    <property name="target">
        <bean class="com.example.Person"> <!-- this is the inner bean -->
            <property name="name" value="Fiona Apple"/>
            <property name="age" value="25"/>
        </bean>
    </property>
</bean>
```

内部bean定义不需要指定ID或name, 如果指定了, 容器也不会使用它们作为bean的标识符. 容器也会在创建时忽略它们的`scope`标记, 因为内部bean通常都是匿名的, 并且总是跟外部bean一起创建. 一般不可能去单独的访问内部bean, 或者将他们注入到协作bean而不是包装bean中.

作为旁例, 从一个自定义的scope中获取到销毁回调是可能的, 例如对于一个单例bean中作用域为request-scope的内部bean. 内部bean的创建是与外部bean的创建是绑定的, 但是销毁回调使它特定于request生命周期. 这并不是一个普遍的场景, 内部bean一般是与包含它的bean有着相同的作用域. 

#### 集合

`<list/>`,`<set/>`,`<map/>` 和 `<props/>`元素分别
对应于Java集合类型(`Collection`)的`List`, `Set`, `Map`, 和 `Properties`. 下例展示其用法:

```xml
<bean id="moreComplexObject" class="example.ComplexObject">
    <!-- results in a setAdminEmails(java.util.Properties) call -->
    <property name="adminEmails">
        <props>
            <prop key="administrator">administrator@example.org</prop>
            <prop key="support">support@example.org</prop>
            <prop key="development">development@example.org</prop>
        </props>
    </property>
    <!-- results in a setSomeList(java.util.List) call -->
    <property name="someList">
        <list>
            <value>a list element followed by a reference</value>
            <ref bean="myDataSource" />
        </list>
    </property>
    <!-- results in a setSomeMap(java.util.Map) call -->
    <property name="someMap">
        <map>
            <entry key="an entry" value="just some string"/>
            <entry key ="a ref" value-ref="myDataSource"/>
        </map>
    </property>
    <!-- results in a setSomeSet(java.util.Set) call -->
    <property name="someSet">
        <set>
            <value>just some string</value>
            <ref bean="myDataSource" />
        </set>
    </property>
</bean>
```

字典map的键值,或者集set的值, 可以是下面元素的任一:

```xml
bean | ref | idref | list | set | map | props | value | null
```

#### 集合合并

Spring容器支持合并集合. 开发人员可以定义一个父的`<list/>`,`<set/>`,`<map/>` 和 `<props/>`元素,并且子元素的`<list/>`,`<set/>`,`<map/>` 和 `<props/>`可以继承和覆盖父集合的值. 也就是说, 子集合的值是父集合与子集合元素的合并, 子集合的元素覆盖了父集合中的值.

本节讨论父子bean的合并机制. 读者要是不了解父子bean的定义可以参看相关章节,然后再回来.

下例展示了集合的合并:

```xml
<beans>
    <bean id="parent" abstract="true" class="example.ComplexObject">
        <property name="adminEmails">
            <props>
                <prop key="administrator">administrator@example.com</prop>
                <prop key="support">support@example.com</prop>
            </props>
        </property>
    </bean>
    <bean id="child" parent="parent">
        <property name="adminEmails">
            <!-- the merge is specified on the child collection definition -->
            <props merge="true">
                <prop key="sales">sales@example.com</prop>
                <prop key="support">support@example.co.uk</prop>
            </props>
        </property>
    </bean>
<beans>
```

注意`merge=true`的使用, 它在bean`child`的`<props>`元素中名为`adminEmails`. 当`child`被容器解析和初始化后, 最终的实例将有一个`adminEmails`的`Properties`集合, 包含了合并父集合与子集合中`adminEmails`的全部元素. 下面展示了结果:

```
administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk
```

子`Properties`集合的值继承了父`<props/>`, 并且子集合中`support`值覆盖了父集合中的值. 

这种合并行为也同样类似于`<list/>`, `<map/>`, 和 `<set/>`等集合类型. 在`<list/>`元素的特定情况下, 其语义与`List`集合类型相关联(也就是一个一系列值的有序集合). 父集合的值优先于子集合的值. 在`Map`, `Set`, 和 `Properties`类型情况下, 元素间不存在顺序. 因此,容器内部使用构筑在`Map`,`Set`,`Properties`实现类型之上的无序集合类型. 

#### 集合合并的限制

不能合并不同的集合类型(如`Map`和`List`进行合并). 如果这样做, 会抛出相应异常. `merge`属性必须在继承或者较低的子定义上. 指定在父集合定义上的`merge`是多余的,也不会产生期望的合并.

#### 强类型集合

从Java5的泛型集合开始, 你可以使用强类型的集合了. 也就是声明一个值包含(例如)String 类型的元素集合成为可能. 如果使用Spring的DI去注入一个强类型集合, 你可以得到Spring类型转化支持, 将先前添加到`Collection`的元素转化为正确的类型. 下例展示了用法:

```java
public class SomeClass {

    private Map<String, Float> accounts;

    public void setAccounts(Map<String, Float> accounts) {
        this.accounts = accounts;
    }
}
```

```xml
<beans>
    <bean id="something" class="x.y.SomeClass">
        <property name="accounts">
            <map>
                <entry key="one" value="9.99"/>
                <entry key="two" value="2.75"/>
                <entry key="six" value="3.99"/>
            </map>
        </property>
    </bean>
</beans>
```

当bean`something`的`account`属性准备注入时, 它的泛型类型信息被反射获取到. 因此, Spring的类型转化基础设施辨别出元素的值是`Float`, 并且将字符串值(`9.99,2.75 和 3.99`)转化为实际的`Float`类型.

#### Null和空字符值

Spring将properties的空参数视为空字符串. 下面的XML配置片段设置`email`属性为空值("").

```xml
<bean class="ExampleBean">
    <property name="email" value=""/>
</bean>
```

上面的例子等效于下面的Java代码:

```java
exampleBean.setEmail("");
```

`<null/>`元素处理null值. 如下所示:

```xml
<bean class="ExampleBean">
    <property name="email">
        <null/>
    </property>
</bean>
```

上面代码等效于:

```java
exampleBean.setEmail(null);
```

#### XML的p-命名空间

p-命名空间可以在`bean`元素的属性中使用,(而不是嵌套的`<property/>`元素), 可以用来描述属性值或协作bean.

Spring支持用命名空间扩展配置格式, 这基于XML架构定义. 这节讨论的`bean`配置格式定义在XML架构文档中. 尽管如此, p-命名空间没有定义在XSD文件中, 值存在于Spring的核心. 

下面展示了两段XML(第一段是标准的XML, 第二段是p-命名空间), 他们有相同的结果:

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean name="classic" class="com.example.ExampleBean">
        <property name="email" value="someone@somewhere.com"/>
    </bean>

    <bean name="p-namespace" class="com.example.ExampleBean"
        p:email="someone@somewhere.com"/>
</beans>
```

这个例子展示了bean定义中有个p-命名空间叫`email`. 这实际是告诉Spring有个属性声明. 如前面提到的, p-命名空间没有架构定义, 因此你可以用属性的名字设置标签属性名称. 

下面展示了两个bean定义中同时引用了另一个bean.

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean name="john-classic" class="com.example.Person">
        <property name="name" value="John Doe"/>
        <property name="spouse" ref="jane"/>
    </bean>

    <bean name="john-modern"
        class="com.example.Person"
        p:name="John Doe"
        p:spouse-ref="jane"/>

    <bean name="jane" class="com.example.Person">
        <property name="name" value="Jane Doe"/>
    </bean>
</beans>
```

这个例子包含了不止是用p-命名空间的一个属性, 而且使用了声明属性引用的格式. 第一个bean定义使用`<property name="spouse" ref="jane"/>`创建了从bean`john`到`jane`的引用, 第二个定义则使用了`p:spouse-ref="jane"`来完成相同的事情. 本例中, `spouse`是属性名, 同时`-ref`表明这不是一个表值而是对另一个bean的引用.

> p-命名空间不如标准xml格式灵活. 例如, 声明属性引用的这种格式与使用`ref`的格式冲突. 而标准的XML则不会. 我们强烈建议你细心选用合适的方式, 与团队沟通来避免产生同时使用三种格式的XML文档. 

#### XML的c-命名空间

类似于p-命名空间. 从Spring3.1开始, c-命名空间允许将构造参数配置在行内, 而不是单独嵌套的`<constructor-arg/>`元素内.

下例使用`c:`命名空间实现与构造函数注入相同的事情:

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:c="http://www.springframework.org/schema/c"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="beanTwo" class="x.y.ThingTwo"/>
    <bean id="beanThree" class="x.y.ThingThree"/>

    <!-- traditional declaration with optional argument names -->
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg name="thingTwo" ref="beanTwo"/>
        <constructor-arg name="thingThree" ref="beanThree"/>
        <constructor-arg name="email" value="something@somewhere.com"/>
    </bean>

    <!-- c-namespace declaration with argument names -->
    <bean id="beanOne" class="x.y.ThingOne" c:thingTwo-ref="beanTwo"
        c:thingThree-ref="beanThree" c:email="something@somewhere.com"/>

</beans>
```

`c:`命名空间使用与`p:`命名空间相同的约定来设置构造函数参数(对于引用使用`-ref`后缀).相似的, 需要声明在XML文件中, 虽然在XSD架构中未定义(它存在于Spring的内核中).

对于少数构造函数名称不可用的情况(通常是没有debug信息的已编译二进制文件),可以使用参数索引, 如下:

``` xml
<!-- c-namespace index declaration -->
<bean id="beanOne" class="x.y.ThingOne" c:_0-ref="beanTwo" c:_1-ref="beanThree"
    c:_2="something@somewhere.com"/>
```

> 鉴于XML语法, 索引必须以`_`开头, 因为XML属性名称不能以数字开头(虽然一些IDE可以). 相应的,元素`<constructor-arg>`中也可使用索引数字,但不常用, 因为声明时的顺序已经足够了. 

实践中, 构造函数解析机制对于匹配参数已经足够了, 所以除非你真正需要, 我们建议使用名称标记贯穿整个程序. 

#### 复合属性名称

在设置bean属性时可以使用复合或者嵌套的属性名称. 只要路径下所有组件不为`null`即可. 如下定义:

```xml
<bean id="something" class="things.ThingOne">
    <property name="fred.bob.sammy" value="123" />
</bean>
```

`something`bean有个`fred`属性, `fred`又有个`bob`属性, `bob`有个`sammy`属性, 最终`sammy`属性被赋值为`123`. 为了能使其起作用, 在bean被构建后, `fred`和其`bob`必须不为`null`.否则`NullPointerException`将被抛出.

### 1.4.3 使用`depend-on`

如果一个bean是另一个bean的依赖, 也就意味着一个bean会作为另一个bean的属性值. 在XML配置中你使用`<ref/>`元素来配置. 但有时候bean之间的依赖关系不是直接的. 举个例子, 一个类的静态初始化器需要被触发,比如对于数据库驱动注册. `depends-on`属性能够显式的迫使一个或多个bean的初始化, 这发生在使用了这个元素的bean初始化之前. 下例使用`depends-on`展示只有一个bean的依赖:

```xml
<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
<bean id="manager" class="ManagerBean" />
```

对于多个依赖, 可以为`depends-on`属性指定多个值(用分号,空格, 逗号分隔)

```xml
<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
    <property name="manager" ref="manager" />
</bean>

<bean id="manager" class="ManagerBean" />
<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
```

> `depends-on`属性能够指定初始化期间的依赖. 仅在单例bean中, 指定相应的销毁期依赖. 用`depends-on`关系定义的依赖bean将被首先销毁, 优先于它自身修饰的bean. 因此, `depends-on`可以用来控制关闭顺序.

### 1.4.4 延迟加载的bean

默认情况下,`ApplicationContext`实现会立马创建和配置所有单例bean, 作为其初始化步骤的一部分. 通常,预初始化时令人满意的, 因为配置和环境错误可以被及时发现, 而不是经过几小时,几天. 当这种行为不令人满意时, 你可以通过将bean定义为延迟加载而阻止预初始化发生. 一个延迟加载的bean告知IoC容器,这个bean是在第一次请求时创建,而不是容器启动时.

XML中, 通过`<bean/>`元素的`lazy-init`属性控制这种行为. 如下:

```xml
<bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/>
<bean name="not.lazy" class="com.something.AnotherBean"/>
```

当上面的配置被`ApplicationContext`处理时, 其启动时`lazy`bean不会被立即初始化, 而`not.lazy`bean将立即被初始化.

尽管如此, 当一个延迟初始化bean是一个非延迟初始化bean的依赖时, `ApplicationContext`在启动时创建了延迟bean, 因为它必须满足单例的依赖. 延迟初始化bean被注入到非延迟的单例bean中了. 

也可以在容器级别通过`<beans/>`元素的`default-lazy-init`属性控制延迟加载行为. 如下所示:

```xml
<beans default-lazy-init="true">
    <!-- no beans will be pre-instantiated... -->
</beans>
```

### 1.4.5 自动装配

Spring容器能够自动装配协作bean之间的关系. 你可以让容器通过检查`ApplicationContext`中的内容自动解析协作bean. 自动装配有如下好处:

* 自动装配可以显著减少指定属性和构造参数的需要. (对于本章其他地方讨论的bean模板等机制也是有价值的).

* 自动配置可以随着对象发展而更新配置. 例如, 如果需要向类添加依赖,则可以自动满足依赖而不需手工配置. 因此,自动装配在开发阶段很有用, 不会在代码变得更稳定时拒绝切换到显式书写的选项. 

当时用XML配置时(参看依赖注入), 你可以通过`<bean/>`元素的`autowire`属性为一个bean指定自动装配模式. 自动装配功能有四种模式. 你可以任选其一. 下表描述了这四种模式:

Table2. 自动装配模式

| 模式 | 说明|
|------|-----|
|no    |(默认)不使用自动装配. bean的引用必须使用`ref`元素. 对于较大部署不推荐修改这个模式设置. 因为显式指定的协作者提供了各大的控制权和可读性. 某种意义上是一个系统的架构文档.|
|byName|通过属性名称自动装配. Spring通过名称查找需要自动装配的bean. 例如: 如果一个bean定义按名字自动装配, 并且包含了一个`master`属性(也就是同时有`setMaster(..)`方法), Spring会查找名为`master`的bean定义, 并且将其设置到属性.|
|byType|如果容器中有匹配property类型的bean就自动装配. 如果多于一个, 将抛出致命异常, 这表明可能不应该使用`byType`匹配. 如果没有匹配的bean, 则忽略(属性不被赋值)|
|constructor|与`byType`类似但是是提供给构造函数参数的. 如果容器中没有精确类型的bean, 致命错误将发生|

通过`byType`和`constructor`装配模式, 你可以装配数组和泛型集合. 这种情况下, 容器中所有类型匹配的候选对象都将提供以满足依赖. 对于`Map`,如果key的类型是`String`,你就可以自动装配. 一个自动装配的`Map`实例的值是由所有匹配类型的bean组成的, 这个实例的key包含对应bean的名称. 

#### 自动装配的限制和不足

自动装配使用在贯穿整个项目的过程中能工作得很好. 如果不是普遍使用, 而只是使用到一两个bean上时会搞得开发人员头晕. 

参考自动装配的限制和不足:

* `property`和`constructor-arg`设置的显式依赖总是会覆盖自动装配. 不能自动装配简单类型,`String`和`Class`(或者这些类型的数组). 这个限制是专门设计的. 

* 比起显式装配, 自动装配精确度较低. 虽然, 正如前面表格提到的, Spring非常小心地避免在多个期望结果下导致的二义性进行猜测. Spring管理的对象间的关系以及不是显式文档定义的了. 

* 装配信息可能是不可用的, 对于从Spring容器生成的文档的工具而言.

* 容器内多个bean定义可能会匹配到自动装配的setter类型或构造参数类型.对于数组,或者`Map`实例, 这不是一个问题. 然而对于期望单一值的依赖, 这种二义性不能被随意处理, 如果没有唯一bean可用,异常将会抛出.  

对于后面的几种场景, 你可能有如下几个选择:

* 抛弃自动装配, 拥抱显式装配

* 设置bean的`autowire-candidate`为`false`以防止自动装配, 正像下一节描述的.

* 通过设置`<bean/>`元素的`primary`属性为`true`将其定义为优先匹配对象. 

* 使用有更多细粒度控制的注解驱动配置, 如在注解配置中描述的.

#### 从自动配置中排除bean

在单个bean级别, 你可以从自动装配中排除bean.在XML配置中, 可以通过设置bean的`autowire-candidate`为`false`. 容器能使得特定bean排除在自动装配之外(包括注解格式的配置如`@Autowired`).

> `autowire-candidate`属性被设计为仅对基于类型的装配有效. 对于通过name引用的显式引用无效, 即使指定的bean没有被标记为候选也会被解析. 结果就是当名字匹配时, 通过name自动装配仍然会注入bean. 

你可以通过基于bean名称的模式匹配去限制bean的自动装配. 根级别元素`<beans/>`通过属性`default-autowire-candidate`接收一个或多个模式.例如:限制名称以`Repository`结尾的bean的候选状态, 可以使用模式`*Repository`. 可以通过逗号分隔多个模式. bean元素上的`autowire-candidate`属性的值`true`或`false`总是有优先权. 对于这些bean, 模式规则不生效.

这些技术对于从没想要通过自动装配注入的bean是有用的. 这并不意味着被排除的bean自己不能通过自动装配所配置, 而是它本身将不会作为bean的候选装配给其他bean.

### 1.4.6 方法注入

大多数应用场景中, 容器中的很多bean都是单例的. 当一个单例的bean需要与另一个单例bean协作, 或者一个非单例bean需要与另一个非单例bean协作时, 一般需要通过将一个bean作为另一个bean的属性来处理依赖关系. 当bean的生命周期不同时将会发生问题. 假设一个单例bean A需要一个非单例(原型)bean B, 也许每个方法都有调用. 容器只创建A一次, 因此只有一次机会设置它的属性. 一旦有用到, 容器不能总是使用B的新实例提供给A.

一种解决方案就是抛弃依赖注入. 你可以使一个Bean A 通过实现接口`ApplicationContextAware`被容器所感知, 并且a通过`getBean("B")`请求容器每次都获得到b的新实例.下面代码演示了这种方法:

```java
// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean("command", Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
```

上面代码并不令人满意, 因为业务代码与Spring框架耦合在一起了. 方法注入, 是一种Spring容器更为高级的特性, 能够让你更聪明滴处理此类问题. 

> 你可以从[这篇博客](https://spring.io/blog/2004/08/06/method-injection/)中获取到更多方法注入的动机. 

#### 查找方法注入

查找方法注入是重写容器管理的bean并查找另一个容器中的命名bean将其返回的能力. 查找一般是一个原型bean, 就像在前面章节讨论的. Spring框架通过CGLib库的二进制代码动态生成子类重写方法.

* 为了能让动态的子类工作, 需要为其生成子类的bean不能是`final`, 同时需要覆盖的方法也不能是`final`.

* 进行单元测试时, 如果有`abstract`方法的类需要你自己去定义子类并且提供`abstract`方法的桩实现.

* 具体方法也是需要能组件扫描的, 这就需要获取具体类.

* 另一个关键的限制查找方法和工厂方法,特别是与配置类中的`@bean`注解方法不兼容. 这种情况下, 容器不再控制创建实例因此也就不能在运行时创建子类. 

在前面的`CommandManager`类的代码片段中, Spring容器动态覆盖实现了`createCommand()`方法. 类`CommandManager`没有任何Spring依赖, 如下所示;

```java
package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
```

在客户端代码中包含了需要注入的方法, 这个被注入的方法需要如下的格式:

```xml
<public|protected> [abstract] <return-type> theMethodName(no-arguments);
```

如果方法是`abstract`修饰的, 子类将实现这个方法, 否则动态生成的子类将重写定义在源类中的实际方法. 如下所示:

```xml
<!-- a stateful bean deployed as a prototype (non-singleton) -->
<bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype">
    <!-- inject dependencies here as required -->
</bean>

<!-- commandProcessor uses statefulCommandHelper -->
<bean id="commandManager" class="fiona.apple.CommandManager">
    <lookup-method name="createCommand" bean="myCommand"/>
</bean>
```

id定义为`commandManager`的bean调用其`createCommand()`方法, 在其需要`myCommand`实例的时候. 你必须小心地部署bean`myCommand`为原型bean. 如果它是一个单例, 则每次返回的都是相同的实例.

也可以使用组件注解的方式, 你可以通过`@Lookup`注解在方法上, 如下所示:

```java
public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup("myCommand")
    protected abstract Command createCommand();
}
```

或者, 更规范地, 你可以信任目标bean通过返回的类型解析得到目标bean.

```java
public abstract class CommandManager {

    public Object process(Object commandState) {
        MyCommand command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup
    protected abstract MyCommand createCommand();
}
```

注意通常你需要用一个桩实现来声明这种带注释的查找方法, 这样他们才能与Spring组件扫描兼容, 默认情况下, 抽象类会被扫描忽略. 这个限制不适于显式注册或显式导入bean类. 

> 另一个访问不同作用域的方法是使用`ObjectFactory`/`Provider`连接点. 参看: 不同作用域的bean依赖.

> 你可以发现`ServiceLocatorFactoryBean`(在包`org.springframework.beans.factory.config`)是很有用的.

#### 任意方法替换

一种比查找方法注入不那么有用的形式是在一个管理bean中使用另一个方法实现去替换方法. 你可以跳过这节, 直到你需要这种机制再回来看.

使用XML配置的元数据时, 你可以使用`replaced-method`元素替换一个已经存在的方法. 请看下面的类定义, 它有个方法`computeValue`需要被重写:

```Java
public class MyValueCalculator {

    public String computeValue(String input) {
        // some real code...
    }

    // some other methods...
}
```

实现接口`org.springframework.beans.factory.support.MethodReplacer`提供了一个新的方法定义,如下所示:

``` java
/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    }
}
```

需要部署的源bean定义和需要覆盖的方法应该按如下方式组合:

``` xml
<bean id="myValueCalculator" class="x.y.z.MyValueCalculator">
    <!-- arbitrary method replacement -->
    <replaced-method name="computeValue" replacer="replacementComputeValue">
        <arg-type>String</arg-type>
    </replaced-method>
</bean>

<bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/>
```

你可以为元素`<replace-method/>`需要覆盖的方法签名指定一个或多个`<arg-type/>`元素. 只有类中的方法被重载并且有多个的时候才需要参数签名. 为了方便, String类型的参数可以只是一个缩写, 例如,下面的写法都匹配`java.lang.String`

```java
java.lang.String
String
Str
```

因为参数的个数经常能区分出可能的选择, 因此这种缩写能节省大量输入时间, 通过一个短字符串来匹配一个参数类型. 

## 1.5 Bean 作用域(scope)

当创建bean定义的时候, 实际上你就有个通过bean定义去创建类真实实例的配方. bean定义是配方的想法是非常重要的, 因为它意味着,你可以通过一个配方去创建多个实例. 

通过bean的定义, 你不仅可以控制插入到对象的依赖和配置值, 还可以控制通过bean定义的对象的作用域. 这种方式是强大而灵活, 因为你可以选择通过配置生成的对象的作用域, 而不是必须在class级别操作对象的作用域. bean可以定义为几个作用域其中的一个. Spring框架支持六种作用域, 四种仅可以用在web类型的`ApplicationContext`中. 你也可以自定义scope.

下面表格描述了支持的作用域:

**Table 3. Bean scopes**
|Scope|Description|
|------|------|
|singleton|(默认)对于每个IoC容器来说, 处理每个bean定义的对象实例仅有一个|
|prototype|处理一个bean定义可以有多个对象实例|
|request|处理对于每个HTTP请求仅有一个实例. 也就是对于每个bean定义, 每个HTTP请求都有它自己的实例. 仅仅在Web类型的Spring `ApplicationContext`中是可用的.|
|session|处理在一个HTTP`Session`范围内一个bean的定义. 仅仅在Web类型的Spring `ApplicationContext`中是可用的.|
|application|处理在`ServletContext`级别的bean的定义. 仅仅在Web类型的Spring `ApplicationContext`中是可用的.|
|websocket|处理在`WebSocket`级别的bean的定义,  仅仅在Web类型的Spring `ApplicationContext`中是可用的.|

> 从Spring3.0开始, 线程级别的作用域是可用的, 但不是默认注册的. 关于更多请参看`SimpleThreadScope`的文档. 关于如何注册这个作用域或者其他自定义作用域的指导, 请参看自定义作用域.

### 1.5.1 单例作用域

容器内仅仅有一个共享的bean实例, 并且所有通过bean定义中的id或者id列表仅能匹配出唯一的特定bean的实例. 

换个说法, 当你定义了一个bean,并且将其设置为singleton作用域时, Spring IoC容器创建了bean定义的唯一实例. 这个唯一实例是存储在此类单例bean的缓存中的, 并且所有子请求和引用都会返回缓存的bean. 下面的图展示了单例bean如何工作:
![单例bean](https://docs.spring.io/spring/docs/5.2.0.BUILD-SNAPSHOT/spring-framework-reference/images/singleton.png)

Spring单例bean的概念不同于GOF模式书中的单例模式. GoF单例硬编码了对象的作用域, 所以对于每个ClassLoader,有且仅有一个bean实例被创建. Spring的单例bean作用域对于每个容器每个bean来说有且仅有一个. 这意味着, 如果你在每个容器中定义一个指定的bean, 容器将为每个bean的定义生成一个且仅有一个bean的实例. 单例作用域是Spring默认的. 要用XML定义一个单例bean, 你可以参看下面定义:

```xml
<bean id="accountService" class="com.something.DefaultAccountService"/>

<!-- the following is equivalent, though redundant (singleton scope is the default) -->
<bean id="accountService" class="com.something.DefaultAccountService" scope="singleton"/>
```

1.5.2 原型作用域

非单例的原型作用域bean将在每次请求的时候创建一个新的实例. 也就是这个bean被注入另一个bean或者通过容器的`getBean()`方法调用获取. 原则上, 使用需要保持状态的bean时使用原型作用域, 使用状态无关的bean时使用单例bean.

下图说明了Spring的单例作用域:

![原型bean](https://docs.spring.io/spring/docs/5.2.0.BUILD-SNAPSHOT/spring-framework-reference/images/prototype.png)

(DAO对象不是典型的原型作用域, 因为一个DAO不保持任何会话状态. 我们重用单例的说明图是很容易的)

下面例子定义了XML格式的原型bean

```xml
<bean id="accountService" class="com.something.DefaultAccountService" scope="prototype"/>
```

同其他作用域相比, Spring不会管理原型bean的完整生命周期. 容器除了将其实例化,配置,另外还有组装和将其提供给client外, 不会有更多的原型实例的任何记录了. 因此, 虽然初始化回调方法由所有作用域的对象都会调用, 但在原型模式来说, 配置的销毁回调方法不会被调用. 客户端代码必须清理原型对象并释放被其占用的任何昂贵的资源. 为了使Spring容器能获取到原型bean占用的资源, 尝试使用自定义的post-处理器, 这个处理器维护这需要被清理的bean引用. 

在某些方面, Spring容器对于原型bean的作用是对new操作符的代替. 过去所有的生命周期管理都是客户端来维护. (关于Spring中bean生命周期的更多信息, 参看:生命周期回调)

### 1.5.3 拥有原型bean依赖的单例bean

当使用有原型bean做为依赖的单例bean时, 记住依赖是在实例化的时候解析的. 因此,如果你将一个原型bean注入单例bean, 那这个原型bean是作为新的bean被初始化了, 并且注入到了单例bean中. 这个原型bean是单例bean的独占实例.

尽管如此, 假设你想要在运行期间为单例bean多次重复获取原型bean. 你不能讲原型bean注入到单例bean中, 因为注入只发生了一次, 就在容器初始化单例bean并解析他的依赖的时候. 如果你需要一个运行时的原型bean, 参看:方法注入.

### 1.5.4  Request,Session,Application, 还有webSocket 

`request`,`session`,`application`,`websocket`作用域只有在web类型的Spring`ApplicationContext`(比如`XmlWebApplicationContext`)实现中可用.如果在标准的Spring容器中使用这些作用域, 比如`ClassPathXmlApplicationContext`, 则`IllegalStateException`将会因未知作用域而抛出.

#### 初始化Web配置

为了支持bean的这几个作用域(`request`,`session`,`application`,`websocket`(web作用域bean)), 在定义bean时还需要做少量的配置. (对于标准的作用域`singleton`和`prototype`,初始化设置是不需要的)

如何完成初始化设置取决于你特定的Servlet环境.

如果你使用Spring web MVC访问作用域bean, 实际上,请求是由Spring的`DispatcherServlet`处理的, 不需要其他的设置. `DispatcherServlet`已经暴露了所有的相关状态.

如果你使用Servlet 2.5 的Web容器, 当不使用`DispatcherServlet`处理时(比如使用JSF或Struts), 你需要注册`org.springframework.web.context.request.RequestContextListener ServletRequestListener`. 对于Servlet 3.0+, 可以通过接口`WebApplicationInitializer`编程完成. 或者作为替换,包括使用旧的容器的话, 在`web.xml`文件中添加如下声明:

```xml
<web-app>
    ...
    <listener>
        <listener-class>
            org.springframework.web.context.request.RequestContextListener
        </listener-class>
    </listener>
    ...
</web-app>
```

或者, 如果监听器设置有异常, 考虑使用Spring的`RequestContextFilter`. filter映射依赖于包含其的web程序配置, 所以你必须合理修改下. 下面列出web程序的部分配置:

```xml
<web-app>
    ...
    <filter>
        <filter-name>requestContextFilter</filter-name>
        <filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>requestContextFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    ...
</web-app>
```

`DispatcherServlet`,`RequestContextListener`,还有`RequestContextFilter`都做了同样的事情, 即绑定Http请求对象到服务请求的`Thread`. 这使得bean在调用链中可以使用request-和session-作用域.

#### Request 作用域

参考如下XML配置bean:

```xml
<bean id="loginAction" class="com.something.LoginAction" scope="request"/>
```

Spring容器使用`loginAction`定义为每个HTTP请求创建bean`LoginAction`的实例. 也就是`loginAction`bean在HTTP请求级别作用域. 你可以随意修改实例的内部状态,因为被`loginAction`bean定义实例化出来的其他对象看不到这些修改. 他们是特定于单独的request的. 当请求完成处理后, request作用域的bean就被抛弃了. 

当使用注解驱动的组件或java代码配置时, `@RequestScope`注解能用来分配给一个`request`作用域的组件. 下面例子展示了如何使用:

```java
@RequestScope
@Component
public class LoginAction {
    // ...
}
```

#### Session 作用域

参看下面XML配置的bean定义:

```xml
<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
```

Spring容器通过`userPreferences`bean的定义为每个HTTP`Session`生成`UserPreferences`bean的实例. 换句话说, `userPreferences`bean 在 HTTP `Session` 作用域级别. 跟request作用域bean一样, 你可以随意修改实例的内部状态, 而其他由同一个`userPreferences`bean定义生成的 HTTP `Session` 的实例不会看到这些变化, 因为他们特定于单独的 HTTP `Session`. 当 HTTP `Session` 最终不再使用时, 对应的Session作用域的bean也就不再使用了. 

当使用注解驱动组件或java代码配置时, 你可以使用`@SessionScope`注解到`session`作用域的相关组件上.

#### Application 作用域

考虑下面XML的bean定义:

```xml
<bean id="appPreferences" class="com.something.AppPreferences" scope="application"/>
```

Spring容器使用`appPreferences`bean的定义创建了`AppPreferences`bean的实例. 也就是`appPreferences`bean是在`ServletContext`级别的, 并且作为一个标准的`ServletContext`属性存储. 这类似于Spring单例bean, 但有两点重要的不同: 它是在每个`Servlet`上的单例, 不是在每个Spring'ApplcationContext'上的单例(可能在任何web程序中有多个),并且实际上它是暴露的并且因此是作为`ServletContext`属性可见的. 

当使用注解驱动或者java代码配置时, 你可以使用`@ApplicationScope`注解到`application`组件上. 如下所示:

```java
@ApplicationScope
@Component
public class AppPreferences {
    // ...
}
```

#### 作用域bean作为依赖

Spring容器不仅管理对象(beans)的初始化, 也包含其组装协作者(依赖项). (举例来说)如果你想要将一个HTTP request作用域的bean注入到另一个更长生命周期的bean中, 你可以选择注入一个AOP代理对象代替bean. 也就是说, 你需要使用暴露了与作用域对象相同接口的代理对象注入, 这个代理对象能够从相关作用域中获取到真实对象(例如一个HTTP请求)并且委托调用真实对象上的方法.

> 在单例bean之间你也可以使用`<aop:scoped-proxy/>`, 通过一个中间代理引用, 这个代理是可序列化的,因此能在反序列化时重新获取目标单例bean. 

> 当在一个`prototype`作用域的bean上声明`<aop:scoped-proxy/>`时 , 每个请求共享代理对象的方法将会将其引导到新建实例上并调用. 

> 同时, 在作用域安全的方式下, 从一个短作用域访问bean, 作用域代理并不是唯一的方法. 你也可以用`ObjectFactory<MyTargetBean>`声明你的注入点(也就是,构造器或setter参数或者自动装配域), 允许通过`getObject()`在需要对象时获取当前实例-- 而不是持有其实例或单独存储之. 

> 作为扩展的变体, 你可以声明`ObjectProvider<MyTargetBean>`, 这个对象有几个访问方式的变体, 包含`getIfAvailable` 和 `getIfUnique`.

> JSR-330 中这被叫做`Provider`并且用来与`Provider<MyTargetBean>`一起使用, 并且用`get()`方法获取. 关于JSR-330更多请参考![这里](https://docs.spring.io/spring/docs/5.2.0.BUILD-SNAPSHOT/spring-framework-reference/core.html#beans-standard-annotations).

下面例子中只有一行, 但理解其在背后的原因比怎么做更重要:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- an HTTP Session-scoped bean exposed as a proxy -->
    <bean id="userPreferences" class="com.something.UserPreferences" scope="session">
        <!-- instructs the container to proxy the surrounding bean -->
        <aop:scoped-proxy/> <!--这里定义了代理--> 
    </bean>

    <!-- a singleton-scoped bean injected with a proxy to the above bean -->
    <bean id="userService" class="com.something.SimpleUserService">
        <!-- a reference to the proxied userPreferences bean -->
        <property name="userPreferences" ref="userPreferences"/>
    </bean>
</beans>
```

为了创建代理, 需要插入一个子元素`<aop:scoped-proxy/>`到作用域bean的定义中. (参看创建代理的类型选择和XML配置方式). 为什么定义在`request`,`session`或者自定义作用域上的bean需要`<aop:scoped-proxy/>`?  考虑下面单例bean的定义并对比上面表述的作用域(注意下面`userPreferences`bean定义是不完整的):

```xml
<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>

<bean id="userManager" class="com.something.UserManager">
    <property name="userPreferences" ref="userPreferences"/>
</bean>
```

上面例子中, 单例bean(`userManager`)注入了HTTP `Session`-作用域的bean中(`userPreferences`). 这里的突出点是`userManager`是单例的: 它是每个容器唯一的, 并且它的依赖(在本例中是`userPreferences`bean)仅仅注入了一次. 这意味着`userManager`bean都是在相同的`userPreferences`对象上进行操作的(也就是最初被注入的那个).

这不是你想要的结果, 当将一个短生命周期的bean注入到长生命周期的bean中时(例如, 注入一个HTTP `Session`作用域的协作bean到单例bean中). 相反, 你需要一个单例的`userManager`对象, 并且对于HTTP`session`生命周期, 你需要`userPreferences`对象并将其指定为HTTP `Session`. 因此, 容器创建了一个暴露了与`UserPreferences`类相同公共接口的对象.(理想情况下这个对象是`UserPreferences`实例), 这个对象能够从作用域机制中(HTTP request,session等)获取到真实的对象. 容器将代理对象注入到`userManager`bean, 它并不知道`UserPreferences`引用是个代理. 本例中, 当`UserManager`实例调用注入对象`UserPreferences`的方法时, 实际上它是调用代理的方法. 代理然后获取从HTTP `Session`作用域(本例中)的真实`UserPreferences`对象, 并调用真实对象上的方法. 

因此, 你需要下面的配置(完整而正确), 当你注入`request-`和`session-`作用域的bean时, 如下:

```xml
<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
    <aop:scoped-proxy/>
</bean>

<bean id="userManager" class="com.something.UserManager">
    <property name="userPreferences" ref="userPreferences"/>
</bean>
```

#### 选择创建的代理类型

默认情况下, 当Spring容器用标记为`<aop:scoped-proxy/>`元素的bean创建代理时, 一个CGLIB类代理对象就被创建了. 

> CGLIB代理仅拦截公共调用! 不调用代理上的非公共方法. 他们不会被代理到目标作用域对象上.

或者, 你可以使用标准JDK基于接口的代理为作用域bean配置容器. 通过将元素`<aop:scoped-proxy>`的属性`proxy-target-class`设置为`false`. 使用JDK基于接口的代理意味着你不需要在classpath下引用多余的库. 尽管如此, 这也意味着作用域bean必须实现至少一个接口并且所有注入的的作用域bean必须通过接口引用. 下例展示了如何使用接口代理:

```xml
<!-- DefaultUserPreferences implements the UserPreferences interface -->
<bean id="userPreferences" class="com.stuff.DefaultUserPreferences" scope="session">
    <aop:scoped-proxy proxy-target-class="false"/>
</bean>

<bean id="userManager" class="com.stuff.UserManager">
    <property name="userPreferences" ref="userPreferences"/>
</bean>
```

关于选择基于类的还是基于接口的代理, 请参看: 代理机制. 

### 1.5.5 自定义作用域

bean的作用域机制是可扩展的. 你可以自定义或者重新定义已经存在的作用域, 虽然稍后会知道这不是最佳实践而且你不能重写内置的`singleton`和`prototype`作用域.

#### 创建自定义作用域

为了集成自定义的作用域到容器中, 你需要实现接口`org.springframework.beans.factory.config.Scope`, 这个接口将会在本节描述. 对于如何实现自定义作用域的观念, 参看Spring框架实现的`Scope`实现还有`Scope`java文档, 里面解释了更多需要实现的方法.

`Scope`接口有四个方法, 用来从作用域获取,移除,销毁对象.

以session作用域的实现为例, 返回session作用域bean(如果不存在,方法在这个实例将在绑定到session后以备将来引用, 然后返回一个新实例).下面的方法从潜在作用域返回对象:

```java
Object get(String name, ObjectFactory objectFactory)
```

以session作用域的实现为例, 从潜在的session作用域删除bean. 对象应该被返回, 但如果指定名称的bean找不到, 你可以返回null. 下面的方法将从潜在作用域删除对象:

```java
Object remove(String name)
```

下面的方法为作用域注册了回调, 将在它被销毁或者当作用域内的指定对象销毁时执行:

```java
void registerDestructionCallback(String name, Runnable destructionCallback)
```

关于销毁回调, 可以参看![java文档](https://docs.spring.io/spring-framework/docs/5.2.0.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/factory/config/Scope.html#registerDestructionCallback)或者Spring作用域实现的代码.

下面方法包含了从潜在作用域获取会话id:

```java
String getConversationId()
```

这个标识符在每个作用域都不同, 对于session作用域实现, 这个标识符可以是session标识符. 

#### 使用自定义作用域

在你编码并测试一个或多个自定义作用域实现后, 你需要使Spring容器能够感知到你的作用域. 下面方法是为Spring容器注册一个新作用域的核心方法:

```java
void registerScope(String scopeName, Scope scope);
```

这个方法是在接口`ConfigurableBeanFactory`声明的, 在Spring的大多数对于接口`ApplicationContext`的实现中, 通过`BeanFactory`属性可以获取到. 

`registerScope(..)`方法的第一个参数是相关作用域的唯一名称. Spring内置的此类名称是`singleton`和`prototype`. 方法的第二个参数是自定义`Scope`实现的实例, 这个实例就是你想注册和使用的. 

假设你写好了自定义的`Scope`实现, 并且像下一个例子一样注册到了容器中.

> 下一个例子使用`SimpleThreadScope`, 其包含在Spring中但没有默认注册. 这个教程与你自定义的`scope`实现是相同的. 

```java
Scope threadScope = new SimpleThreadScope();
beanFactory.registerScope("thread", threadScope);
```

你可以创建bean的定义, 并将自定义的scope实现依附其中. 如下:

```xml
<bean id="..." class="..." scope="thread">
```

自定义的`Scope`实现不仅限于使用编程方式注册, 你也可以使用声明方式注册, 通过`CustomScopeConfigurer`类进行注册, 如下所示:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">
        <property name="scopes">
            <map>
                <entry key="thread">
                    <bean class="org.springframework.context.support.SimpleThreadScope"/>
                </entry>
            </map>
        </property>
    </bean>

    <bean id="thing2" class="x.y.Thing2" scope="thread">
        <property name="name" value="Rick"/>
        <aop:scoped-proxy/>
    </bean>

    <bean id="thing1" class="x.y.Thing1">
        <property name="thing2" ref="thing2"/>
    </bean>

</beans>
```

> 当你在`FactoryBean`实现中使用`<aop:scoped-proxy/>`时, `FactoryBean`自身是作用域下的bean, 不是从`getObject()`方法返回的对象.

## 1.6 自定义Bean的性质

Spring框架提供了一些接口供你自定义bean的性质. 本节按下面方式组织:

* 生命周期回调
* `ApplicationContextAware` 和 `BeanNameAware`
* 其他`Aware`接口

### 1.6.1 生命周期回调

为了与容器管理的bean的生命周期交互, 你可以实现Spring`InitializingBean` 和 `DisposableBean` 接口. 容器会为前者调用`afterPropertiesSet()`,为后者调用`destroy()` 以使bean执行在bean初始化和销毁时应该做的操作.

> 在现代Spring程序中,JSR-250 的 `@PostConstruct` 和 `@PreDestroy` 注解被认为是获取生命周期回调的最佳实践. 使用这些注解意味着你的bean不会耦合到Spring特定的接口中. 更多信息请参看:使用`@PostConstruct` 和 `@PreDestroy`.

> 如果你不想用JSR-250注解但仍然想去除耦合, 考虑元数据中使用 `init-method` 和 `destroy-method`.

在内部, Spring框架使用接口`BeanPostProcessor`的实现来处理他发现的任何回调接口并且调用合适的方法. 如果你需要自定义特性或者修改Spring没有默认提供的其他生命周期行为, 你可以实现`BeanPostPocessor`. 更多信息请参看:容器扩展点.

除了初始化和销毁回调外, Spring管理的对象也可以实现`Lifecycle`接口, 以便那些对象能参与容器自身声明周期驱动的启动和停止过程. 

生命周期回调接口将在本节描述.

#### 初始化回调

`org.springframework.beans.factory.InitializingBean` 接口能够在容器设置了bean的所有必要属性后执行初始化工作. `InitializingBean` 接口只有一个方法:

```java
void afterPropertiesSet() throws Exception;
```

我们强烈建议不要使用`InitializingBean`接口,因为它不必要地耦合到了Spring中. 相反, 我们建议使用`@PostConstruct` 注解或者指定一个POJO 初始化方法. 如果使用XML配置, 你可以使用`init-method`属性指定一个没有参数的方法名称. Java代码配置的话, 你可以使用`@Bean`上的 `initMethod` 属性. 参看:获取生命周期回调. 参考下例:

```xml
<bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/>
```

```java
public class ExampleBean {

    public void init() {
        // do some initialization work
    }
}
```

上面的例子和下面的例子(由两个清单组成)有相同的效果:

```xml
<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
```

```java
public class AnotherExampleBean implements InitializingBean {

    public void afterPropertiesSet() {
        // do some initialization work
    }
}
```

这样,上面的头两个例子代码没有与Spring耦合.

#### 销毁回调

实现`org.springframework.beans.factory.DisposableBean`接口使得一个bean能在包含它的容器销毁时回调. `DisposableBean`接口只有一个方法:

```java
void destroy() throws Exception;
```

我们建议你不要使用`DisposableBean`回调接口, 因为代码不必要的耦合到Spring了. 相反, 我们建议使用`@PreDestroy`注解, 或者在bean定义中指定一个普通方法. 使用XML配置的话你可以使用元素`<bean/>`上的`destroy-method`属性. 使用java代码配置的话, 你可以使用`@Bean`注解上的`destroyMethod`属性. 参看获取生命周期回调. 示例如下:

```xml
<bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/>
```

```java
public class ExampleBean {

    public void cleanup() {
        // do some destruction work (like releasing pooled connections)
    }
}
```

上面的定义等同于下面的定义:

```xml
<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
```

```java
public class AnotherExampleBean implements DisposableBean {

    public void destroy() {
        // do some destruction work (like releasing pooled connections)
    }
}
```

上面的两个定义与Spring代码没有耦合. 

> 你可以为`<bean>`元素分配给属性`destroy-method`一个专门的值(`inferred`(推断)), 这个值指示Spring自动去探测特定bean上的公共`close`或`shutdown`方法. (任何实现了`java.lang.AutoCloseable` 或 `java.oi.Closeable`的类将会匹配到) 你也可以为`<beans>`元素分配给属性`default-destroy-method`一个特定值, 用来在所有bean上应用动作(参看默认初始化和销毁方法). 注意, 这个java代码配置的默认行为. 

#### 默认初始化和销毁方法

当你不用Spring特定的`InitializingBean` 和 `DisposableBean` 接口回调的初始化和销毁方法时, 你一般编写方法的名称类似`init()`,`initialize()`,`dispose()`等. 理论上, 这些生命周期回调方法是标准化的贯穿于整个项目, 这样开发人员就能使用相同的方法并保持一惯性. 

你可以配置Spring容器查找每个bean上的命名初始化和销毁方法. 这意味着你作为开发人员能编写程序类并使用名为`init()`的初始化方法回调, 而并不需要为每个bean定义上指定`init-method="init"`. Spring容器在bean被创建时调用这个方法(并遵循前面描述的标准生命周期回调). 这个特性也需要强制执行一贯的初始化和销毁方法回调的命名约定.

假设你的初始化回调方法叫`init()`并且你销毁回调方法名叫`destroy()`. 你的类将按下面例子阻止:

```java
public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    // this is (unsurprisingly) the initialization callback method
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException("The [blogDao] property must be set.");
        }
    }
}
```

你可以像下面这样使用那个类:

```xml
<beans default-init-method="init">

    <bean id="blogService" class="com.something.DefaultBlogService">
        <property name="blogDao" ref="blogDao" />
    </bean>

</beans>
```

顶级元素`<beans/>`上的属性`default-init-method`促使Spring容器去识别在bean上的`init()`方法作为初始化回调函数. 当bean被创建和组装后, 如果bean有这么个方法, 它就将在恰当的时候执行. 

你也可以在顶级元素`<beans/>`上使用`default-destroy-method`, 类似地去配置(XML)销毁回调函数.

在已经存在的bean上, 已经有按约定命名的回调方法, 你可以使用`<bean/>`元素上指定`init-method`和`destroy-method`重写默认的方法. 

Spring容器担保在bean的依赖全部被提供后能够立即调用配置的初始化回调. 因此,初始化回调发生在原始bean引用上, 这意味着AOP注入还没有应用到bean上. 一个完整的目标bean是首先被创建然后一个AOP代理注入链被引用. 如果目标bean和代理被单独定义, 你的代码就能够绕开代理与目标bean交互. 因此, 在`init`方法上应用注入是不和逻辑的, 因为这样讲耦合目标bean的生命周期到它的代理或注入器, 并且当你的代码与原始的目标bean直接交互时留下奇怪的语义.

#### 组合生命周期机制

从Spring2.5开始, 控制bean生命周期行为有三种选择:

* 回调接口 `InitializingBean` 和 `DisposableBean`
* 自定义的`init()` 和 `destroy()` 方法
* 注解 `@PostConstruct` 和 `@PreDestroy`. 你可以组合这些机制去控制bean.

> 如果给一个bean配置了多种生命周期机制,并且每个机制都使用了不同的方法名, 那么每个配置方法将会按本提示后面给出的顺序执行. 尽管如此, 如果为多个机制配置了相同的方法名-- 例如, 初始化方法的`init()`-- 那该方法将只执行一次, 就如上面所阐述的.

为同一个bean配置多个生命周期机制, 初始化方法将按下面顺序执行:

* 使用注解`@PostConstruct`的方法
* 通过回调接口`InitializingBean`定义的`afterPropertiesSet()`方法
* 自定义的`init()`方法

销毁方法按相同的顺序执行:

* 使用注解`@PreDestroy`的方法 
* 通过回调接口`DisposableBean`定义的`destroy()`
* 自定义的`destroy()`

#### 启动和停止回调

对于拥有自己生命周期需要的任何对象, 接口`Lifecycle`定义了必不可少的方法(例如启动和停止某些后台进程).

```java
public interface Lifecycle {

    void start();

    void stop();

    boolean isRunning();
}
```

任何Spring管理的对象都可以实现接口`Lifecycle`. 然后, 当`ApplicationContext`自身收到开始和停止信号时(例如,运行时的停止/重启场景), 它将级联调用上下文定义的所有`Lifecycle`实现. 这是通过委托给`LifecycleProcessor`完成的, 如下所示:

```java
public interface LifecycleProcessor extends Lifecycle {

    void onRefresh();

    void onClose();
}
```

注意, `LifecycleProcessor`本身是接口`Lifecycle`的扩展. 它添加了两个方法在上下文刷新和关闭时交互.

> 注意, 标准的`org.springframework.context.Lifecycle`接口是一个明确的规约, 是为了启动和停止通知使用, 并没有在上下文刷新时应用自动启动. 对于特定bean的自动启动更细粒度的控制(包括启动阶段), 考虑实现接口`org.springframework.context.SmartLifecycle`代替. 

> 同时请注意, 停止通知不能保证一定在销毁时会发生. 在标准的停止过程下,所有的`Lifecycle`bean在一般的销毁回调被传播前首先接收一个停止通知. 尽管这样, 在上下文生命周期热刷新时或者在抛弃刷新尝试时, 只有销毁方法会被调用. 

启动和停止调用的顺序可能是比较重要的. 如果两个对象间存在依赖关系, 依赖方将在被依赖方之后启动, 并且在被依赖方之后停止. 不过有时候直接依赖是不知道的. 你可能仅仅知道一些类型的对象的优先于另一些类型的对象启动. 这种情况下, `SmartLIfecycle`接口定义了另一种选项, 在其父类接口`Phased`上指定`getPhase()`方法. 下面的代码展示了`Phased`接口:

```java
public interface Phased {

    int getPhase();
}
```

下面展示了`SmartLifecycle`接口:

```java
public interface SmartLifecycle extends Lifecycle, Phased {

    boolean isAutoStartup();

    void stop(Runnable callback);
}
```

当启动时, 底层阶段的对象优先启动. 当停止时, 顺序相反. 因此, 一个实现了接口`SmartLifecycle`并且其方法`getPhase()`返回`Integer.MIN_VALUE`将会在第一个启动的, 并是最后一个停止的. 在此范围的另一端,也就是`Integer.MAX_VALUE`将表明对象是最后启动的并且是最先停止的(可能因为它依赖于要运行的其他进程). 当提到阶段值的时候, 重要的一点是任何"正常"`Lifecycle`对象如果没有实现`SmartLifecycle`接口的话,这个阶段值的默认为0. 因此, 任何负值的对象将在那些标准组件之前启动(在其后停止). 如果正值则相反.

通过`SmartLifecycle`接收一个停止方法. 任何实现必须在对象的停止过程完成后调用回调的`run()`方法. 这就使程序拥有了异步停止能力, 因为接口`LifecycleProcessor`的默认实现`DefaultLifecycleProcessor`在每个阶段中等待该组对象的超时值以调用该回调. 每个阶段的超时时间是30秒. 你可以通过定义一个名为`lifecycleProcessor`的bean来重写默认的生命周期处理器. 如果你想仅仅是修改超时时间, 定义如下"

```xml
<bean id="lifecycleProcessor" class="org.springframework.context.support.DefaultLifecycleProcessor">
    <!-- timeout value in milliseconds -->
    <property name="timeoutPerShutdownPhase" value="10000"/>
</bean>
```

就像前面提到的, `LifecycleProcessor`接口也定义了上下文刷新和关闭的回调方法. 后者驱动关闭过程,就好像`stop()`方法被显式调用, 但它发生在上下文关闭时. 另一方面, 刷新回调赋予了`SmartLifecycle`bean的另一种特性. 当上下文被刷新(在所有对象创建和初始化后), 回调就被调用了. 此时, 默认的生命周期处理器检查每个`SmartLifecycle`对象的`isAutoStartup()`方法返回的bool值. 如果是`true`, 对象将立刻启动而不是等到上下文或者其自身的`start()`方法显式调用(与上下文刷新不同,上下文启动并不是标准上下文实现的标准实现). `phase`值和任何依赖关系决定了前面描述的启动顺序.

#### 在非WEB程序中优雅地停止Spring容器

> 这节内容仅仅应用于非web程序. Spring 基于web的`ApplicationContext`实现已经提供了当web程序关闭时优雅地关闭容器的代码. 

如果你在一个非web程序中(例如, 一个胖客户端桌面环境)使用Spring容器, 注册一个JVM的停止钩子. 这样做可以保证你优雅地关闭, 并调用单例bean上关联的销毁方法使所有资源能够释放. 你必须依然要正确配置和实现那些销毁回调. 

为了注册停止的钩子, 调用接口`ConfigurableApplicationContext`声明的方法`registerShutdownHook()`, 如下所示:

```java
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");

        // add a shutdown hook for the above context...
        ctx.registerShutdownHook();

        // app runs here...

        // main method exits, hook is called prior to the app shutting down...
    }
}
```

### 1.6.2 `ApplicationContextAware` 和 `BeanNameAware`

当`ApplicationContext`创建了一个实现了`org.springframework.context.ApplicationContextAware`接口的对象实例时, 这个实例就提供了对`ApplicationContext`的引用. 下面代码是接口`ApplicationContextAware`的定义:

```java
public interface ApplicationContextAware {

    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
}
```

因此, bean能够通过编程方式操作创建了他们的`ApplicationContext`, 通过`ApplicationContext`接口或通过能转化为这个接口子类型的对象(例如: `ConfigurableApplicationContext`,这个接口暴露了更多的功能). 其中一个用途是对其他bean进行编程检索. 有时候这种能力是有用的. 但总体上你应该避免使用, 因为它会耦合你的代码到Spring并且不能遵循IoC风格, 在那里协作bean作为bean的属性. `ApplicationContext`的其他方法提供了访问文件,发布程序事件,还有访问`MessageSource`等功能. 这些附加特性参见`ApplicationContext`的附加功能.

自从Spring2.5开始, 自动装配是另一种能获取`ApplicationContext`引用的替代方式. "传统的"`constructor`和`byType`装配模型(如同在装配协作者一节描述的)能分别为构造器参数或setter方法参数提供`ApplicationContext`类型依赖. 更多的灵活性, 包括自动装配字段和多参数方法, 使用新的基于注解的装配特性. 如果你这么做了, 带有`@Autowired`注解的域, 构造函数或方法, 那`ApplicationContext`就自动装配到一个期望`ApplicationContext`类型的属性域,构造函数参数, 或者方法参数中去了. 更多信息请参见使用`@Autowired`.

当`ApplicationContext`创建了实现`org.springframework.beans.factory.BeanNameAware`接口的类实例后, 这个类就拥有了在定义时为其指定的名字引用. 下面代码展示了接口BeanNameAware的定义:

```java
public interface BeanNameAware {

    void setBeanName(String name) throws BeansException;
}
```

回调在bean的属性被布局后但是在`InitializingBean`, `afterPropertiesSet`或自定义初始化方法之前被调用. 

### 1.6.3 其他`Aware`接口

除了(之前讨论的)`ApplicationContextAware`和`BeanNameAware`外, Spring提供了一系列`Aware`接口以使bean向容器表明他们需要特定的基础设施依赖. 作为普遍法则, 这个名称表明了依赖类型. 下面表格简要列出最重要的`Aware`接口:

Table 4 Aware接口

|名称|注入的依赖|解释文档索引|
|--------|-------|-------|
|ApplicationContextAware|声明ApplicationContext|ApplicationContextAware and BeanNameAware|
|ApplicationEventPublisherAware|封装的ApplicationContext的事件发布|ApplicationContext的附加功能|
|BeanClassLoaderAware|用来加载bean的类加载器|实例化bean|
|BeanFactoryAware|声明BeanFactory|ApplicationContextAware and BeanNameAware|
|BeanNameAware|声明的bean的名称|ApplicationContextAware and BeanNameAware|
|BootstrapContextAware|容器运行其中的资源适配器BootstrapContext, 一般仅JCA可用的ApplicationContext中可用|![JCA CCI](https://docs.spring.io/spring/docs/5.2.0.BUILD-SNAPSHOT/spring-framework-reference/integration.html#cci)|
|LoadTimeWeaverAware|加载时为处理类定义的加载器|Spring框架中使用AspectJ加载时织入|
|MessageSourceAware|配置的解析消息的资源策略(支持参数化和国际化)|ApplicationContext的附加功能|
|NotificationPublisherAware|Spring JMX 提醒发布者|提醒|
|ResourceLoaderAware|底层访问资源的配置加载器|Resources|
|ServletConfigAware|容器运行其中的当前`ServletConfig`,仅在web-aware的Spring `ApplicationContext`中可用|Spring MVC|
|ServletContextAware|容器运行其中的当前`ServletContext`,仅在web-aware的Spring `ApplicationContext`中可用|Spring MVC|

请再次注意, 使用这些接口将使你的代码耦合到Spring API, 并且也不遵循IoC风格. 因此我们建议他们当需要访问容器时使用基础设施bean.

## 1.7 Bean定义继承

bean的定义包含很多配置信息, 包含构造函数参数, 属性值, 还有特定于容器的信息, 例如初始化方法,静态工厂方法等. 一个bean的子类定义继承了父定义中的配置数据. 子类定义可以覆盖或者按需添加数据. 使用父子定义可以节省很多编码. 事实上, 这是一种模型.

如果你使用编程方式使用`ApplicationContext`接口, 子类bean的定义是通过`ChildBeanDefinition`类来表现的. 许多用户不在这个层面使用它. 相反, 他们通过在诸如`ClassPathXmlApplicationContext`的类中生命配置bean. 当你使用基于XML的配置元数据时, 你可以通过`parent`属性指明子类bean定义, 其值是父bean的定义名称. 下例展示了如何这么做:

```xml
<bean id="inheritedTestBean" abstract="true"
        class="org.springframework.beans.TestBean">
    <property name="name" value="parent"/>
    <property name="age" value="1"/>
</bean>

<!--注意`parent`属性-->
<bean id="inheritsWithDifferentClass"
        class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBean" init-method="initialize">  
    <property name="name" value="override"/>
    <!-- the age property value of 1 will be inherited from parent -->
</bean>
```

如果没有指定,子类bean定义将使用父类定义的bean类,但依然可以覆盖它. 后一种情况下, 子类必须兼容父类(也就是必须接受父类的属性值).

子类继承了父bean的作用域,构造函数参数值, 属性值还有方法重写, 同时可以添加新的值给它. 任何你指定的作用域,初始化方法,销毁方法或者`static`工厂方法配置都将覆盖掉父类的配置. 

剩下的配置总是从子类定义获取: 依赖,装配模式,依赖检查,单例, 懒加载.

上面例子中父类定义使用`abstract`属性显式标记父bean是抽象的. 如果父bean不指定类型, 显式标记父bean为`abstract`是必须的, 如下所示:

```xml
<bean id="inheritedTestBeanWithoutClass" abstract="true">
    <property name="name" value="parent"/>
    <property name="age" value="1"/>
</bean>

<bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBeanWithoutClass" init-method="initialize">
    <property name="name" value="override"/>
    <!-- age will inherit the value of 1 from the parent bean definition-->
</bean>
```

父bean不能被实例化自己, 因为它不完整, 且显式标记为`abstract`了. 当一个定义是`abstract`的时, 它仅仅是为子定义提供的一个纯净的模板bean定义. 视图尝试单独使用这个抽象bean, 或者将它引用为另一个bean的`ref`属性, 或者使用父bean的id执行`getBean()`方法将返回错误. 相似的, 容器内部的`preInstantiateSingletons()`方法将忽略定义为抽象的bean. 

> `ApplicationContext`默认预初始化所有的单例. 因此, 重要的一点是(至少对于单例bean)如果你有个(父)bean定义, 并且仅仅想把它作为模板使用, 并且给他指定了类名, 你就必须保证设置了abstract属性为true, 否则应用程序上下文将(尝试)预实例化这个`abstract`bean.

## 1.8 容器扩展点

通常, 攻城狮不需要`ApplicationContext`的子类实现. 相反, Spring容器可以通过实现特定接口的方式扩展. 以下几节描述了这些接口.

### 1.8.1 使用`BeanPostProcessor`自定义bean

`BeanPostProcessor`接口定义了一些回调方法, 你可以实现提供你自己的(或者覆盖默认的)初始化逻辑, 依赖解析逻辑等. 如果你想要在容器完成初始化, 配置和实例化bean之后实现一些自己的逻辑, 你可以插入一个或多个`BeanPostProcessor`的实现. 

你可以配置多个`BeanPostProcessor`实例, 并能够通过`order`属性的值来控制这些实例执行的顺序.如果`BeanPostProcessor`实现了`Ordered`接口, 你就可以设置这个属性了. 如果你写了自己的`BeanPostProcessor`, 你就也应该考虑实现`Ordered`接口. 更多细节可参看javadoc关于`BeanPostProcessor`和`Ordered`接口的部分. 也可以参看: 编程注册`BeanPostProcessor`的实例. 

> `BeanPostProcessor`实例作用在bean或对象上. 也就是Spring容器实例化一个bean实例后`BeanPostProcessor`实例开始做他们的工作. 

> `BeanPostProcessor`是容器级别的作用域. 仅仅是你使用容器层次结构的时候才是有意义的. 如果你在容器中定义了一个`BeanPostProcessor`,它将仅仅处理这个容器中的bean. 换句话说, 定义在一个容器中的bean不能被其他容器中的`BeanPostProcessor`处理, 就算这俩容器都是相同等级层次架构的一部分. 

> 为了改变bean的定义(也就是定义bean的蓝图), 你需要使用`BeanFactoryPostProcessor`, 这在使用`BeanPostProcessor`来自定义配置原数据中有描述. 

`org.springframework.beans.factory.config.BeanPostProcessor`接口包含两个回调方法. 当一个post-processor的bean被注册到容器后, 对于每个本容器实例化出的bean, post-processor都将从容器获取到回调方法, 是在容器初始化方法之前(例如`InitializingBean.afterPropertiesSet()`或者任何声明为`init`的方法)将被调用, 且在bean实例化回调方法之后. post-processor可以做任何事情, 包括完全忽略回调方法. 一个bean post-processor通常检查回调接口, 或者使用代理来包装bean. 一些Spring AOP 基础设施类就是实现为post-processor, 为了提供代理包装逻辑. 

`ApplicationContext`自动探测在配置元数据中任何实现了`BeanPostProcessor`接口的bean. `ApplicationContext`将作为post-processor注册了这些bean, 以便晚些时候在bean创建的时候调用. bean post-processor能够以和其他bean相同的方式部署到容器中. 

注意当在配置类上使用`@Bean`注解的工厂方法声明`BeanPostProcessor`时, 工厂方法的返回类型必须是实现类型本身, 或者至少是接口`org.springframework.beans.factory.config.BeanPostProcessor`, 明确表示bean的post-processor属性. 否则, `ApplicationContext`不能在完全创建它时通过类型自动探测. 因为`BeanPostProcessor`需要被早点实例化, 从而被用于其他bean的初始化过程中, 所以这种早期探测是至关重要的. 

> **编程的方式注册`BeanPostProcessor`实例**

> 建议注册`BeanPostProcessor`的方式就是前面提到的,通过`ApplicationContext`自动检测, 同时你也可以用编程的方式使用`ConfigurableBeanFactory`的方法`addBeanPostProcessor()`进行注册. 当你需要评估注册前的条件逻辑, 或者想要在一个层次结构中跨上下文拷贝post-processor时, 编程的方式就很有用了. 注意, 编程添加的`BeanPostProcessor`实例并不关心`Ordered`接口. 这里, 是注册的顺序决定了执行的顺序. 同时注意, 编程注册的`BeanPostProcessor`接口总是在那些自动检测注册的接口之前处理, 就算显式指定了顺序也是如此. 

> **`BeanPostProcessor`实例和AOP自动代理**

> 实现了`BeanPostProcessor`接口的类是特殊的并且被容器区别对待. 所有`BeanPostProcessor`实例和他们直接饮用的bean都是在启动时实例化的, 作为`ApplicationContext`启动阶段的一个特殊部分. 接下来, 所有`BeanPostProcessor`实例将被以一种风格注册并应用到所有容器的bean上. 因为AOP自动代理是作为`BeanPostProcessor`自身的一个实现. 所以BeanpostProcessor实例和它们直接引用的bean都不符合自动代理的条件，因此，它们中没有织入的方面。 

> 对于这样的bean, 你可能看到如下日志信息: Bean someBean 不符合所有`BeanPostProcessor`接口处理的条件(例如:不符合自动代理).

> 如果你有通过自动装配或`@Resource`注解(可能会回到自动装配)方式装配bean到`BeanPostProcessor`中, Spring在查找类型匹配的依赖候选时, 可能会访问到不期望的bean, 使得他们不符合自动代理或者其他bean post-processor处理. 例如, 如果你有个`@Resource`的依赖项, 其中字段或setter名称并不直接对应到bean的声明名称, 并且不使用name属性, 那么Spring将按类型访问其他bean来匹配它们. 

下面的例子展示了在`ApplicationContext`中如何编码, 注册和使用`BeanPostProcessor`.

#### 示例: `BeanPostProcessor`-风格的Hello World程序

第一个例子是基本用法. 展示了一个自定义的`BeanPostProcessor`实现调用每个容器创建的bean的`toString()`方法并将结果打印到控制台. 

下面是代码:

```java
package scripting;

import org.springframework.beans.factory.config.BeanPostProcessor;

public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {

    // simply return the instantiated bean as-is
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        return bean; // we could potentially return any object reference here...
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) {
        System.out.println("Bean '" + beanName + "' created : " + bean.toString());
        return bean;
    }
}
```

下面`beans`元素使用了`InstantiationTracingBeanPostProcessor`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:lang="http://www.springframework.org/schema/lang"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/lang
        http://www.springframework.org/schema/lang/spring-lang.xsd">

    <lang:groovy id="messenger"
            script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy">
        <lang:property name="message" value="Fiona Apple Is Just So Dreamy."/>
    </lang:groovy>

    <!--
    when the above bean (messenger) is instantiated, this custom
    BeanPostProcessor implementation will output the fact to the system console
    -->
    <bean class="scripting.InstantiationTracingBeanPostProcessor"/>

</beans>
```

注意`InstantiationTracingBeanPostProcessor`仅仅是声明了. 它没有名字, 并且应该它是个bean, 它能够依赖注入给任何其他bean. (上面配置定义了个bean, 是使用Groovy脚本的形式,Spring动态语言支持的细节请看:动态语言支持)

下面java程序运行上面的代码和配置:

```java
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.scripting.Messenger;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
        Messenger messenger = (Messenger) ctx.getBean("messenger");
        System.out.println(messenger);
    }

}
```

输出如下:

```
Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961
```

#### 示例: `RequiredAnnotationBeanPostProcessor`

使用回调接口或注解与自定义`BeanPostProcessor`实现协力是扩展Spring容器的常见做法. 一个例子是Spring的`RequiredAnnotationBeanPostProcessor`, 一个`BeanPostProcessor`的实现, 它是随Spring发行附带的, 能确保标记为任意注释的beans上的javabean属性是实际上配置为依赖注入的一个值. 

### 1.8.2 使用`BeanFactoryPostProcessor`自定义配置元数据

下一个扩展点我们看一下`org.springframework.beans.factory.config.BeanFactoryPostProcessor`. 这个接口的语法类似于其他的`BeanPostProcessor`, 但有个主要不同: `BeanFactoryPostProcessor`操作bean的元数据. 也就是, Spring容器使用`BeanFactoryPostProcessor`读取配置元数据并可能在容器实例化任何除`BeanFactoryPostProcessor`之外的bean之前改变它. 

你可以配置多个`BeanFactoryPostProcessor`实例, 并可以通过`order`属性控制这些实例的执行顺序. 虽然,你仅仅需要设置实现了`Ordered`接口的`BeanFactoryPostProcessor`的这个属性. 如果你编写了自己的`BeanFactoryPostProcessor`, 你就应该考虑实现`Ordered`接口. 更多细节参看:`BeanFactoryPostProcessor`和`Ordered`的java文档. 

> 如果你想修改实际的bean实例(也就是通过配置元数据创建的对象), 那你就需要使用`BeanPostProcessor`(之前章节讨论的通过`BeanPostProcessor`自定义bean). 虽然技术上可以使用`BeanFactoryPostProcessor`与bean实例协作(例如, 通过使用`BeanFactory.getBean()`), 但这样做将导致早产的bean实例, 侵犯了标准的Spring容器生命周期.这样容易导致副作用, 例如绕开bean处理. 

> 同时`BeanFactoryPostProcessor`实例是容器级别的作用域. 这仅仅在使用容器层次结构的时候是有意义的. 如果你容器中定义了一个`BeanFactoryPostProcessor`, 那他就只在这个容器定义的bean起作用.在一个容器中的bean定义不能被另一个容器中的`BeanFactoryPostProcessor`处理, 就算两个容器都是相同层次结构的一部分.

一个bean工厂的post-processor, 当它在`ApplicationContext`中声明时自动执行, 为了给定义在容器中的元数据做出修改. Spring包含很多预定义的工厂post-processor, 例如`PropertyOverrideConfigurer`和`PropertySourcesPlaceholderConfigurer`. 你也可以使用自定义的`BeanFactoryPostProcessor`--例如, 注册自动以的属性编辑器. 

`ApplicationContext`自动检测那些部署到其中的, 实现接口`BeanFactoryPostProcessor`的bean. 在恰当的时候, 它使用这些bean为bean工厂的post-processor. 你可以象其他bean一样部署这些post-processor bean.

> 与使用`BeanPostProcessor`一样, 你通常不想要配置`BeanFactoryPostProcessor`为延迟加载. 如果没有其他bean引用一个`Bean(Factory)PostProcessor`, 那post-processor将不会被初始化. 因此, 将其标记为延迟初始化是会被忽略的, 并且`Bean(Factory)PostProcessor`将会被更早的初始化, 就算你设置了`<beans/>`元素的`default-lazy-init=true`. 

#### 例子: 类的名字替换`PropertySourcesPlaceholderConfigurer`

通过使用标准的java `Properties` 格式, 你可以使用`PropertySourcesPlaceholderConfigurer`来扩展独立在文件中的bean定义中的属性值. 这么做能使人们部署程序去自定义的特定环境的属性, 例如数据库URLs和密码, 而不需要复杂的有风险的去修改主要的XML定义文件. 

请看下面的XML格式的配置元数据片段, 里面有个使用占位符的`DataSource`值被定义:

```xml
<bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
    <property name="locations" value="classpath:com/something/jdbc.properties"/>
</bean>

<bean id="dataSource" destroy-method="close"
        class="org.apache.commons.dbcp.BasicDataSource">
    <property name="driverClassName" value="${jdbc.driverClassName}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>
```

示例展示了从一个外部`Properties`文件中配置的属性. 在运行时, `PropertySourcesPlaceholderConfigurer`被用来替换数据源中的一些属性值. 需要替换的属性是以一种`${properties-name}`的格式指定, 遵循Ant和log4j以及JSP EL风格.

真正的值来自另一个标准的`Properties`文件:

```
jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root
```

因此, 字符串`${jdbc.username}`在运行时被'sa'替换, 并且其他的与键匹配的占位符值都给替换了. `PropertySourcesPlaceholderConfigurer`检查properties占位符和bean的定义属性. 而且, 你可以自定义占位符前缀和后缀. 

随着Spring2.5版本的`context`命名空间, 你可以使用专门的配置元素去配置属性占位符. 你可以为`location`属性提供一个或多个用逗号分隔的值列表. 如下:

```xml
<context:property-placeholder location="classpath:com/something/jdbc.properties"/>
```

`PropertySourcesPlaceholderConfigurer`不仅查找指定的properties文件. 默认情况下, 如果它不能从指定的属性文件中找到, 它会继续查找Spring`Environment`属性和标准的`System`属性:

> 你可以使用`PropertySourcesPlaceholderConfigurer`去替换类的名称, 这有时候是有用的, 当你不得不在运行时选择一个特定的类实现的时候. 下面展示了这种情况:
``` xml
<bean class="org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer">
    <property name="locations">
        <value>classpath:com/something/strategy.properties</value>
    </property>
    <property name="properties">
        <value>custom.strategy.class=com.something.DefaultStrategy</value>
    </property>
</bean>

<bean id="serviceStrategy" class="${custom.strategy.class}"/>
```
> 如果这个类不能在运行时被解析为一个有效的类, 解析失败发生在当它将要被创建时, 对于一个非延迟加载的bean, 也就是在`ApplicationContext`的`preInstantiateSingletons()`阶段.

#### 示例: `PropertyOverrideConfigurer`

`PropertyOverrideConfigurer`是另一个bean工厂post-processor, 类似于`PropertySourcesPlaceholderConfigurer`, 但又不同于后者, 对于bean的properties, 最初的定义可以没有默认值或者压根就没值. 如果一个覆盖的`Properties`文件没有bean的properties合适的入口, 那么默认的上下文定义将被使用.

注意, bean的定义并不知道被覆盖, 所以覆盖配置被使用的xml定义文件并不是立即就可见. 万一有多个`PropertyOverrideConfigurer`实例为同一属性定义了多个, 那依据覆盖机制最后一个将获胜.

properties文件配置的行格式如下:

```
beanName.property=value
```

下面是这种格式的示例:

```
dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb
```

示例文件能被定义了一个名字为`dataSource`的bean使用, 其中包含了`driver`和`url`属性. 

组合属性名称也是受支持的, 只要路径path的每个被复写的部分都是非空, 最终属性除外(假设是使用构造器初始化的). 在接下来的例子中, bean`tom`的`fred`属性的`bob`属性的`sammy`属性被设置为`123`.

```
tom.fred.bob.sammy=123
```

> 指定的覆写的值总是字面量. 他们不会被解析为bean的引用. 当xml bean定义中指定一个bean的引用时,这个约定同样被使用. 

自从Spring 2.5的`context`命名空间开始, 就可以使用一个明确的配置元素去配置属性了. 如下所示:

```xml
<context:property-override location="classpath:override.properties"/>
```

### 1.8.3 使用`FactoryBean`自定义实例化逻辑

你可以为本身是工厂的类实现接口`org.springframework.beans.factory.FactoryBean`.

`FactoryBean`接口是可插入Spring容器实例化逻辑的一个点. 如果你有比较复杂的代码, 这种代码使用java比使用一对xml文件更好的表达, 你就可以自己去创建自己的`FactoryBean`, 将复杂的实例化代码写进这个类, 并将这个类插入到容器中. 

`FactoryBean`接口提供了额三个方法:

* `Object getObject()`: 返回工厂创建的实例对象. 这个实例可能是共享的, 取决于工厂返回的是单例还是原型. 

* `boolean isSingleton()`: 如果这个`FactoryBean`返回单例就是`true`,否则是`false`.

* `Class getObjectType()`: 返回对象的类型, 这个对象是`getObject()`方法返回的. 或者返回`null`, 如果类型不能预知. 

`FactoryBean`的观念和接口在Spring框架中多处使用. Spring自身提供的就总有50多个实现. 

当你需要问容器请求接口`FactoryBean`的真实实例本身, 而不是它生产的bean时, 在调用`ApplicationContext`的方法`getBean()`方法将返回在bean的`id`前面冠以`&`. 所以, 对于一个id为`myBean`的`FactoryBean`, 调用`getBean("myBean")`将返回`FactoryBean`的产品, 而调用`getBean("&myBean")`返回`FactoryBean`实例本身. 

## 1.9 基于注解的容器配置

> **Spring中是否注解配置要优于XML的配置**

> 基于注解的配置是否优于XML, 关于注解的介绍引出了这个问题. 简短的答案是"看情况". 长一点的答案是:每种方式都有其优缺点, 经常地, 这取决于开发人员决定哪种方式更适合他们. 基于他们定义的方式, 注解提供了许多上下文, 这导致了更短而更闭联的配置. 而XML更精通于不接触代码或无需重新编译而组装组件.一些开发人员更喜欢将装配接近源码的方式, 而其他人则认为注解的类不再是POJO了, 而且配置变得零散而难以控制. 

> 不管何种选择, Spring都能兼容两种方式甚至混用它们. 值得指出,通过java配置选项, Spring使得注解在一个非侵入方式下使用, 不需要触碰目标组件的源码, 至于工具, 所有的配置方式都被Spring Tool Suite 支持. 

一种替换XML配置的方式是基于注解的配置, 后者依赖于二进制字节码原数据装配组件而不是使用尖括号的声明. 不同于XML描述装配, 开发人员将配置转移到组件类内部,通过注解在类上, 方法上或域字段上. 就像在示例:`RequiredAnnotationBeanPostProcessor`中一样, 使用`BeanPostProcessor`与注解协作是一种扩展Spring 容器的普遍方法. 例如, Spring2.0赋予了使用`@Required`注解强制必填属性的能力. Spring2.5使得使用相同的一般模式来驱动Spring DI 成为可能. 本质上, `@Autowired`注解提供了在自动装配一节的描述相同的能力, 但拥有更细粒度的控制和更广的适用性. Spring2.5同样添加了JSR-250注解的支持,例如`@PostConstruct`和`@PreDestroy`. Spring 3.0 添加了对JSR-330(java的依赖注入)注解支持, 包含在`javax.inject`包下如`@Inject`和`@Named`. 这些注解的细节可以在相关章节找到. 

> 注解注入在XML注入之前执行. 因此, XML配置将覆盖了通过两种方式装配的注解. 

通常, 你可以像分离的bean定义一样注册他们, 但你也可以隐式的通过包含在XML配置中的下面标签来注册. (注意将`context`命名空间包含进去):

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

</beans>
```

(隐式注册的post-processor包含`AutowiredAnnotationBeanPostProcessor`, `CommonAnnotationBeanPostProcessor`, `PersistenceAnnotationBeanPostProcessor`, 还有前面提到的` RequiredAnnotationBeanPostProcessor`.)

> `<context:annotation-config/>`仅仅查找相同应用上下文定义的bean上的注解. 这意味着如果你为一个`DispatcherServlet`的`WebApplicationContext`上添加标签`<context:annotation-config/>`, 它仅仅在你的Controller上检查`@Autowired`, 而不会在service上. 可参看:DispatcherServlet获取更多信息. 

### 1.9.1 @Required

`@Required`注解引用在bean的setter方法上, 如下:

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

这个注解表明, 受影响的bean的属性必须在配置是就确定, 不管是通过bean定义中的显式的属性值还是自动装配. 如果没有找到值,容器将抛出异常. 这允许早期和显式失败, 避免了`NullPointerException`等诸如此类的实例. 我们依然建议你将断言放置在bean类内部(例如, 放在初始化方法里面). 这样就强制了必填属性的引用和值, 就算你在容器外使用类也是如此. 

> `@Required`注解在Spring framework 5.1开始起被否定了, 更倾向于必填设置通过构造函数(或使用随bean属性的setter方法`InitializingBean.afterPropertiesSet()`的自定义实现) .

### 1.9.2 使用`@Autowired`

> JSR 330 的注解`@Inject` 能够替换在本节例子中使用的Spring注解`@Autowired`. 这里(bean的标准注解)有更多细节.

你可以将`@Autowired`注解应用到构造函数, 如下所示:

```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

> 从Spring 框架4.3 开始, 如果目标bean只定义了一个构造函数, 那么`@Autowired`注解就不是必须的. 但如果有多个构造函数, 那至少需要注解其中的一个来告诉容器使用哪个. 

你也可以将`@Autowired`注解应用到传统的setter方法上, 如下:

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

你也可以将注解应用到具有任意名称和多个参数的方法, 如下:

```java
public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

也可以将`@Autowired`应用到域并且可以和构造方法混用, 如下

```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    private MovieCatalog movieCatalog;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

> 确保你的目标组件(如`MovieCatalog`或`CustomerPreferenceDao`)和使用`@Autowired`注解的地方是类型一致的. 否则,注入可能会因为运行时没有匹配到类型而失败. 

> 对于XML定义的bean或组件类通过classpath扫描, 容器通常可以预知类型. 但对于`@Bean`工厂方法, 你需要确保返回类型要足够明确. 对于那些实现了多个接口的组件, 或隐式的引用到具体实现类型的组件, 考虑在工厂方法返回值将其声明为特定类型(至少要指定为与注入点引用的bean需要的类型).

你也可以为需要一个数组的域或方法提供一组特定类型的bean, 这些bean从`ApplicationContext`中获取. 如下:

```java
public class MovieRecommender {

    @Autowired
    private MovieCatalog[] movieCatalogs;

    // ...
}
```

同样可以引用于集合类, 如下:

```java
public class MovieRecommender {

    private Set<MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}
```

> 如果你想指定集合数组中的元素顺序, 你可以给目标bean实现`org.springframework.core.Ordered`接口或者使用`@Order`或者标准的`@Priority`注释. 否则他们的顺序遵循容器中定义的相关目标bean注册的顺序. 

> 你可以在目标类级别上声明`@Order`注解, 以及在`@Bean`方法上, 这可能是单独的bean定义(在使用同一个bean类的多个定义的情况下). `@Order`值可能影响注入点的优先级, 但要知道, 它不影响单例的启动顺序, 而这是由依赖关系和`@DependsOn`声明决定的正交关系. 

> 注意标准的`javax.annotation.Priority`注解不能在`@Bean`级别上使用, 因为它不能声明在方法上. 它的语义可以通过`@Order`值与每个类型的单一bean上使用`@Primary`相结合来建模. 

甚至类型化的`Map`实例也是可以自动包装的, 只要期待的key值是`String`类型. Map的值包含了所有期望类型的实例, 而key值包含了相关bean的名称, 如下所示:

```java
public class MovieRecommender {

    private Map<String, MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}
```

默认情况下, 如果没有候选bean, 自动装配将会失败(也就是默认必填). 默认的行为是将注解方法, 构造函数和域看做所需的依赖. 你也可以像如下所示的那样去改变其行为:

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired(required = false)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

> 每个类仅有一个构造函数可以被标记为必填, 但可以有多个注解的构造函数. 那种情况下, 每个都将被作为候选, 并且Spring使用最大参数的构造函数, 这个构造函数可以满足依赖.

> 建议将`@Autowired`所需的必填属性置于`@Required`注解之上. 必填属性表明属性不是为了自动装配必须要的. 属性将被忽略如果它不能被自动装配. 而`@Required`, 另一方面它更强, 它可以以容器支持的任何方式设置属性. 如果没有值注入, 相关的异常将会抛出. 

作为替换, 你可以使用java8的`java.util.Optional`来表达一个非必填属性依赖. 如下所示:

```java
public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(Optional<MovieFinder> movieFinder) {
        ...
    }
}
```

从Spring 5.0 开始, 你也可以使用`@Nullable`注解了(任何包中任何类型的注释, 例如JSR-305的:`javax.annotation.Nullable`) :

```java
public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        ...
    }
}
```

您也可以为众所周知的依赖项接口使用`@Autowired`: `BeanFactory`, `ApplicationContext`, `Environment`, `ResourceLoader`, `ApplicationEventPublisher`,还有`MessageSource`. 这些接口和他们的扩展接口, 例如:`ConfigurableApplicationContext`或者`ResourcePatternResolver`, 会被自动解析, 不需要特殊的设置步骤. 下面例子展示了自动装配一个`ApplicationContext`对象:

```java
public class MovieRecommender {

    @Autowired
    private ApplicationContext context;

    public MovieRecommender() {
    }

    // ...
}
```

> `@Autowired`, `@Inject`, `@Resource`, 和 `@Value` 是被Spring的`BeanPostProcessor`实现所处理. 这意味着你不能讲这些注释应用到你自己的`BeanPostProcessor`或者`BeanFactoryPostProcessor`类型. 这些类型必须显式的使用XML或Spring`@bean`方法装配.  

### 1.9.3 使用`@Primary`注释进行微调

因为按类型的自动装配可能会有多个候选, 所以有必要在选择过程中有更多控制. 一种达成此目标的方式是使用`@Primary`注解. `@Primary`表明当多个bean候选都符合单例依赖时, 这个特定的bean应当被自动装配给引用. 如果确实有一个主要的bean, 那它就成为了自动装配的值. 

参看下面的配置, 定义了`firstMovieCatalog`作为主要的`MovieCatalog`:

```java
@Configuration
public class MovieConfiguration {

    @Bean
    @Primary
    public MovieCatalog firstMovieCatalog() { ... }

    @Bean
    public MovieCatalog secondMovieCatalog() { ... }

    // ...
}
```

使用上面的配置, 下面的`MovieRecommender`被自动装配了`firstMovieCatalog`:

```java
public class MovieRecommender {

    @Autowired
    private MovieCatalog movieCatalog;

    // ...
}
```

相关的bean定义如下:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog" primary="true">
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean id="movieRecommender" class="example.MovieRecommender"/>

</beans>
```

### 1.9.4 使用Qualifiers微调

当使用按类型自动封装时, 如果有几个不同的实例而只有一个主要的实例被确定, `@Primary`是一种有效的方法.当你需要在选择过程中有更多控制时, 可以使用Spring的`@Qualifier`注解. 你可以使用它的几个相关参数来缩小类型匹配范围, 这样对于任一参数选择其特定的bean. 在最简单的示例中, 它可以是一个普通的描述值, 如下:

```java
public class MovieRecommender {

    @Autowired
    @Qualifier("main")
    private MovieCatalog movieCatalog;

    // ...
}
```

你也可以指定`@Qualifier`注解到单独的构造函数参数上, 如下:

```java
public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(@Qualifier("main")MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

下面示例展示了相关的bean定义:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog">
        <qualifier value="main"/> <!--用main指定的值被具有相同名称的构造函数参数自动装配-->

        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <qualifier value="action"/> <!--用action指定的值被具有相同名称的构造函数参数自动装配-->

        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean id="movieRecommender" class="example.MovieRecommender"/>

</beans>
```

> 作为一种回退匹配, bean的名称被认为是默认的指定值. 因此,你可以定义一个`id`为`main`的bean替代内部的指定元素, 结果是一样的. 虽然你可以使用bean名称引用特定的bean, `@Autowired`根本上是使用可选语义的修饰语进行类型驱动注入.这就意味着限定的值,即便有名称后备, 总是会限定在匹配类型范围内. 他们语义上不会表达为对一个bean`id`的引用. 好的限定值是`main`,`MEMA`或`persistent`, 表达独立于bean的`id`外的一种特定角色, 这个bean的id可能是自动生成的匿名定义, 就像前面例子中一样. 

> 限定还可被用到集合, 就像前面讨论的一样, 如:`Set<MovieCatalog>`. 这种情况下, 所有匹配的bean, 根据声明的限定, 是作为集合注入. 这暗示了限定符不需要是唯一的. 相反他们构成了过滤标准. 例如, 你可以使用相同的限定值"action"定义多个`MovieCatalog`bean, 所有他们都被注入到使用`@Qualifier("action")`注解的集合`Set<MovieCatalog>`中. 

在类型匹配的候选时, 让限定值依赖bean名称选择, 不需要在注入点添加`@Qualifier`注解. 如果没有其他解析指令(如限定符或primary标记), 对于非单一依赖的情况, Spring通过目标bean的名称并选择相同名称的候选来匹配注入点名称(也就是,域名称或参数名称).

也就是说, 如果你想通过名称来表达注解驱动的注入, 就不需要使用`@Autowired`, 就算他能在类型匹配的候选中进行选择. 相反, 使用JSR-250 的 `@Resource` 注解, 这个注解语义上定义了特定目标bean的唯一名称, 声明的类型和匹配过程无关. `@Autowired`有不同的语义: 在通过类型选择bean后, 特定的`String`限定的值被认为仅仅是侯选中的(例如, 匹配`account`限定将依赖于相同的限定标签). 

对于本身定义为集合的bean, 如`Map`或数组类型, `@Resource`是好的解决方法, 通过名字引用特定的集合或数组bean. 也就是说, 自从4.3版本开始, 你也可以使用`@Autowired`类型匹配算法来匹配`Map`和数组类型, 只要元素类型信息保存在`@Bean`的返回签名类型或集合继承中. 在这种情况下, 如上一段所述, 你可以使用限定值在相同类型中进行选择. 

从4.3开始, 对于注入, `@Autowired`也被认为是自引用的(也就是引用返回到当前被注入的bean上). 注意,自我注入是个回退. 一般的对其他组件的依赖往往具有优先权. 从这个意义上说, 自我引用不在一般候选范围因此从来不是主要的. 相反,他们一般是最后的选择. 实际上你应该使用自我引用作为最后的手段(例如通过bean的事务代理调用同一实例的其他方法). 在这种场景下, 考虑重构受影响的方法到单独的代理bean中. 想法, 你可以使用`@Resource`, 这可以通过其唯一名称获取到当前bean的代理. 

`@Autowired`被用到域,构造函数,还有多个参数的方法上, 允许通过限定注解在参数级别缩小范围. 相比之下, `@Resource`仅被支持在域和bean属性的setter方法上使用. 因此, 你应该在你注入目标是个构造函数或多参数方法上使用限定. 

你也可以创建自定义的限定注解. 定义了一个注解, 并给其定义上添加了`@Qualifier`, 如下:

```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Genre {

    String value();
}
```

接下来你就可以将自定义限定添加到域或参数上, 如下:

```java
public class MovieRecommender {

    @Autowired
    @Genre("Action")
    private MovieCatalog actionCatalog;

    private MovieCatalog comedyCatalog;

    @Autowired
    public void setComedyCatalog(@Genre("Comedy") MovieCatalog comedyCatalog) {
        this.comedyCatalog = comedyCatalog;
    }

    // ...
}
```

接下来, 你可以为候选bean定义提供信息了. 你可以添加`<qualifier/>`标签作为`<bean/>`标签的子元素, 然后为其指定`type`和`value`来匹配你自定义的注解. 类型通过注解类的全限定名匹配. 最为替换, 如果没有名字冲突, 你可以使用短名称. 下面例子展示了全部两种方式:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog">
        <qualifier type="Genre" value="Action"/>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <qualifier type="example.Genre" value="Comedy"/>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean id="movieRecommender" class="example.MovieRecommender"/>

</beans>
```

在类路径扫描和组件管理中, 你可以看到XML定义的基于注解的限定元数据. 特别的, 请参看使用注解提供限定元数据. 

一些情况下, 使用没有值的注解就足够了. 当注解服务于更普遍的目标并且能应用于多个不同类型的依赖时更为有用. 例如, 你可能需要提供一个离线目录供搜索, 当没有网络接入时. 首先, 定义简单的注解, 如下:

```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Offline {

}
```

然后, 添加注解到域或属性上, 如下:

```java
public class MovieRecommender {

    @Autowired
    @Offline //此处添加了注解@Offline
    private MovieCatalog offlineCatalog;

    // ...
}
```

现在bean定义仅仅需要一个限定`type`, 如下所示:

```xml
<bean class="example.SimpleMovieCatalog">
    <qualifier type="Offline"/>  <!--这个元素指定了限定-->
    <!-- inject any dependencies required by this bean -->
</bean>
```

你也可以定义自定义限定注解, 其可以接收更多的命名属性或替换简单的`value`属性. 如果多个属性值被指定到一个域或参数上, 自动包装时, bean的定义必须匹配所有这些属性值才能作为候选. 参看如下所示的定义:

```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface MovieQualifier {

    String genre();

    Format format();
}
```

这个例子中`Format`是枚举, 定义如下:

```java
public enum Format {
    VHS, DVD, BLURAY
}
```

自动包装的域是用自定义限定注解的, 其包含两个属性:`genre`和`format`, 如下所示:

```java
public class MovieRecommender {

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Action")
    private MovieCatalog actionVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Comedy")
    private MovieCatalog comedyVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.DVD, genre="Action")
    private MovieCatalog actionDvdCatalog;

    @Autowired
    @MovieQualifier(format=Format.BLURAY, genre="Comedy")
    private MovieCatalog comedyBluRayCatalog;

    // ...
}
```

最终, bean定义应该包含匹配的限定值. 这个示例也展示了你可以使用bean的元数据属性来代替`<qualifier/>`元素.  如果可用, `<qualifier/>`和他的属性优先, 但自动封装机制回退则使用`<meta/>`标签的值, 如果没有限定存在的话. 如下所示定义中后面两个:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog">
        <qualifier type="MovieQualifier">
            <attribute key="format" value="VHS"/>
            <attribute key="genre" value="Action"/>
        </qualifier>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <qualifier type="MovieQualifier">
            <attribute key="format" value="VHS"/>
            <attribute key="genre" value="Comedy"/>
        </qualifier>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <meta key="format" value="DVD"/>
        <meta key="genre" value="Action"/>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <meta key="format" value="BLURAY"/>
        <meta key="genre" value="Comedy"/>
        <!-- inject any dependencies required by this bean -->
    </bean>

</beans>
```

### 1.9.5 使用泛型作为自动包装限定符

另外, 对于`@Qualifier`注解, 你可以使用java泛型类型作为限定的隐式格式. 例如, 你有如下配置:

```java
@Configuration
public class MyConfiguration {

    @Bean
    public StringStore stringStore() {
        return new StringStore();
    }

    @Bean
    public IntegerStore integerStore() {
        return new IntegerStore();
    }
}
```

假设前面的bean实现了一个泛型接口(也就是`Store<String>`和`Store<Integer>`), 你可以`@Autowire`这个`Store`接口, 并且泛型被用来作为限定, 如下:

```java
@Autowired
private Store<String> s1; // <String> qualifier, injects the stringStore bean

@Autowired
private Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean
```

泛型限定也用来自动装配集合列表,`Map`接口和数组. 下面例子自动装配了泛型`List`:

```java
// Inject all Store beans as long as they have an <Integer> generic
// Store<String> beans will not appear in this list
@Autowired
private List<Store<Integer>> s;
```

### 1.9.6 使用`CustomAutowireConfigurer`

`CustomAutowireConfigurer`是一个`BeanFactoryPostProcessor`, 允许你注册你自己自定义的限定注解类型, 就算它们不是被Spring的`@Qualifier`注解的. 下例展示了如何使用`CustomAutowireConfigurer`:

```xml
<bean id="customAutowireConfigurer"
        class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer">
    <property name="customQualifierTypes">
        <set>
            <value>example.CustomQualifier</value>
        </set>
    </property>
</bean>
```

`AutowireCandidateResolver`通过下面的方式决定自动装配候选:

* 每个bean定义的`autowire-candidate`值
* 任何`<beans/>`元素上可用的`default-autowire-candidates`模型
* 使用了`@Qualifier`的注解以及通过`CustomAutowireConfigurer`注册的自定义注解

当多个bean被限定为自动装配的候选, 首要项的决策遵循: 如果候选中存在`primary`属性且值为`true`, 则它被选中. 

### 1.9.7 使用`@Resource`注入

Spring支持使用JSR-250规范的`@Resource`注解进行注入, 其(`javax.annotation.Resource`)能够用在域或者setter方法上. 这是JavaEE的一种普遍模式: 例如, 在JSF-管理的bean和JAX-WS端点中. Spring为Spring管理的bean也支持这种模式. 

`@Resource`获取name属性. 默认Spring将这个值作为bean名称注入. 换句话说, 它遵循按名称语义, 如下所示:

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource(name="myMovieFinder")  // 这里注入了一个@Resource
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
```

如果没有明确制定名称, 默认名称就是从域的名字或者setter方法导出. 在域情况下, 它使用域名称, 在setter方法情况下, 它获取bean属性名. 下面例子展示了名为`movieFinder`的bean注入到setter方法:

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
```

> 注解提供的名称将会被接收`CommonAnnotationBeanPostProcessor`通知的`ApplicationContext`解析为bean的名称. 名称可以通过JNDI解析, 如果你显式配置了Spring的`SimpleJndiBeanFactory`. 尽管可以, 但我们建议你依赖默认的行为并使用Spring的JNDI查找来保证间接级别. 

在没有显式的名称指定的`@Resource`使用场景下, 类似于`@Autowired`,`@Resource`查找主类型匹配而不是命名bean, 并且也可以解析熟知的依赖:`BeanFactory`, `ApplicationContext`, `ResourceLoader`, `ApplicationEventPublisher`, 和 `MessageSource` 接口.

因此, 下例中,`customerPreferenceDao`域首先查找一个名为"customerPreferenceDao"的bean 并且回退到主类型匹配的类型`CustomerPreferenceDao`:

```java
public class MovieRecommender {

    @Resource
    private CustomerPreferenceDao customerPreferenceDao;

    @Resource
    private ApplicationContext context; // `context`域是注入了熟知的依赖类型`ApplicationContext`

    public MovieRecommender() {
    }

    // ...
}
```

### 1.9.8 使用`@PostConstruct`和`@PreDestroy`

`CommonAnnotationBeanPostProcessor`不仅识别`@Resource`注解, 也可以识别JSR-250生命周期注解:`javax.annotation.PostConstruct`和`javax.annotation.PreDestroy`. Spring 2.5 引用的, 对于这些注解的支持提供了一种相应的生命周期回调机制, 如之前的初始化回调和销毁回调章节有描述的. 假设`ApplicationContext`注册了`CommonAnnotationBeanPostProcessor`, 一个添加了这些注解的方法将会被调用, 调用点与相应的Spring生命周期接口方法或显式声明回调方法相同. 下面例子中, 缓存通过初始化方法预热并通过销毁方法清除:

```java
public class CachingMovieLister {

    @PostConstruct
    public void populateMovieCache() {
        // populates the movie cache upon initialization...
    }

    @PreDestroy
    public void clearMovieCache() {
        // clears the movie cache upon destruction...
    }
}
```

关于组合使用不同的生命周期机制, 可以参看组合生命周期机制.

> 如同`@Resource`, `@PostConstruct` 和 `@PreDestroy`注解是从JDK6到8成为标准的java类库的一部分. 尽管这样, 整个`javax.annotation`包从JDK9的核心java模块中独立了, 并最终在JDK11中被删除.如果要用, 则需要从Maven中心引用`javax.annotation-api`架构, 简单的将其添加到类路径下.

## 1.10 类路径扫描和托管组件

本章中大部分例子都将使用XML来指定用于Spring容器生产`BeanDefinition`的配置元数据. 前面章节(基于注解的容器配置)阐述如何通过代码级别的注解来生成大量配置元数据. 就算在那些示例中, 最基础的bean定义依然是显式定义在XML文件中的, 而注解仅仅是驱动了DI. 本节描述一种隐式的通过扫描类路径方法探测候选组件的方式. 候选组件是一组按一定过滤规则匹配的并被容器注册的相关bean定义. 这就移除了使用XML来完成bean注册的方式. 相反, 你可以使用注解(例如:`@Component`), AspectJ类型表达式, 或者你自定义的过滤规则来筛选哪些类定义能注册到容器中.

> Spring 3.0 开始. 通过Spring的Java配置项目提供的一些特性成为了Spring核心的一部分. 这就允许你使用Java而不是传统的XML来定义bean. 可以参看`@Configuration`, `@Bean`, `@Import`, 和 `@DependsOn`注解示例来了解如何使用这些特性.

### 1.10.1 `@Component`和更多注解

`@Repository`注解是为很多履行一个仓储角色(等同于数据访问对象或DAO)的诸多类上的一个标记. 使用这个标记的一个用法就是自动解析异常, 如同在异常解析一节描述的. 

Spring 提供了更多注解: `@Component`, `@Service`, 和 `@Controller`. `@Component`是一般的使用在Spring管理的组件上的注解. `@Repository`, `@Service`, 和 `@Controller`是比`@Component`更具针对性的用例(各自分别在持久化,服务和表现层使用). 因此, 你可以在你的组件上使用`@Component`, 但使用`@Repository`, `@Service`, 和 `@Controller`替代将使你的类在工具处理时或联合使用方面时更合理. 例如, 这些注解提供了理想的目标切入点. `@Repository`, `@Service`, 和 `@Controller`也能在将来Spring版本中提供更多的语义.因此, 如果你在你的服务层中选择使用`@Component` 或 `@Service`, `@Service`是更明确的更好的选项. 类似的, 如前所述, `@Repository`在持久层已经得到异常解析方面的支持. 

### 1.10.2 使用元注解和组合注解

许多Spring提供的注解可以作为元注解用到你的代码中. 元注解是可以应用到另一个注解上的注解. 例如, 前面提到的`@Service`注解就是使用`@Component`元注解的, 如下:

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component // Component 将导致 @Service 与 @Component 一样被对待
public @interface Service {

    // ....
}
```

你也可以组合使用元注解用来创建组合注解. 例如, Spring MVC 的 `@RestController`是由`@Controller`和`@ResponseBody`组合的.

更多的, 组合注解能够选择重新定义元注解的属性来自定义. 如果你想要仅暴露元注解中的一些属性的话这就是有用的. 例如, Spring的`@SessionScope`注解硬编码了scope的名称为`session`, 但仍然允许自定义`proxyMode`. 如下是`SessionScope`的定义:

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Scope(WebApplicationContext.SCOPE_SESSION)
public @interface SessionScope {

    /**
     * Alias for {@link Scope#proxyMode}.
     * <p>Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
     */
    @AliasFor(annotation = Scope.class)
    ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

}
```

然后你可以不声明`proxyMode`来使用`@SessionScope`:

```java
@Service
@SessionScope
public class SessionScopedService {
    // ...
}
```

你也可以重写`proxyMode`的值, 如下所示:

```java
@Service
@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
public class SessionScopedUserService implements UserService {
    // ...
}
```

更多细节请看wiki页面的[Spring注解编程模型](https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model)

### 1.10.3 自动探测类和注册bean定义

Spring能自动探测更多的类并使用`ApplicationContext`注册相关的`BeanDefinition`实例.例如下面的两个类对于这样的自动探测是合适的:

```java
@Service
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}

@Repository
public class JpaMovieFinder implements MovieFinder {
    // implementation elided for clarity
}
```

为了自动探测并注册相关的bean, 你需要添加`@ConponentScan`到`@Configuration`类上, `basePackages`属性时两个类通用的包(如果多个包的话,你可以使用逗号或分号或空格分割的列表,将每个类的父包包含其中).

```java
@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig{
    ...
}
```

> 为了简洁, 上面例子可以使用注解的值属性(也就是`@ComponentScan("org.example")`).

下面是对应的XML:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="org.example"/>

</beans>
```

> 使用`<context:component-scan>`隐式的启用了`<context:annotation-config>`的功能. 当使用`<context:component-scan>`时就不需要在包含`<context:annotation-config>`元素了.

> 类路径包的扫描需要相关的目录包含在类路径下. 当你使用Ant打包JARs是, 确保没有为JAR任务打开"仅文件"开关. 同时, 类路径目录可能会在一些环境下由于安全策略而没有暴露--例如, JDK1.7.0-45的独立app或更高(需要信任类库设置在你的清单中, 参看[http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources](http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources)). 

> 在JDK9的模块路径(Jigsaw)下, Spring类路径扫描通常按预期执行. 尽管如此, 请确保你的组件类导出在`module-info`下. 如果你期望Spring调用你类中的非公有变量, 请确保他们是'opened'(也就是,在`module-info`描述符下,他们使用`opens`声明替换`exports`声明).

更多的, 当你使用component-scan元素时, `AutowiredAnnotationBeanPostProcessor`和`CommonAnnotationBeanPostProcessor`两者都是隐式包含的. 这意味着这两个组件被自动探测并一起包装了--都没有任何XML提供的bean配置元数据.

> 你可以通过包含`annotation-config`属性并设置为`false`来关闭 `AutowiredAnnotationBeanPostProcessor` 和 `CommonAnnotationBeanPostProcessor`.

### 1.10.4 使用过滤器来自定义扫描

默认情况下, 用`@Component`, `@Repository`, `@Service`, `@Controller`标记的类, 或者使用`@Component`元注解的自定义注解标记的类是探测的候选组件. 尽管这样, 你也可以通过应用过滤器修改和扩展行为. 为注解`@ComponentScan`添加`includeFilters`或`excludeFilters`参数(或者`component-scan`元素的`include-filter`或 `exclude-filter`子元素). 每个元素都需要`type`和`expression`属性, 下面的表格描述了过滤选项:

**表5. 过滤类型**
|过滤类型|示例表达式|描述|
|-------|----------|----|
|annotation (default)|org.example.SomeAnnotation|目标组件上, 在类级别上出现的注释|
|assignable|org.example.SomeClass|目标组件要被其扩展或实现的类或接口|
|aspectj|org.example..*Service+|与目标组件匹配的一个AspectJ表达式|
|regex|org\.example\.Default.*|与目标组件类名称匹配的正则表达式|
|custom|org.example.MyTypeFilter|`org.springframework.core.type.TypeFilter`接口的自定义实现|

下面例子展示了忽略所有`@Repository`注解并使用"stub"仓储代替的配置:

```java
@Configuration
@ComponentScan(basePackages = "org.example",
        includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
        excludeFilters = @Filter(Repository.class))
public class AppConfig {
    ...
}
```

下面例子是等效的XML配置:

```xml
<beans>
    <context:component-scan base-package="org.example">
        <context:include-filter type="regex"
                expression=".*Stub.*Repository"/>
        <context:exclude-filter type="annotation"
                expression="org.springframework.stereotype.Repository"/>
    </context:component-scan>
</beans>
```

> 你也可以通过在注解上设置`useDefaultFilters=false`或者给元素`<component-scan/>`设置`use-default-filters="false"`来使默认过滤器失效. 这实际上也使得使用`@Component`, `@Repository`, `@Service`, `@Controller`, 或 `@Configuration` 注解的类的自动探测失效了.

### 1.10.5 在组件中定义元数据

Spring组件也能为容器贡献bean定义元数据. 你可以通过使用`@Configuration`注解的类里面的`@Bean`注解来定义bean元数据. 下面例子展示了这种方式:

```java
@Component
public class FactoryMethodComponent {

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    public void doWork() {
        // Component method implementation omitted
    }
}
```

上面的类是Spring的一个组件,`work()`方法中它有应用特定的代码. 它也贡献了一个bean的定义,有个引用方法`publicInstance()`的工厂方法. `@Bean`注解标识了工厂方法和其他bean定义的属性, 如通过`@Qualifier`指定的限定值. 其他方法级别的注解可能是特定的`@Scope`,`@Lazy`以及自定义限定注解.

> 除了组件初始化角色, 你也可以将`@Lazy`注解放在由`@Autowired`或`@Inject`标记的注入点上. 在这个上下文中, 它最终注入了一个延迟解析代理.

自动装配域和方法是受支持的, 如前所述, 同时对`@Bean`方法有更多的自动封装的支持. 如下所述:

```java
@Component
public class FactoryMethodComponent {

    private static int i;

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    // use of a custom qualifier and autowiring of method parameters
    @Bean
    protected TestBean protectedInstance(
            @Qualifier("public") TestBean spouse,
            @Value("#{privateInstance.age}") String country) {
        TestBean tb = new TestBean("protectedInstance", 1);
        tb.setSpouse(spouse);
        tb.setCountry(country);
        return tb;
    }

    @Bean
    private TestBean privateInstance() {
        return new TestBean("privateInstance", i++);
    }

    @Bean
    @RequestScope
    public TestBean requestScopedInstance() {
        return new TestBean("requestScopedInstance", 3);
    }
}
```

示例自动为类型为`String`的参数`country`自动装配了另一个名为`privateInstance`的bean的age属性值. Spring表达式语言元素通过注解`#{<expression>}`定义了值. 对于`@Value`注解, 表达式解析器在解析表达式文本的时候查找bean的名称.

从Spring4.3开始, 你可能需要声明一个参数类型为`InjectionPoint`的工厂方法(或者它的特定的子类如`DependencyDescriptor`), 来访问请求的注入点来触发当前bean的创建. 注意这种仅适用于真实的bean实例创建, 对于已存在实例的注入不适用. 作为其结果, 这个特性对于原型bean更有意义. 对于其他作用域, 工厂方法仅看到scope内触发创建新bean实例的注入点(例如, 触发创建延迟加载单例bean的依赖项).这种情况下你可以谨慎的使用注入点元数据. 下面例子展示了如何使用`InjectionPoint`:

```java
@Component
public class FactoryMethodComponent {

    @Bean @Scope("prototype")
    public TestBean prototypeInstance(InjectionPoint injectionPoint) {
        return new TestBean("prototypeInstance for " + injectionPoint.getMember());
    }
}
```

普通Spring组件中的`@Bean`方法与其他在Spring`@Configuration`类中的其他同辈们处理是不同的. 不同之处在于, `@Component`类没有用CGLIB增强用来切入方法和域的调用. CGLIB代理是一种调用`@Configuration`类中`@Bean`注解的方法和域来创建引用到相关对象的bean元数据的方法.此类方法不会被普通的java语义调用, 而是为了提供非正常的生命周期管理和Spring的Bean代理而贯穿容器, 即使是通过编程方法调用`@Bean`方法引用其他bean时. 相反, 调用`@Component`类中的`@Bean`方法或域时使用标准java语义, 没有其他特定CGLIB的处理或应用其他限制.

> 你可能声明`@Bean`为`static`, 允许调用它们，而无需将其包含的配置类作为实例创建。这在定义post-processor的bean时有特殊的意义(例如, 类型`BeanFactoryPostProcessor` 或 `BeanPostProcessor`), 因为这样的bean会被容器生命周期中更早的初始化, 并且在这个点上应该避免触发其他配置部分.

> 调用静态的`@Bean`方法从来不会被容器切入, 就算是`@Configuration`类(如前所述), 由于技术限制: CGLIB 子类仅仅能覆盖非静态方法. 因此, 对另一个`@Bean`方法的直接调用具有java语义, 结果一个独立的实例直接由工厂方法返回. 

> `@Bean`方法的Java语言的可见性不会立即对Spring容器中的bean定义产生影响. 你可以自由的在非`@Configuration`类中声明工厂方法, 或者在任何地方声明静态方法. 尽管可以, `@Configuration`类中普通的`@Bean`方法需要是可覆盖的-- 也就是他们不能被声明为`private`或者`final`.

> 在提供的组件或配置类中`@Bean`方法可以被发现, 同样在java8的由组件和配置类实现的接口中的默认实现方法也可以. 从Spring4.2开始, 这就允许在组合复杂配置时有更大的灵活性, 甚至通过Java8的默认办法使多继承成为可能. 

> 最终,一个类中可能持有相同bean的多个方法, 作为多工厂方法的安排, 这些取决于于运行时可用依赖. 这与选择最佳构造函数或配置中的工厂方法是相同的算法: 在构造时会选择具有最大数量的依赖项的变量，即容器如何在多个`@Autowired`构造函数之间进行选择。

### 1.10.6 命名的自动探测组件

当一个组件被作为扫描过程的一部分探测到时, 它的bean名称通过扫描者知道的`BeanNameGenerator`策略生成. 默认情况下,任何Spring的注解(`@Component`, `@Repository`, `@Service`, 和 `@Controller`)包含一个名字`value`因此提供了相应bean定义的名称. 

如果注解不包含`value`或被其他组件探测(例如自定义过滤器), 默认的bean名称生成器会返回首字母小写的不合格类名. 例如, 付过下面的组件类被探测到, 他们的名字应该是`myMovieLister`和`movieFinderImpl`.

```java
@Service("myMovieLister")
public class SimpleMovieLister {
    // ...
}
```

```java
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
```

> 如果你不想依赖默认的bean命名策略, 你可以提供自定义的bean命名策略. 首先,实现`BeanNameGenerator`接口, 并且保证包含了无参构造函数. 接着, 当配置扫描者的时候提供全限定类名, 如下例子中的注解和bean定义展示的:

```java
@Configuration
@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)
public class AppConfig {
    ...
}
```

```xml
<beans>
    <context:component-scan base-package="org.example"
        name-generator="org.example.MyNameGenerator" />
</beans>
```

作为通用规定, 考虑使用注解指定名称, 当其他组件显式引用到它时. 另一方面,当容器负责装配时自动生成的名称就足够了. 

### 1.10.7 位自动探测组件提供作用域

Spring托管组件一样, 默认的和大多数通用的scope是`singleton`. 虽然如此, 有时候你需要通过`@Scope`指定一个不同的作用域. 你可以为其指定名字, 如下所示:

```java
@Scope("prototype")
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
```

`@Scope`注解仅在具体的bean类上(注解的组件)或工厂方法上(`@Bean`方法)是自省的. 相比于XMLbean定义, 没有bean定义继承的概念, 并且类级别的继承与元数据不相干. 

在Spring上下文中更多的关于web特定的作用域如"request","session"等,请参看Request,Session,Application和WebSocket作用域. 这些作用域有预置的注解, 你也可以使用Spring元注解的方式组合你自己的作用域注解: 例如, 使用`@Scope("prototype")`自定义注解,可能需要声明一个自定义的scope-proxy模式.

> 为作用域解析提供一个自定义策略而不是依赖注解的方式, 你可以实现接口`ScopeMetadataResolver`. 确保包含一个无参构造函数. 接着你在配置扫描的时候提供一个全限定名, 如下例子中的注解和bean定义所示:

```java
@Configuration
@ComponentScan(basePackages = "org.example", scopeResolver = MyScopeResolver.class)
public class AppConfig {
    ...
}
```

```xml
<beans>
    <context:component-scan base-package="org.example" scope-resolver="org.example.MyScopeResolver"/>
</beans>
```

当使用非单例作用域时, 也许必要为作用域的对象生成代理. 原因在作用域bean作为依赖项中有描述. 为了达到此目的, component-scan元素的一个scoped-proxy属性时可用的. 三种可能的值分别是: `no`,`interfaces`,`和targetClass`. 例如, 下面配置将生成标准的JDK动态代理:

```java
@Configuration
@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
public class AppConfig {
    ...
}
```

```xml
<beans>
    <context:component-scan base-package="org.example" scoped-proxy="interfaces"/>
</beans>
```

### 1.10.8 Qualifier元数据注解

在使用修饰符来微调基于注解的装配中讨论了`@Qualifier`注解. 那一节中的例子展示了在解析自动装配的候选的时候, `@Qualifier`注解和自定义修饰注解提供的更好的控制. 因为这些例子基于XML bean定义, 修饰元数据是通过在作为候选的`bean`元素中使用`qualifier` 或 `meta`子元素来实现的. 当依赖于类路径扫描的自动探测组件时, 你可以在候选类上添加限定元数据注解. 下面三个例子展示了这种技术:

```java
@Component
@Qualifier("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}
```

```java
@Component
@Genre("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}
```

```java
@Component
@Offline
public class CachingMovieCatalog implements MovieCatalog {
    // ...
}
```

> 对大多数基于注解的变体, 记住注解元数据是绑定到类定义自身的, 使用XML允许给相同类型的多个bean提供不同的限定元数据, 因为元数据是提供给每个实例,而不是每个类型. 

### 1.10.9 候选组件生成索引

虽然类路径扫描是很快的, 对于大型程序, 也可以通过在编译时创建一个静态候选列表在提供启动性能. 在这种模式下,自动扫描的所有模块必须必须使用这种机制. 

> `@ComponentScan`或`<context:component-scan>`指令必须保持不变, 以请求上下文扫描特定包中的候选. 当`ApplicationContext`探测到这么个索引, 则自动使用它而不是扫描类路径.

生成索引, 要给每个包含被扫描的目标组件的模块添加一个额外的依赖. 下例展示了Maven中的配置:

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context-indexer</artifactId>
        <version>5.2.0.BUILD-SNAPSHOT</version>
        <optional>true</optional>
    </dependency>
</dependencies>
```

对于Gradle4.5或更早版本, 依赖需要声明在`compileOnly`配置中, 如下例子所示:

```groovy
dependencies {
    compileOnly "org.springframework:spring-context-indexer:5.2.0.BUILD-SNAPSHOT"
}
```

> 对于Gradle4.6及以后版本, 依赖需要声明在`annotationProcessor`配置中, 如下例子所示:

```groovy
dependencies {
    annotationProcessor "org.springframework:spring-context-indexer:5.2.0.BUILD-SNAPSHOT"
}
```

处理过程将生成一个`META-INF/spring.components`文件, 包含在jar文件. 

> 当在你的IDE中使用此模式的时候, `spring-context-indexer`必须作为注解处理器注册, 来确保当候选组件更新时索引页同步更新. 

> 当`META-INF/spring.components`存在在类路径下时, 索引自动生效. 如果索引是特定对某些库(或用例)可用但不是为整个程序构建时, 你可以通过`spring.index.ignore`设置为`true`来回退到标准的类路径排列(好像根本不存在索引), 无论是作为系统属性或设置在类路径下的`spring.properties`文件. 

## 1.11 使用JSR330标准注解

Spring3.0 开始, Spring提供了对JSR-330标准注解(依赖注入)的支持. 这些注解与Spring注解以同样的方式被扫描. 使用它们你需要在类路径下引入相关的jar.

> 如果你使用Maven, `javax.inject`在标准的Maven仓储下是可用的([http://repo1.maven.org/maven2/javax/inject/javax.inject/1/](http://repo1.maven.org/maven2/javax/inject/javax.inject/1/)). 你可以添加下面依赖到pom.xml:

```xml
<dependency>
    <groupId>javax.inject</groupId>
    <artifactId>javax.inject</artifactId>
    <version>1</version>
</dependency>
```

### 1.11.1 使用`@Inject`和`@Named`依赖注入

代替`@Autowired`注解, 也可以使用`@javax.inject.Inject`如下:

```java
import javax.inject.Inject;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.findMovies(...);
        ...
    }
}
```

如同`@Autowired`, 你可以将`@Inject`使用在域级别,方法级别和构造参数级别. 而且你可能声明你的注入点为一个`Provider`, 允许按需访问较短作用域的bean或者通过`Provider.get()`调用延迟访问其他bean. 下例提供了上面例子中的一个变体:

```java
import javax.inject.Inject;
import javax.inject.Provider;

public class SimpleMovieLister {

    private Provider<MovieFinder> movieFinder;

    @Inject
    public void setMovieFinder(Provider<MovieFinder> movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.get().findMovies(...);
        ...
    }
}
```

如果你想为注入的依赖项使用限定名称, 可以使用`@Named`注解, 如下例:

```java
import javax.inject.Inject;
import javax.inject.Named;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(@Named("main") MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

如同`@Autowired`,`@Inject`也可以与`java.util.Optional`或`@Nullable`一同使用. 在这里这是更合适的, 因为`@Inject`没有`required`属性. 下面两个例子展示了如何使用`@Inject`和`@Nullable`:

```java
public class SimpleMovieLister {

    @Inject
    public void setMovieFinder(Optional<MovieFinder> movieFinder) {
        ...
    }
}
```

```java
public class SimpleMovieLister {

    @Inject
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        ...
    }
}
```

### 1.11.2 `@Named`和`@ManagedBean`: 标准可替换`@Component`的注解

替换`@Component`, 也可以使用`@javax.inject.Named`或`javax.annotation.ManagedBean`, 如下所示:

```java
import javax.inject.Inject;
import javax.inject.Named;

@Named("movieListener")  // @ManagedBean("movieListener") could be used as well
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

使用没有指定名称的`@Component`是很普遍的. `@Named`可以用同样的风格, 如下:

```java
import javax.inject.Inject;
import javax.inject.Named;

@Named
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

当使用`@Named` 或 `@ManagedBean`时, 你可以像使用Spring注解一样使用组件扫描, 如下所示:

```java
@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    ...
}
```

> 不同于`@Component`, JSR-330 的 `@Named` 和 JSR-250 的 `ManagedBean`注解不能组合使用. 你应该使用Spring场景模型或者创建自定义注解. 

### 1.11.3 JSR-330 标准注解的限制

使用标准注解, 你应该知道一些显著的特性是不可用的, 如下表所示:

**表6 Spring组件模型元素与JSR-330变体的区别**
|Spring|Javax.inject.*|javax.inject限制/说明|
|------|----------------|-------------------|
|@Autowired|@Inject|`@Inject`没有'required'属性. 可以用Java8的`Optional`替代|
|@Component|@Named/@ManagedBean|JSR-330不提供组合模型,仅仅是一种标识命名模型的方式|
|@Scope("singleton")|@Singleton|JSR-330的默认作用域类似Spring的`prototype`. 所以为了保持与Spring默认的一致性, JSR-330 的bean声明在容器中默认是`singleton`的. 为了使用非`singleton`的其他作用域, 你需要使用Spring的`@Scope`注解. `javax.inject`也提供了@Scope注解.不过这个仅仅用来创建你自己的注解时使用.|
|@Qualifier|@Qualifier / @Named|`javax.inject.Qualifier`仅是为了创建自定义限定的元注解.具体的`string`类型的限定符(如同Spring的`@Qualifier`带有一个值)可以是通过`javax.inject.Named`关联|
|@Value|-|无等效的|
|@Required|-|无等效的|
|@Lazy|-|无等效的|
|ObjectFactory|Provider|`javax.inject.Provider`是Spring的`ObjectFactory`的替代, 但仅仅有一个短的方法`get()`. 它也可以用在与Spring`@Autowired`或无注解构造函数以及setter方法上组合使用|

## 1.12 基于Java的容器配置

这节内容涵盖了如何在java代码中使用注解配置容器. 包含下面主题:

* 基本概念: `@Bean`和`@Configuration`
* 使用`AnnotationConfigApplicationContext`初始化Spring容器
* 使用`@Bean`注解
* 使用`@Configuration`注解
* 组合基于java的配置
* Bean定义档案
* `PropertySource`抽象
* 语句中的占位符解析

### 1.12.1 基本概念: `@Bean`和`@Configuration`

Spring中的基于Java的配置支持和核心是`@Configuration`注解类和`@Bean`注解的方法.

`@Bean`注解用来表明一个方法实例化,配置,并初始化出有Spring容器管理的新对象.对于熟悉Spring的`<beans/>`XML配置, `@Bean`注解扮演了与`<bean/>`元素相同的角色. 你可以与Spring`@Component`一起使用`@Bean`注解方法. 即使如此, 他们总是跟`@Configuration`bean一起使用的.

`@Configuration`注解的类表明它的主要目的是作为bean定义的源. 而且`@Configuration`允许通过调用同一个类中的其他`@bean`方法来定义bean间的依赖关系. 可能最简单的`@Configuration`类如下:

```java
@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
```

上面的`AppConfig`类等同于下面的`<beans/>`XML配置;

```xml
<beans>
    <bean id="myService" class="com.acme.services.MyServiceImpl"/>
</beans>
```

> **全@Configuration vs 轻@Bean模式**

> 当`@Bean`方法在没有被`@Configuration`注解的类中声明时, 它们会作为轻型模式被处理. 在`@Component`中的bean方法或在普通旧的类中的bean方法会被认为是轻型的, 与包含的类有不同的主要目的, 并且`@Bean`方法是种额外的好处.例如, 服务组件可能通过各合适的组件类附加的`@Bean`方法暴露管理视图给容器. 此情景下, `@Bean`方法是通用的工厂方法机制.

> 不同于全`@Configuration`, 轻量`@Bean`方法不能声明内部bean依赖. 相反, 他们操作包含他们组件的内部状态, 以及可选择的它们声明的参数. 这样的`@Bean`方法因此不能调用其他`@Bean`方法. 每个这个的方法仅仅是对特定bean的引用的工厂方法, 不需要任何运行时的特定语义. 积极的一个影响是运行时没有CGLIB子类被应用, 因此在类设计方面没有任何限制(也就是,包含类可能是`final`的等等).

> 普遍场景下, `@Bean`方法在`@Configuration`类内部声明, 要保证full模式总是被使用并跨方法引用因此直接关联到容器生命周期管理. 这就阻止了相同的`@Bean`方法通过普通Java调用, 从而帮助减少lite模式下难以追踪的bug发生. 

`@Bean`和`@Configuration`注解在接下来的章节中会更深的讨论. 首先, 我们扫描了通过使用Java配置的方式创建容器的方式. 

### 1.12.2 使用`AnnotationConfigApplicationContext`初始化Spring容器

接下来的章节记录了Spring的`AnnotationConfigApplicationContext`, Spring3.0引入的. 多功能的`ApplicationContext`实现能接收不仅仅是`Configuration`类作为输入, 还有`@Component`类以及JSR-330元数据注解的类.

当`@Configuration`类作为输入时, `@Configuration`类本身被作为bean定义注册并将其内部所有的`@Bean`方法也被注册为bean定义.

当`@Component`和JSR-330类作为输入时, 他们被注册为bean定义, 并且假定如`@Autowired`或`@Inject`的DI元数据在这些类的内部按需使用.

#### 简单的结构

与Spring的XML文件用来被初始化`ClassPathXmlApplicationContext`时的输入一样, 你可以使用`@Configuration`类作为初始化`AnnotationConfigApplicationContext`时的输入. 这允许完全不适用XML的方式, 如下所示:

```java
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```

如前面提到的, `AnnotationConfigApplicationContext`不仅限于`@Configuration`类. 任何`@Component`或者JSR-330注解类都可以作为构造的参数, 如下所示:

```java
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```

前面的实例假设了`MyServiceImpl`,`Dependency1`和 `Dependency2`使用了诸如`@Autowired`的Spring DI注解. 

#### 通过`register(Class<?> ... )`编程构建容器

你可以通过无参构造实例化`AnnotationConfigApplicationContext`,然后通过`register()`方法配置它. 这种方法在编程构建`AnnotationConfigApplicationContext`是特别有用. 如下所示:

```java
public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(AppConfig.class, OtherConfig.class);
    ctx.register(AdditionalConfig.class);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```

#### 使用`scan(String…​)`开启组件扫描

开启组件扫描, 你可以在`@Configuration`类上注解如下:

```java
@Configuration
@ComponentScan(basePackages = "com.acme")  // 这个注解启动了组件扫描
public class AppConfig  {
    ...
}
```

有经验的Spring用户可能更熟悉XML声明, 它是从Spring的`context:`命名空间, 如下例子所示:

```xml
<beans>
    <context:component-scan base-package="com.acme"/>
</beans>
```

在前面例子中, `com.acme`包被扫描以查找任何`@Component`注解的类, 还有那些注册在Spring容器内的bean定义.`AnnotationConfigApplicationContext`暴露的`scan(String…​)`方法拥有同样的组件扫描能力, 如下所示:

```java
public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.scan("com.acme");
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
}
```

> 记住`@Configuration`类是使用`@Component`元注解的, 所以他们是扫描的候选. 在前面的例子中, 假设`AppConfig`声明在`com.acme`包内部(包括更深层次的包内), 在调用`scan()`期间它被选中. 依赖`refresh()`, 它所有的`@Bean`方法被处理并注册在容器内部.

#### 使用`AnnotationConfigWebApplicationContext`支持WEB程序

一种`WebApplicationContext`的`AnnotationConfigApplicationContext`变体是`AnnotationConfigWebApplicationContext`. 当配置`ContextLoaderListener`Sevlet监听器, Spring MVC `DispatcherServlet`等时可以使用这个实现. 下面的`web.xml`片段配置一个典型的Spring MVC Web程序(注意`contextClass` context-param 和 init-param 的使用).

```xml
<web-app>
    <!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
        instead of the default XmlWebApplicationContext -->
    <context-param>
        <param-name>contextClass</param-name>
        <param-value>
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        </param-value>
    </context-param>

    <!-- Configuration locations must consist of one or more comma- or space-delimited
        fully-qualified @Configuration classes. Fully-qualified packages may also be
        specified for component-scanning -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>com.acme.AppConfig</param-value>
    </context-param>

    <!-- Bootstrap the root application context as usual using ContextLoaderListener -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <!-- Declare a Spring MVC DispatcherServlet as usual -->
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
            instead of the default XmlWebApplicationContext -->
        <init-param>
            <param-name>contextClass</param-name>
            <param-value>
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            </param-value>
        </init-param>
        <!-- Again, config locations must consist of one or more comma- or space-delimited
            and fully-qualified @Configuration classes -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>com.acme.web.MvcConfig</param-value>
        </init-param>
    </servlet>

    <!-- map all requests for /app/* to the dispatcher servlet -->
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/app/*</url-pattern>
    </servlet-mapping>
</web-app>
```

### 1.12.3 使用`@Bean`注解

`@Bean`是方法级别的注解, 并且与XML 的 `<bean/>`元素同源. 这个注解支持一些`<bean/>`属性,如`* init-method * destroy-method * autowiring * name`.

在`@Configuration`注解的或者在`@Component`注解的类中都可以使用`@Bean`注解. 

#### 声明一个Bean

要声明bean, 你可以在一个方法上添加`@Bean`注解. 在`ApplicationContext`内部, 这个方法将被它的返回值类型注册到容器的bean定义. 默认bean的名字和方法名称是一样的. 下面示例展示了`@Bean`的声明:

```java
@Configuration
public class AppConfig {

    @Bean
    public TransferServiceImpl transferService() {
        return new TransferServiceImpl();
    }
}
```

上面的配置是等同于下面XML的配置:

```xml
<beans>
    <bean id="transferService" class="com.acme.TransferServiceImpl"/>
</beans>
```

两种方式都使得名为`transferService`的bean在`ApplicationContext`可用, 绑定到一个类型为`TransferServiceImpl`的实例, 如下所示:

```
transferService -> com.acme.TransferServiceImpl
```

你也可以使用接口(或基类)声明`@Bean`方法返回类型, 如下所示;

```java
@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }
}
```

然则, 这限制了预测类型的可见性为接口类型(`TransferService`). 然后, 容器仅知道一次完整类型(`TransferServiceImpl`),受影响的bean单例被创建了. 非延迟加载的单例bean实例化根据他们声明的顺序初始化, 所以,依赖于当其他组件尝试匹配一个没有声明的类型时, 你可能看到不同类型的匹配结果(如`@Autowired TransferServiceImpl`, 仅在`transferService`被实例化时解析). 

> 如果你持续通过声明的服务接口引用, 你的`@Bean`返回类型可能安全地参与到设计决策中. 然而, 对于实现了多个接口或对于潜在引用它们实现类型的组件, 更安全的是尽可能的指定返回类(至少指定引用到bean的注入点时需要的类型)

#### Bean依赖












