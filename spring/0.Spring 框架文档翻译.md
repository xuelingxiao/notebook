# Spring 框架文档
### Version 5.1.3.RELEASE

---

> 最新的, 更新的笔记, 支持的版本和其他主题,独立的发布版本等, 是在Github Wiki 项目维护的.


* **总览**  历史, 设计哲学, 反馈, 入门. 

* **核心**  IoC容器, 事件, 资源, 国际化(i18n), 验证, 数据绑定, 类型转化, Spring表达式语言(SpEL), 面向切面编程(AOP).

* **测试**  Mock对象, 测试上下文框架(TestContext framework), Spring MVC 测试, WebTestClient.

* **数据访问**  事务, DAO支持, JDBC, ORM, 编组XML.

* **Web Servlet** Spring MVC, WebSocket, SockJS, STOMP 消息. 

* **Web Reactive** Spring WebFlux, WebClient, WebSocket.

* **集成** Remoting, JMS, JCA, JMX, Email, Tasks, Scheduling, Cache.

* **语言** Kotlin, Groovy, 动态语言(Dynamic languages).



*****



# 第一部分 总览

内容:

1. 我们为什么以"Spring"命名
2. Spring及Spring框架的历史
3. 设计哲学
4. 反馈和贡献
5. 入门

**Spring 简化了Java企业应用的创建. 可以提供在企业应用环境下Java生态所需的一切, 同时也支持Kotlin和Groovy作为JVM的替代语言, 根据实际需要,也可以创建多种不同的架构.(architecture). 从Spring Framwork 5.0 开始, Spring需要JDK 8+ 并且已经为JDK9提供开箱即用支持**

Spring提供了广泛的应用场景. 在大型企业应用中,应用往往要存在很长一段时间,并且不得不运行在一个升级周期超出开发人员控制的JDK和服务器上. 而其他的应用则使用内嵌服务器单独运行jar包,或者部署在云环境. 还有一些应用可能独立部署, 根本不需要服务器(例如批处理或集成负载). 

Spring是开源的.背后有长期大量而活跃的根据实际应用案例而提交的反馈.这将帮助Spring成功长期进化.

## 1. 命名"Spring"的含义

"Spring"意思是在不同环境中不同的东西. 能够用来指代Spring项目本身(这是它的发端起始点). 随着时间推移, 其他建立在Spring之上的项目被创建出来. 通常我们称"Spring", 其实是指所有这些项目. 本文档主要聚焦基础: 也就是Spring框架本身.

Spring框架分模块. 可以根据情况选择需要的模块. 核心模块是核心容器, 包含配置模型和依赖注入机制. 还有更多,Spring 框架提供了对不同应用架构的基础支持. 包含消息,事务和持久化,还有Web. 它还包含基于Servlet的MVC框架, 同时提供了对应的交互式框架Web Flux. 

关于模块的提醒: Spring框架jar文件允许JDK9支持的模块路径("Jigsaw"). 在此类应用中, Spring Framework 5 的jar文件带有自动模块名称清单. 它定义了独立于jar工件的语言级别的模块名称（“spring.core”，“spring.context”等）. 当然, Spring在JDK8和9的类路径上都可以正常工作. 

## 2. Spring 和 Spring Framework 的历史

Spring 是为了回应早期复杂的J2EE规范于2003年诞生. 有人认为 Java EE 和 Spring 是竞争关系,实际上,Spring是Java EE 的补充. Spring的编程模型并不是完全拥抱Java EE平台规范, 而是小心地有选择地从EE生态中集成了独立的规范:

1. Servlet API ([JSR 340](https://jcp.org/en/jsr/detail?id=340))

2. WebSocket API ([JSR 356](https://www.jcp.org/en/jsr/detail?id=356))

3. Concurrency Utilities ([JSR 236](https://www.jcp.org/en/jsr/detail?id=236))

4. JSON Binding API ([JSR 367](https://jcp.org/en/jsr/detail?id=367))

5. Bean Validation ([JSR 303](https://jcp.org/en/jsr/detail?id=303))

6. JPA ([JSR 338](https://jcp.org/en/jsr/detail?id=338))

7. JMS ([JSR 914](https://jcp.org/en/jsr/detail?id=914))

8. 如果需要的话,还有 JTA/JCA 做事务协调

Spring Framework 还支持依赖注入([JSR 330](https://www.jcp.org/en/jsr/detail?id=330))和普通注解([JSR 250](https://jcp.org/en/jsr/detail?id=250))规范. 这些规范的实现由开发人员可以用来替换Spring默认提供的机制.

Spring Framework 5.0 开始起, Spring要求Java EE 7以上(e.g. Servlet 3.1+, JPA 2.1+).同时使用新的Java EE 8(e.g. Servlet 4.0, JSON Binding API)以上的新api提供开箱即用.这就保证了Spring完全兼容Timcat8和9, WebSphere9, 还有JBoss EAP 7.

慢慢的,Java EE 在开发中的角色发生了变化. 早期Java EE 和 Spring创建的程序是被部署到应用程序服务器上. 而今天, 归功于Spring Boot, 应用程序以devops或云的方式创建,使用内嵌的Servlet容器, 而且经常变化.自从Spring Framework 5 , WebFlux程序甚至都不需要直接调用Servlet Api了, 它可以运行在非Servlet规范的容器(如Netty)中.

Spring是持续革新和进化的. 超出Spring Framework, 有很多其他项目如Spring Boot, Spring Security,Spring Data,Spring Cload, Spring Batch,还有很多. 每个项目都有它自己的源码仓库, 问题跟踪和发布周期. 从[spring.io/projects](https://spring.io/projects) 可以看到所有项目的列表.

## 3. 设计哲学

当你学习一个框架的时候, 不仅要知道它能干什么, 更重要的是知道它所遵循的原则. 下面是Spring Framework遵循的指导原则.

* 在所有层面提供选择权. Spring允许你尽量延迟设计选择. 例如, 你可以通过配置而不是修改代码就替换掉数据持久化的提供程序.这也同样适用于其他基础设施概念并能集成很多三方API.

* 容纳不同的观点. Spring 拥抱伸缩性, 它并不坚持认为事情应该就这样做. 根据观点不同, 它提供了广泛的应用选择.

* 保持强大的向后兼容性. Spring演化经过精心设计和管理, 可以防止版本之间出现破坏性改变. Spring支持一定范围版本的JDK和第三方库. 便于维护依赖于Spring的程序和库. 

* 关心API设计. Spring团队花费大量精力和时间设计API, 使其直观并且能保持多个版本和持续很多年.

* 高质量的编码, Spring强调有意义的, 实时的,准确的javadoc. 是极少数声称代码简洁且包之间没有循环依赖的项目之一.

## 4. 反馈和贡献

对于如何操作或诊断或调试问题, 我们强烈建议使用StackOverflow, 并且我们有一个问题页清单, 列出了使用建议. 如果你完全确定Spring Framework有问题或者想提交特性, 请使用JIRA问题跟踪.

如果你解决了问题或者修正了建议, 你可以在GitHub上发起PR. 总之,请记住, 除了微不足道的问题,我们希望有个问题存根进行讨论并记录下来供未来参考. 

更多问题请参看顶级页面"贡献"页上的指南.

## 5 入门

如果你刚开始使用Spring, 你可能想要通过创建一个Spring Boot的项目开始Spring之旅. Spring Boot提供了一个快速(也是固化的)方式创建生产就绪的 Spring 程序, 它基于Spring 框架, 信奉约定优于配置,并且设计为快速启动运行. 

你可以使用start.spring.io来生成基础项目, 或者按照"入门"指南一步步创建, 例如"Getting Started Building a RESTful Web Service". 这些指南只关注于当前主题任务, 可以比较容易的理解, 很多都是Spring Boot项目. Spring portfolio还包含其他项目, 当你解决特定问题时你可能会考虑关注下相关的项目.



***



# 核心技术

**这部分指导文档涵盖了Spring Framework不可或缺的所有技术**

这些技术中最重要的,是Spring Framework的Ioc容器. 在吃透了Spring Framework 的IoC容器之后,紧接着是理解Spring的AOP技术. Spring Framework有其自身的AOP框架, 概念上很好理解并且能够满足实际应用中80%的热点需要.

Spring提供了AspectJ集成(这是目前特性最为丰富,当然也是Java企业领域最成熟的AOP实现).

## 1. IoC容器

本章涵盖Spring的IoC容器.

### 1.1 介绍Spring IoC容器和Beans

本节涵盖了Spring Framework对IoC原则的实现. DI是与其密切相关的另一个概念. IoC是一个处理过程,通过这个过程,对象只能通过构造函数参数, 工厂方法参数或在从工厂方法构造或返回的对象实例上设置的属性来定义他们的依赖关系. 当创建这些bean时, 容器去注入这些依赖. 这个过程从根本上反转了由对象自身去控制它所需依赖的方式, 通过直接类构造或类似Service Locator模式的机制.

`org.springframework.beans` 和 `org.springframework.context` 这两个包是IoC容器的基础. `BeanFactory` 接口提供了能够管理任何对象类型的高级配置机制. `ApplicationContext` 是 `BeanFactory` 的一个子类接口. 增加以下功能:

* 易于与Spring的AOP特性集成.
* 消息资源处理(国际化)
* 事件发布
* 应用程序层次的特定上下文,例如:在Web程序中的`WebApplicationContext`.

简言之, `BeanFactory` 提供了配置框架和基本的功能, `ApplicationContext` 增加了诸多企业特性功能.  `ApplicationContext` 是 `BeanFactory` 的一个完整超集, 在本章中专门用于Spring IoC容器的描述. 如果想用`BeanFactory`代替`ApplicationContext`可以参看后面有关`BeanFactory`的内容.

Spring中,构成你程序的骨架并且被Spring IoC容器管理的对象被称为beans. bean就是一个被Spring IoC容器实例化,装配和管理的对象. bean也可以简单的是应用中诸多对象中的一个.bean和他们之间的依赖被映射到容器的配置元数据中.

## 1.2 容器概览

`org.springframework.context.ApplicationContext` 接口代表了Spring IoC容器并且负责实例化,配置,组装bean. 容器通过读取配置元数据获取指令来实例化,配置,组装bean.配置元数据使用XML,Java注解或者Java代码的方式表现.它允许您表达组成应用程序的对象以及这些对象之间丰富的依赖.

Spring提供了`ApplicationContext` 接口的几个实现. 在独立应用中, 通常会创建一个`ClassPathXmlApplicationContext`或`FileSystemXmlApplicationContext`的实例.XML是传统的定义配置的格式, 你也可以通过一小段XML配置来启用这些支持的格式, 指定容器使用Java注解或者代码格式配置. 

在很多的应用场景下, 并不需要显式的实例化一个或多个Spring的IoC容器. 例如, 在Web应用中,`web.xml`文件中大概八行类似的样板化的XML描述就足够了(参看Web程序中便捷的ApplicationContext实例). 如果你使用Spring Tool Suite(一种Eclipse增强开发环境), 能够很轻松地用几次点击鼠标和几个按键生成这样的样板配置.

下图从较高层次展示了Spring如何工作. 你的程序类和配置元数据时结合在一起的, 因此,当`ApplicationContext`创建并实例化后, 你就有了一个可执行系统或程序.
![The Spring Ioc Container](https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/images/container-magic.png)

### 1.2.1 配置元数据

如同上图展示的, Spring IoC 容器使用配置元数据. 配置元数据表现了你作为开发者如何告知Spring容器去实例化,配置并组装程序中的对象.

配置元数据以传统而直观的XML格式提供, 这是本节大部分内容传达的关于Spring IoC容器的关键概念和特性.

*XML不是唯一允许描述元数据的格式. Spring IoC 容器已经弱化了配置以何种格式书写. 当今,许多开发人员更愿意在程序中选择Java配置的方式.*

如何使用其他格式的配置,可以参考下面的信息:

* 注解配置: Spring 2.5引入了注解配置支持
* Java配置: 从Spring3.0开始, Spring JavaConfig项目中的一些特性已经成为Spring Framework的核心. 因此,你可以使用Java而不是XML文件扩展你的应用. 要使用这些新特性, 请参看`@Configuration`,`@Bean`,`@Import`,`@DependsOn`注解.

Spring配置由至少一个,或典型的超过一个由容器管理的bean的定义. XML格式使用`<bean/>`元素配置这些beans, 它嵌套在顶层`<beans/>`元素里面. Java配置则包含在使用`@Configuration`注解的class中,并使用`@Bean`注解方法.

这些bean定义与构成你程序的对象相吻合. 例如, 你定义服务层对象,数据访问层对象,变现层对象如Struts `Action` 实例, 基础对象如Hibernate `SessionFactories`, JMS 队列等. 一般不会在容器中定义细粒度的域对象.因为这通常是DAO或业务逻辑层的任务去创建和加载这些对象. 尽管如此, 你可以使用AspectJ去配置在容器之外创建对象.参看在Spring中使用AspectJ依赖注入领域对象.

下面例子展示了XML配置的基本格式:

``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="..." class="...">   
        <!-- collaborators and configuration for this bean go here
        1. id是区分bean的一个字符串标识符
        2. class 定义bean的类型,使用全限定类名
         -->
    </bean>

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions go here -->

</beans>
```

`id`属性的值指向协作的对象. 本例中没有明确写出.可参看依赖项.

### 1.2.2 实例化容器

`ApplicationContext` 构造参数中的定位参数字符串是让容器从外部变量加载配置. 参数可以是多种资源格式, 例如本地文件系统, Java `CLASSPATH`等.

``` Java
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
```

*学习Spring容器后, 你可能想要了解下Spring的`Resource`抽象, 它提供了一种便捷的从URI格式的资源中读取流的机制. 尤其是,`Resource`路径通常用来构建程序上下文, 这点可参看"程序上下文和资源路径"*

下面例子展示了服务层对象的配置文件:

``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- services -->

    <bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
        <property name="accountDao" ref="accountDao"/>
        <property name="itemDao" ref="itemDao"/>
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for services go here -->

</beans>
```

接下来的例子展示了数据访问层配置:

``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="accountDao"
        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for data access objects go here -->

</beans>
```

前面例子中, 服务层由`PetStoreServiceImpl`类和两个数据读取对象`JpaAccountDao`和`JpaItemDao`(根据JPA对象关系映射标准). `name`指类中的属性,表示bean的名称, `ref`元素指向另一个bean定义. 在`id`与`ref`元素之间的联系表明了对象间的协作依赖关系. 关于对象依赖配置的更多细节, 参看"依赖项".

####　结合XML格式的配置

使用多个xml文件定义bean是有用的. 通常各自的xml文件能分别表示逻辑层或架构中的一个模块.

你可以使用程序上下文构造器从所有这些XML片段中加载bean的定义. 构造器获取多个`resource`资源位置, 就像我们在上节展示的那样. 或者, 使用一个或多个`<import/>`元素从其他文件中加载bean定义. 下面展示了如何这样做:

``` xml
<beans>
    <import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>

    <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>
</beans>
```

上面的例子中, 外部bean定义是从这几个文件加载的: `services.xml`,`messageSource.xml`,`themeSource.xml`. 这些文件的路径相对于导入他们的文件, 因此`services.xml` 必须是与导入文件处在相同路径目录下. 就像你看到的, '/'可以忽略. 虽然路径是相对的,但尽量不要使用'/'. 导入的这些文件的格式必须符合Spring的Schema, 需要有顶级`<beans/>`元素. 必须是有效的XML的bean定义.

*可以但不提倡在父级目录中使用'../'引用文件. 这样会在当前应用程序外创建依赖文件.特别不提倡使用`classpath:`URLs(例如,`classpath:../services.xml`),运行时解析时会选择最近的根路径并且转到它的父目录.Classpath的配置可能会错误地引导到其他的目录下.*
*可以使用绝对路径替代相对路径,例如`file:C:/config/services.xml`或` classpath:/config/services.xml`. 但这样就不灵活地将路径耦合到程序配置中了.一般的做法是可以使用一种间接方式-例如占位符"${...}",  这样系统JVM可以在运行时解析到正确路径上*

命名空间本身提供了导入指令特性. 比纯bean定义更高级的配置特性Spring也有提供. 例如`context`和`util`命名空间.

#### Groovy的Bean定义DSL

外部化元数据配置的更高级例子, bean定义也可以使用Spring的Groovy Bean Definition DSL, 因Gails框架而熟知. 下面演示了".groovy"文件中典型的配置的方式:

``` groovy
beans {
    dataSource(BasicDataSource) {
        driverClassName = "org.hsqldb.jdbcDriver"
        url = "jdbc:hsqldb:mem:grailsDB"
        username = "sa"
        password = ""
        settings = [mynew:"setting"]
    }
    sessionFactory(SessionFactory) {
        dataSource = dataSource
    }
    myService(MyService) {
        nestedBean = { AnotherBean bean ->
            dataSource = dataSource
        }
    }
}
```

这种配置的风格大体上与XML配置相同, 甚至支持XML命名空间. 可以通过`importBeans`指令从XML文件导入bean定义.

### 1.2.3 使用容器

`ApplicationContext`接口是一个能管理注册的bean以及他们之间依赖的高级工厂. 通过方法`T getBean(String name, Class<T> requiredType)` , 可以获取Bean的实例.

`ApplicationContext`允许读取bean定义并访问他们, 如下所示

``` java
// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// retrieve configured instance
PetStoreService service = context.getBean("petStore", PetStoreService.class);

// use configured instance
List<String> userList = service.getUsernameList();
```

Groovy配置的启动也类似. 不过它有Groovy风格的不同上下文实现(同时也支持XML). 下面展示了Groovy配置:

```java
ApplicationContext context = new GenericGroovyApplicationContext("services.groovy", "daos.groovy");
```

最灵活的变量是`GenericApplicationContext`, 其中包含读取器代理, 例如: 对于XML文件, 它使用`XmlBeanDefinitionReader`读取. 如下例:

```java
GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
context.refresh();
```

对于Groovy, 可是使用`GroovyBeanDefinitionReader`, 如下所示:

``` java
GenericApplicationContext context = new GenericApplicationContext();
new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
context.refresh();
```

在相同的`ApplicationContext`中可以混合使用这些读取代理器, 从而从不同资源中读取配置.

可以使用`getBean`获取bean的实例. `ApplicationContext`接口还有一些其他的方法获取bean, 但是理想状态下, 你的程序应该永远不要使用它们. 确实, 你的程序代码压根不应该调用`getBean`方法,因此就一点也不会依赖Spring API. 例如, Spring为多种Web框架的组件集成提供DI功能, 例如controller和JSF管理的Bean, 允许你通过元数据声明依赖的bean(类似包装(autowiring)注解). 

## 1.3 Bean 概览

Spring IoC 容器管理一到多个bean. 这些bean是根据你提供给容器的配置创建的. (例如, 通过XML格式的`<bean />`定义)

在容器内部, 这些bean定义表现为`BeanDefinition`对象. 其包含如下信息 :

* 包含包名的类名: 典型地,bean定义的实际实现类;
* Bean行为配置元素, 标记bean在容器中行为(作用域scope, 生命周期回调等);
* bean的协同或依赖的其他bean的引用.
* 最近创建对象的其他配置信息,例如当使用bean时连接池的池大小或链接数

元数据被解析为一系列组成bean定义的属性, 下面表格列出了这些属性:

Table 1. The bean definition
| 属性 | 参看 |
| ------ | ------ |
| Class | 初始化bean |
| Name | 命名bean |
| Scope | Bean的作用域 |
| Constructor arguments | 依赖注入 |
| Properties | 依赖注入 |
| Autowiring mode | 自动装配协作对象 |
| Lazy initialization mode | 懒加载Bean |
| Initialization method | 初始化回调 |
| Destruction method | 销毁回调 |

bean定义包含如何创建特定bean, 除此之外`ApplicationContext`的实现允许将容器外创建的bean注册进来. 这是通过`getBeanFactory()`方法访问ApplicationContext的 BeanFactory , 该方法默认返回`DefaultListableBeanFactory` 实现. `DefaultListableBeanFactory`支持通过`registerSingleton(..)` 和 `registerBeanDefinition(..)` 方法注册. 尽管可以这样做,应用程序一般还是单纯使用规则的bean定义元数据. 

*bean元数据和单例的手工支持必须尽早注册, 这是为了容器能够在自动装配和其他自省阶段合理解析.重写已经存在的元数据以及已经存在的单例在某些级别上是支持的, 但运行时注册新的bean(与工厂的并发访问)没有得到正式的支持,而且可能导致并发访问异常或bean状态不一致,或两者都有.*

### 1.3.1 命名Bean

每个bean都有一个或多个标识符. 容器内这些标识符必须是唯一的. 一般一个bean只有一个标识符. 但是也可以有多个,多出来的标识符是别名.

XML配置中,`id`或`name`属性用来做标识符. `id`用来精确指定一个id. 按照习惯, 这些名称是字母数字组成的('myBean', 'someService', etc.), 但他们也可以包含特殊字符. 如果你想给bean指定别名,你可以将他们赋值给`name`属性, 用逗号,分号或者空格分割. 在Spring3.1之前, `id`是定义为一个`xsd:ID`类型, 只能是字母. 自从3.1开始将其定义为`xsd:string`类型. 注意`id`的唯一性依然是容器强制的, 而不是XML解析器.

给bean`name`或`id`属性不是必须的. 如果没有指定, 容器会为bean生成一个唯一名称. 尽管这样, 如果你想通过名称引用bean, 或者通过`ref`元素或者是Service Locator风格的查找, 你就必须给bean指定名称. 不给bean指定名称的动机是使用内部类和自动装配. 

> **bean命名约定**

> 给bean命名遵循与给实例域命名相同的约定. 也就是,使用小写字母开头的骆驼命名法. 例如: `accountManager`, `accountService`, `userDao`, `loginController`等.

> 坚持命名bean可以使你的配置易读易理解. 还有, 如果使用Spring AOP, 当给名字相关的一些列bean应用通知时也会有很大帮助. 

*扫描类路径时, Spring会给未命名组件生成名称, 遵循前面描述的规则: 本质上是取类名,然后将首字符小写. 当有多余一个字母并且第一个和第二个字母都是大写时将保留大小写. 这些规则定义在`java.beans.Introspector.decapitalize`(Spring使用)*

#### 在Bean定义之外添加别名

在bean定义内, 你可以给它指定多个名称, 可以使用给`id`指定一个名称, 同时也可以给`name`指定多个(使用分隔符).使用这些名称指定的bean都是等效的, 在某些情况下也是有用的, 例如: 让应用程序中的每个组件通过使用特定于该组件本身的bean名称来引用公共依赖项。

然而在定义bean的时候为其指定别名有时候并不够. 有时候需要将别名bean定义外的其他地方指定. 通常的例子是, 在大型系统内各个子系统分别有各自配置, 每个子系统有一组其bean的定义. XML的配置中,你可以使用`<alias/>`元素实现. 如下:

```xml
<alias name="fromName" alias="toName"/>
```

本例中, bean的名称(同一容器)被命名为`fromName`, 在使用别名定义后, 这个bean通过`toName`也可以引用. 

例如, 子系统A引用了一个数据源叫`subsystemA-dataSource`. 子系统B引用数据源叫`subsystemB-dataSource`. 当主程序都使用这两个系统时, 主程序引用了数据源`myApp-dataSource`. 这三个数据源都指向相同的对象, 你可以将下面的别名配置添加到元数据:

```xml
<alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
<alias name="myApp-dataSource" alias="subsystemB-dataSource"/>
```

现在, 虽然每个组件和主程序都通过一个名称引用了各自唯一的数据源, 并且能保证不会与其他定义冲突(有效创建了命名空间), 然而实际上他们引用的同一个对象.

> **Java 配置**

> 如果使用Java配置, `@Bean`注解可以提供别名, 参看:如何使用`@Bean`注解.

### 1.3.2 实例化Bean

bean定义的本质是创建对象的配方. 当需要时容器将查看bean的配方, 并使用该bean的定义封装的配置元数据来创建(或获取)实际对象.

如果使用XML配置, 要实例化的对象的类型是通过`<bean/>`节点的`class`属性来指定的. `class`属性(对应到`BeanDefinition`实例是`Class`属性)通常是强制的. (例外的情况请参看:使用工厂方法实例化,和Bean定义的继承.) 有两种使用`Class`属性的方法:

* 典型的, 直接指定class, 由容器通过构造器反射的形式直接创建bean. 有点等同于java代码的`new`操作.
* 为包含创建对象的静态工厂方法指定对象的实际类, 少数情况下容器通过静态工厂方法创建bean. 被静态工厂方法创建出来的对象可能是相同的类型或者压根是另一个类型.

> *内部类名称*

> 如果你想要为一个静态内部类配置bean, 你就必须使用内部类的双名称.

> 例如, 你有个类定义为`SomeThing`,在`com.example`包下. `SomeThing`有个静态内部类为`OtherThing`, 那它的`class`属性的值将是`com.example.SomeThing$OtherThing`

> 注意内部类和外部类之间需要使用`$`字母分割.

#### 使用构造器实例化

当使用构造器创建bean时. 所有标准类都可用且都是可与Spring兼容的. 也就是开发时不需要实现任何接口或者遵循特定的编程风格. 简单定义为一个class即可. 尽管如此, 根据使用的IoC容器, 可能你需要定义一个默认构造器.

IoC容器可以管理任何你想要被托管的类. 它不仅限于管理JavaBeans. 大多数Spring用户喜欢在属性后定义getter和sertter模块. 你也可以在容器中定义非bean风格的类. 例如, 如果你想使用遗留代码中完全不遵循JavaBean规范的连接池, Spring也是可以管理的.

使用XML配置指定bean定义 如下:

``` xml
<bean id="exampleBean" class="examples.ExampleBean"/>

<bean name="anotherExample" class="examples.ExampleBeanTwo"/>
```

更多关于构造函数参数和对象构造后属性的赋值, 参看:依赖注入.

#### 静态工厂方法实例化

当定义使用静态工厂构建的bean时, 需要使用`class`属性指定包含静态工厂方法的类, 并且使用`factory-method`属性指定工厂方法.你可以调用该方法(带可选参数, 后面有表述)返回一个对象, 接着这个对象就可以像使用构造器创建出来的一样使用了. 一种这么使用bean定义的场景是在遗留代码中调用静态工厂. 

下面指定了通过调用静态工厂方法创建bean的配置. 这个定义没有指定返回类型, 只是指定了这个类包含静态方法. 在本例中, `createInstance()`方法必须是静态方法. 下面例子展示了如何指定静态方法:

```xml
<bean id="clientService"
    class="examples.ClientService"
    factory-method="createInstance"/>
```

下面展示了使用上述定义的类的代码:

```java
public class ClientService {
    private static ClientService clientService = new ClientService();
    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}
```

有关静态方法的参数和对象从工厂返回后属性的赋值, 参看: 依赖和配置细节. 

#### 使用对象工厂方法实例化

与静态工厂方法实例化类似.容器可以通过调用已存在的bean的非静态工厂方法去创建bean. 要使用这种机制, 可以将`class`留空, 并且在`factory-bean`属性指定当前(或父或祖先)容器中包含用来创建对象的工厂方法的bean. 使用`factory-method`属性设置工厂方法的名称. 下面展示了怎么配置:

```xml
<!-- the factory bean, which contains a method called createInstance() -->
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<!-- the bean to be created via the factory bean -->
<bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/>
```

下面代码展示了对应的java类:

```java
public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }
}
```

工厂类可以有多个工厂方法的定义, 如下所示:

```xml
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/>

<bean id="accountService"
    factory-bean="serviceLocator"
    factory-method="createAccountServiceInstance"/>
```

下面是对应的java类:

```java
public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    private static AccountService accountService = new AccountServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }

    public AccountService createAccountServiceInstance() {
        return accountService;
    }
}
```

关于工厂bean本身如何通过DI管理和配置, 参看:依赖和配置细节.

*Spring文档中,"factory bean"(工厂bean)是指Spring容器中配置的用来通过实例或静态工厂方法创建对象的bean. 相比而言, `FactoryBean`(注意大小写)指Spring特有的`FactoryBean`*

## 1.4 依赖

> 从此处开始升级到5.2.0版本

典型的企业应用不是由单个对象组成的(或用Spring语法来说的bean).就算是最简单的程序也有一些终端用户看起来相互合作的对象来呈现.接下来的这节阐述如何在一个真实的系统中定义一系列的bean, 从而让他们协作达成目标.

### 1.4.1 依赖注入

依赖注入是一个处理过程, 在对象被构造后或者从工厂返回后, 仅仅通过构造函数参数, 工厂方法的参数或者属性赋值的方式来定义他们的依赖(也就是与其他对象协作). 容器在创建bean后注入他们的依赖. 这个处理过程本质上是bean自己去使用类构造和服务定位模式管理初始化和定位它的依赖项的反转(因此叫控制反转).

使用DI原则的代码是清晰的, 并且做到了与提供的依赖项更有效地解耦. 对象不自己定位查找依赖项, 也不知道依赖项的位置和类型.因此, 你的类就更容易被测试, 特别是依赖于接口和抽象类的情况下, 允许你单元测试中使用桩对象或模拟实现.

DI有两个主要的变种: 构造函数依赖注入和属性Setter依赖注入.

#### 构造函数依赖注入

构造函数注入是通过容器调用有若干参数的构造函数完成的, 每个参数代表一个依赖项. 调用带参的静态工厂方法构造bean与此十分类似, 这里讨论对待构造函数构造和静态工厂方法构造是相似的. 下例展示了构造器注入的类定义:

```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

注意这个类没啥特别之处. 它本身就是一个没有实现容器相关接口,基类或使用注解的普通POJO.

#### 构造参数解析

构造参数是通过类型解析匹配的. 如果bean的构造参数没有潜在的二义性, 那么在bean中定义的参数顺序就是bean初始化时的参数顺序. 看下面的代码:

```java
package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}
```

假设`ThingTwo`和`ThingThree`没有继承关系, 没有潜在的二义性. 因此, 下面的配置能很好的起作用, 在`<constructor-arg/>`元素中你不需要制定构造参数的索引或明确制定其类型.

```xml
<beans>
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg ref="beanTwo"/>
        <constructor-arg ref="beanThree"/>
    </bean>

    <bean id="beanTwo" class="x.y.ThingTwo"/>

    <bean id="beanThree" class="x.y.ThingThree"/>
</beans>
```

当另一个bean被引用时, 类型是已知的,匹配能发生(就像前面例子中的处理过程). 当使用简单类型时,例如`<value>true</value>`, Spring不能决定值的类型, 因此无法自动匹配. 再看下面的类:

```java
package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

**构造参数类型匹配**

上述场景中, 如果使用`type`属性给参数指定了类型, 容器就能通过类型匹配. 如下所示:

``` xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```

**构造参数索引**

可以使用`index`属性指定构造函数的参数, 如下:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
```

另外, 如果参数有多个简单类型, 可以使用索引解决多个简单类型参数的二义性.

> 参数是从0开始的.

**构造参数名称**

也可以使用指定构造参数名称消除二义性, 如下:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
```

记住, 要不受限制的使用此功能, 你的代码必须要启用debug标记编译, 这样Spring才能从构造函数查找参数名称. 如果不能或不想启用debug标记, 可以使用`@ConstructorProperties`JDK注解显式添加到构造函数的参数上. 看起来如同下面例子:

```java
package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

#### Setter方式的依赖注入

Setter方式的注入是调用无参构造函数实例化bean或静态工厂方法返回bean之后, 再由容器调用bean的setter方法. 

下例展示了只能用纯setter方式进行注入的类定义. 这个类是传统的java. 是一个没有实现容器相关的接口,基类或添加注解的POJO.

```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

`ApplicationContext`支持构造函数注入和Setter注入. 也支持通过构造函数注入部分依赖后再由Setter注入. 你使用`BeanDefinition`类的形式配置依赖, 这个类与`PropertyEditor`实例协作将属性从一种格式转化为另一种格式. 尽管如此, 大多Spring用户不会直接使用这些类(在编程方面), 而是使用XML `bean`定义, 或者注解注释组件(也就是使用`@Component`,`@Controller`等),或者用`@Configuration`注解的类中使用`@Bean`的java代码配置. 这些资源将在内部转化为`BeanDefinition`实例并用于在IoC容器实例加载. 

> **构造器注入还是Setter注入**

> 因为可以同时混用构造器和Setter注入, 一种比较好的原则是: 强制的依赖使用构造器注入, 可选的依赖则可以使用setter或配置方法. 注意: setter方法上使用`@Required`注解将使得对应属性成为必须的依赖.

> Spring团队提倡构造器注入, 这会让你实现的程序组件是不可变对象并且可以保证依赖不是`null`. 更多的好处是, 构造器注入返回给客户端的组件总是完全被初始化的状态. 还有个边缘效应, 就是大量的构造函数参数是一种不好的代码味道, 暗示着这个类承载了太多的责任并且需要被合理的重构, 实现关注点分离.

> Setter注入应该在依赖是可选的前提下优先使用, 这些依赖可以被赋以合理的默认值. 另外, 非null验证必须要在代码使用依赖的所有地方进行.  使用setter注入的一个好处是: setter方法使得对象的重配置和重注入更易于控制. 通过JMX MBeans管理就是一种setter注入的案例. 

> 使用DI使得特定类更加有意义. 有时候, 当你使用三方类库时, 你并没有源代码, 此时你将手握DI选择权. 例如, 如果三方类没有暴露任何setter方法, 那么使用构造器注入将是唯一途径.

#### 依赖解析过程

容器按照下面阐述的对bean依赖进行解析:

* `ApplicationContext`被创建, 并且使用配置的bean元数据进行初始化. 配置元数据可以是XML,Java code或注解.
* 对于每个bean, 它的依赖以属性,构造函数参数或者静态工厂的参数(如果使用代替普通的构造函数)形式表现. 这些依赖将在bean被创建后提供给bean.
* 每个属性或参数是要被设置的值的定义, 或者是容器中另一个bean的引用.
* 每个属性或参数的值是由特定的格式转换到实际类型的. 默认情况下, Spring能够将字符串格式转化为所有内置类型如: `int`, `long`, `String`, `boolean`等.

Spring容器在创建后对每个bean的配置进行校验. 尽管如此, 在bean被创建后bean的属性才会被赋值. 单例域的并且设置为预实例化(默认情况)的bean在容器创建后被创建. 域的定义参看bean的作用域. 除此之外, bean只有在被请求时才创建. 一个bean的创建会潜在地导致bean的整个图被创建, 也就是bean的依赖,它的依赖的依赖等都被创建和分配. 注意: 依赖解析的不匹配可能会后期表现出来, 也就是第一次创建受影响的bean时. 

> **循环依赖**

> 如果用占主导地位的构造器注入, 就可能会导致无法解析的循环依赖.

> 例如: 类A需要类B,通过构造器参数注入, 相反类B也需要类A,通过构造器注入. 如果配置A,B相互注入给对方, Spring的IoC容器就会在运行时检测到循环引用, 并抛出`BeanCurrentlyInCreationException`. 

> 一种处理这种情况的方法是编辑源代码, 将一个的setter注入改为构造器注入. 相应地避免使用构造器注入而仅仅使用setter. 换句话说, 虽然不提倡, 但可以使用setter注入配置循环依赖. 

> 不同于典型的案例(即没有循环依赖), 在bean A和bean B之间的循环依赖将迫使bean在完全实例化自身前将其注入给对方(这是典型的鸡生蛋蛋生鸡的场景).

总体上你可以信任Spring去做正确的事情. 它在容器加载期间检测配置问题, 如不存在的bean或循环依赖.当bean被真正创建后, Spring会尽量延后设置属性和解析依赖. 这意味着在容器正确加载后, 如果你请求的bean有问题或它的依赖有问题,可能会抛出异常--例如, bean抛出缺失或无效属性的异常. 这种潜在的配置问题的延迟导致的不可见性就是为什么`ApplicationContext`的实现默认会预实例化单例bean. 这种会导致前期一些时间和内存消耗的代价能换来配置问题的及时发现, 就是在`ApplicationContext`被创建时, 而不是以后调用bean时. 你也可以覆盖这种预初始化的配置为延迟初始化.

如果没有循环依赖, 当一个或多个协作的bean被注入到依赖的bean里面, 每个协作bean其实是优先于依赖bean就被完全配置好了. 这意味着如果A依赖B, 容器会在调用A的setter方法之前完全配置好B. 换句话说,这个bean被实例化了(如果它不是预实例化的),它的依赖被设置了, 并且他的生命周期函数(如配置的初始化函数或初始化bean回调函数)也被调用了. 

####　DI的例子

下例使用XML配置setter形式的DI. 一小段bean的定义如下:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- setter injection using the nested ref element -->
    <property name="beanOne">
        <ref bean="anotherExampleBean"/>
    </property>

    <!-- setter injection using the neater ref attribute -->
    <property name="beanTwo" ref="yetAnotherBean"/>
    <property name="integerProperty" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

下面展示了对应的`ExampleBean`类:

```java
public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }
}
```

上例中, setter声明为匹配xml文件中指定的属性, 下面例子使用构造函数注入:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- constructor injection using the nested ref element -->
    <constructor-arg>
        <ref bean="anotherExampleBean"/>
    </constructor-arg>

    <!-- constructor injection using the neater ref attribute -->
    <constructor-arg ref="yetAnotherBean"/>

    <constructor-arg type="int" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

下面展示了对应的`ExampleBean`类定义:

```java
public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}
```

在bean定义的构造函数参数用来通过类`ExampleBean`的构造函数参数注入.

现在改变下例子, 不用构造函数注入, 而使用静态工厂方法返回对象实例:

```xml
<bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance">
    <constructor-arg ref="anotherExampleBean"/>
    <constructor-arg ref="yetAnotherBean"/>
    <constructor-arg value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

下面展示了对应的`ExampleBean`类:

```java
public class ExampleBean {

    // a private constructor
    private ExampleBean(...) {
        ...
    }

    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        // some other operations...
        return eb;
    }
}
```

给静态工厂方法的参数是`<constructor-arg/>`元素提供的, 就像使用构造函数一样. 工厂方法返回的实例类型不需要与包含静态工厂的类的类型一致(本例一致). 一个(非静态)实例工厂本质上使用相同方式(除了使用`factory-bean`而不是`class`属性),所以我们不讨论这些细节.

###　1.4.2 依赖和配置细节

在前面的章节中提到, 你可以定义bean的属性或者通过构造函数参数去引用另外的bean(协作者)或者在行内书写数据值. 为了能这样做, Spring的XML配置可以使用`<property/>`和`<constructor-arg/>`元素包含在bean定义元素中.

#### 纯值数据(原始数据,String等类型)

元素`<property/>`的属性`value`可以指定为书写或构造参数的纯值数据. Spring的转化服务用来将这些值从`String`转化为合适的类型. 下例展示了一组这样的配置:

```xml
<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <!-- results in a setDriverClassName(String) call -->
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
    <property name="username" value="root"/>
    <property name="password" value="masterkaoli"/>
</bean>
```

下例使用`p-`命名空间展示更简洁的XML配置:

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
        destroy-method="close"
        p:driverClassName="com.mysql.jdbc.Driver"
        p:url="jdbc:mysql://localhost:3306/mydb"
        p:username="root"
        p:password="masterkaoli"/>

</beans>
```

上面的XML更为精简. 类型转化是发生在运行时而不是设计时, 除非你使用能够在定义bean时支持属性自动完成的IDE(就像IntelliJ IDEA 或 Spring Tool Suite). 而这样的IDE辅助是我们提倡的.

也可以配置`java.util.Properties`类型的实例, 如下:

``` xml
<bean id="mappings"
    class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">

    <!-- typed as a java.util.Properties -->
    <property name="properties">
        <value>
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        </value>
    </property>
</bean>
```

Spring 容器转化内部`<value/>`元素的内容为`java.util.Properties`的实例, 这是通过使用JavaBeans的`PropertyEditor`机制来实现的. 这是一个捷径, 也是几种Spring团队喜欢使用嵌套`<value/>`而不是`value`属性风格的情况之一. 

#### `idref`元素

`idref`元素仅是一种防止错误的方法, 可以将容器中的另一个bean的id(一个字符串,不是引用)传递给属性或构造参数. 如下所示:

```xml
<bean id="theTargetBean" class="..."/>

<bean id="theClientBean" class="...">
    <property name="targetName">
        <idref bean="theTargetBean"/>
    </property>
</bean>
```

上面bean的定义完全等效于(在运行时)下面的片段:

```xml
<bean id="theTargetBean" class="..." />

<bean id="client" class="...">
    <property name="targetName" value="theTargetBean"/>
</bean>
```

第一种形式优于第二种, 因为使用`idref`标签能够让容器在部署期间检查引用的bean是不是真的存在. 第二种情况下, 传递给bean名为`client`的`targetName`属性的值不会被校验. 仅仅是在`client`被实际实例化的时候会发生类型转化(大多数情况下是严重错误). 如果`client`bean是个原型bean, 则只有在部署容器很久之后才会发现错误和由此产生的异常.  

> `diref`元素的`local`属性不再支持4.0版本的beans XSD, 因为它不再提供常规`bean`引用的值. 当升级到4.0时, 请修改现有的`idref local`引用, 修改为`idref bean`.

`<idref/>`元素带值的一个地方(至少在Spring2.0之前的版本中)是在`ProxyFactoryBean`定义中AOP拦截器的配置. 当你为了防止拼写错拦截器ID而指定拦截器名称时使用`<idref/>`元素.

#### 引用其他bean(协作者)

`ref`元素是在`<constructor-arg/>` 或者 `<property/>`中的不可更改的元素. 在这里, 你将另一个由容器管理的bean(协作者)作为引用的值赋给一个bean的属性. 被引用的bean作为引用被赋值给这个bean的属性, 并且它是在被赋值前就按需初始化的. (如果这个协作者是个单例的话,它已经被容器初始化了).所有引用最终都是另一个对象的引用. 作用域和校验则取决于你是否通过`bean`,`local`,`partent`属性为另一个对象指定ID或名称.

通过`<ref/>`tag的`bean`属性指定目标bean是常见的方式, 并且允许其在同一个容器或父容器中创建任何bean的引用. 不管是不是配置在XML格式的文件. `bean`属性的值可以是目标bean的ID后者是name中的任一值. 下面展示了`ref`元素:

```xml
<ref bean="someBean"/>
```

通过`parent`属性创建的引用指定目标bean是在当前容器的父容器. 其值可能是目标bean的id或name的其中任一值. 目标bean必须在当前容器的父容器中. 主要使用这个属性的场景是: 当你使用了有层次的容器并且在父容器中通过代理proxy包装了一个同名的父bean. 下面是一对使用`parent`的例子:

```xml
<!-- in the parent context -->
<bean id="accountService" class="com.something.SimpleAccountService">
    <!-- insert dependencies as required as here -->
</bean>
```

```xml
<!-- in the child (descendant) context -->
<bean id="accountService" <!-- bean name is the same as the parent bean -->
    class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target">
        <ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
    </property>
    <!-- insert other configuration and dependencies as required here -->
</bean>
```

> 4.0的beans XSD 后`ref`元素的`local`属性不再支持, 因此不需要用它为一个正常的`bean`引用提供值了. 当升级到4.0时请注意修改现有的`ref local`到`ref bean`.

#### 内部的bean

`<bean/>`元素如果定义在`<property/>`或者`<constructor-arg/>`内部, 则表示定义了内部bean, 如下所示:

```xml
<bean id="outer" class="...">
    <!-- instead of using a reference to a target bean, simply define the target bean inline -->
    <property name="target">
        <bean class="com.example.Person"> <!-- this is the inner bean -->
            <property name="name" value="Fiona Apple"/>
            <property name="age" value="25"/>
        </bean>
    </property>
</bean>
```

内部bean定义不需要指定ID或name, 如果指定了, 容器也不会使用它们作为bean的标识符. 容器也会在创建时忽略它们的`scope`标记, 因为内部bean通常都是匿名的, 并且总是跟外部bean一起创建. 一般不可能去单独的访问内部bean, 或者将他们注入到协作bean而不是包装bean中.

作为旁例, 从一个自定义的scope中获取到销毁回调是可能的, 例如对于一个单例bean中作用域为request-scope的内部bean. 内部bean的创建是与外部bean的创建是绑定的, 但是销毁回调使它特定于request生命周期. 这并不是一个普遍的场景, 内部bean一般是与包含它的bean有着相同的作用域. 

#### 集合

`<list/>`,`<set/>`,`<map/>` 和 `<props/>`元素分别
对应于Java集合类型(`Collection`)的`List`, `Set`, `Map`, 和 `Properties`. 下例展示其用法:

```xml
<bean id="moreComplexObject" class="example.ComplexObject">
    <!-- results in a setAdminEmails(java.util.Properties) call -->
    <property name="adminEmails">
        <props>
            <prop key="administrator">administrator@example.org</prop>
            <prop key="support">support@example.org</prop>
            <prop key="development">development@example.org</prop>
        </props>
    </property>
    <!-- results in a setSomeList(java.util.List) call -->
    <property name="someList">
        <list>
            <value>a list element followed by a reference</value>
            <ref bean="myDataSource" />
        </list>
    </property>
    <!-- results in a setSomeMap(java.util.Map) call -->
    <property name="someMap">
        <map>
            <entry key="an entry" value="just some string"/>
            <entry key ="a ref" value-ref="myDataSource"/>
        </map>
    </property>
    <!-- results in a setSomeSet(java.util.Set) call -->
    <property name="someSet">
        <set>
            <value>just some string</value>
            <ref bean="myDataSource" />
        </set>
    </property>
</bean>
```

字典map的键值,或者集set的值, 可以是下面元素的任一:

```xml
bean | ref | idref | list | set | map | props | value | null
```

#### 集合合并

Spring容器支持合并集合. 开发人员可以定义一个父的`<list/>`,`<set/>`,`<map/>` 和 `<props/>`元素,并且子元素的`<list/>`,`<set/>`,`<map/>` 和 `<props/>`可以继承和覆盖父集合的值. 也就是说, 子集合的值是父集合与子集合元素的合并, 子集合的元素覆盖了父集合中的值.

本节讨论父子bean的合并机制. 读者要是不了解父子bean的定义可以参看相关章节,然后再回来.

下例展示了集合的合并:

```xml
<beans>
    <bean id="parent" abstract="true" class="example.ComplexObject">
        <property name="adminEmails">
            <props>
                <prop key="administrator">administrator@example.com</prop>
                <prop key="support">support@example.com</prop>
            </props>
        </property>
    </bean>
    <bean id="child" parent="parent">
        <property name="adminEmails">
            <!-- the merge is specified on the child collection definition -->
            <props merge="true">
                <prop key="sales">sales@example.com</prop>
                <prop key="support">support@example.co.uk</prop>
            </props>
        </property>
    </bean>
<beans>
```

注意`merge=true`的使用, 它在bean`child`的`<props>`元素中名为`adminEmails`. 当`child`被容器解析和初始化后, 最终的实例将有一个`adminEmails`的`Properties`集合, 包含了合并父集合与子集合中`adminEmails`的全部元素. 下面展示了结果:

```
administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk
```

子`Properties`集合的值继承了父`<props/>`, 并且子集合中`support`值覆盖了父集合中的值. 

这种合并行为也同样类似于`<list/>`, `<map/>`, 和 `<set/>`等集合类型. 在`<list/>`元素的特定情况下, 其语义与`List`集合类型相关联(也就是一个一系列值的有序集合). 父集合的值优先于子集合的值. 在`Map`, `Set`, 和 `Properties`类型情况下, 元素间不存在顺序. 因此,容器内部使用构筑在`Map`,`Set`,`Properties`实现类型之上的无序集合类型. 

#### 集合合并的限制

不能合并不同的集合类型(如`Map`和`List`进行合并). 如果这样做, 会抛出相应异常. `merge`属性必须在继承或者较低的子定义上. 指定在父集合定义上的`merge`是多余的,也不会产生期望的合并.

#### 强类型集合

从Java5的泛型集合开始, 你可以使用强类型的集合了. 也就是声明一个值包含(例如)String 类型的元素集合成为可能. 如果使用Spring的DI去注入一个强类型集合, 你可以得到Spring类型转化支持, 将先前添加到`Collection`的元素转化为正确的类型. 下例展示了用法:

```java
public class SomeClass {

    private Map<String, Float> accounts;

    public void setAccounts(Map<String, Float> accounts) {
        this.accounts = accounts;
    }
}
```

```xml
<beans>
    <bean id="something" class="x.y.SomeClass">
        <property name="accounts">
            <map>
                <entry key="one" value="9.99"/>
                <entry key="two" value="2.75"/>
                <entry key="six" value="3.99"/>
            </map>
        </property>
    </bean>
</beans>
```

当bean`something`的`account`属性准备注入时, 它的泛型类型信息被反射获取到. 因此, Spring的类型转化基础设施辨别出元素的值是`Float`, 并且将字符串值(`9.99,2.75 和 3.99`)转化为实际的`Float`类型.

#### Null和空字符值

Spring将properties的空参数视为空字符串. 下面的XML配置片段设置`email`属性为空值("").

```xml
<bean class="ExampleBean">
    <property name="email" value=""/>
</bean>
```

上面的例子等效于下面的Java代码:

```java
exampleBean.setEmail("");
```

`<null/>`元素处理null值. 如下所示:

```xml
<bean class="ExampleBean">
    <property name="email">
        <null/>
    </property>
</bean>
```

上面代码等效于:

```java
exampleBean.setEmail(null);
```

#### XML的p-命名空间

p-命名空间可以在`bean`元素的属性中使用,(而不是嵌套的`<property/>`元素), 可以用来描述属性值或协作bean.

Spring支持用命名空间扩展配置格式, 这基于XML架构定义. 这节讨论的`bean`配置格式定义在XML架构文档中. 尽管如此, p-命名空间没有定义在XSD文件中, 值存在于Spring的核心. 

下面展示了两段XML(第一段是标准的XML, 第二段是p-命名空间), 他们有相同的结果:

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean name="classic" class="com.example.ExampleBean">
        <property name="email" value="someone@somewhere.com"/>
    </bean>

    <bean name="p-namespace" class="com.example.ExampleBean"
        p:email="someone@somewhere.com"/>
</beans>
```

这个例子展示了bean定义中有个p-命名空间叫`email`. 这实际是告诉Spring有个属性声明. 如前面提到的, p-命名空间没有架构定义, 因此你可以用属性的名字设置标签属性名称. 

下面展示了两个bean定义中同时引用了另一个bean.

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean name="john-classic" class="com.example.Person">
        <property name="name" value="John Doe"/>
        <property name="spouse" ref="jane"/>
    </bean>

    <bean name="john-modern"
        class="com.example.Person"
        p:name="John Doe"
        p:spouse-ref="jane"/>

    <bean name="jane" class="com.example.Person">
        <property name="name" value="Jane Doe"/>
    </bean>
</beans>
```

这个例子包含了不止是用p-命名空间的一个属性, 而且使用了声明属性引用的格式. 第一个bean定义使用`<property name="spouse" ref="jane"/>`创建了从bean`john`到`jane`的引用, 第二个定义则使用了`p:spouse-ref="jane"`来完成相同的事情. 本例中, `spouse`是属性名, 同时`-ref`表明这不是一个表值而是对另一个bean的引用.

> p-命名空间不如标准xml格式灵活. 例如, 声明属性引用的这种格式与使用`ref`的格式冲突. 而标准的XML则不会. 我们强烈建议你细心选用合适的方式, 与团队沟通来避免产生同时使用三种格式的XML文档. 

#### XML的c-命名空间

类似于p-命名空间. 从Spring3.1开始, c-命名空间允许将构造参数配置在行内, 而不是单独嵌套的`<constructor-arg/>`元素内.

下例使用`c:`命名空间实现与构造函数注入相同的事情:

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:c="http://www.springframework.org/schema/c"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="beanTwo" class="x.y.ThingTwo"/>
    <bean id="beanThree" class="x.y.ThingThree"/>

    <!-- traditional declaration with optional argument names -->
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg name="thingTwo" ref="beanTwo"/>
        <constructor-arg name="thingThree" ref="beanThree"/>
        <constructor-arg name="email" value="something@somewhere.com"/>
    </bean>

    <!-- c-namespace declaration with argument names -->
    <bean id="beanOne" class="x.y.ThingOne" c:thingTwo-ref="beanTwo"
        c:thingThree-ref="beanThree" c:email="something@somewhere.com"/>

</beans>
```

`c:`命名空间使用与`p:`命名空间相同的约定来设置构造函数参数(对于引用使用`-ref`后缀).相似的, 需要声明在XML文件中, 虽然在XSD架构中未定义(它存在于Spring的内核中).

对于少数构造函数名称不可用的情况(通常是没有debug信息的已编译二进制文件),可以使用参数索引, 如下:

``` xml
<!-- c-namespace index declaration -->
<bean id="beanOne" class="x.y.ThingOne" c:_0-ref="beanTwo" c:_1-ref="beanThree"
    c:_2="something@somewhere.com"/>
```

> 鉴于XML语法, 索引必须以`_`开头, 因为XML属性名称不能以数字开头(虽然一些IDE可以). 相应的,元素`<constructor-arg>`中也可使用索引数字,但不常用, 因为声明时的顺序已经足够了. 

实践中, 构造函数解析机制对于匹配参数已经足够了, 所以除非你真正需要, 我们建议使用名称标记贯穿整个程序. 

#### 复合属性名称

在设置bean属性时可以使用复合或者嵌套的属性名称. 只要路径下所有组件不为`null`即可. 如下定义:

```xml
<bean id="something" class="things.ThingOne">
    <property name="fred.bob.sammy" value="123" />
</bean>
```

`something`bean有个`fred`属性, `fred`又有个`bob`属性, `bob`有个`sammy`属性, 最终`sammy`属性被赋值为`123`. 为了能使其起作用, 在bean被构建后, `fred`和其`bob`必须不为`null`.否则`NullPointerException`将被抛出.

### 1.4.3 使用`depend-on`

如果一个bean是另一个bean的依赖, 也就意味着一个bean会作为另一个bean的属性值. 在XML配置中你使用`<ref/>`元素来配置. 但有时候bean之间的依赖关系不是直接的. 举个例子, 一个类的静态初始化器需要被触发,比如对于数据库驱动注册. `depends-on`属性能够显式的迫使一个或多个bean的初始化, 这发生在使用了这个元素的bean初始化之前. 下例使用`depends-on`展示只有一个bean的依赖:

```xml
<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
<bean id="manager" class="ManagerBean" />
```

对于多个依赖, 可以为`depends-on`属性指定多个值(用分号,空格, 逗号分隔)

```xml
<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
    <property name="manager" ref="manager" />
</bean>

<bean id="manager" class="ManagerBean" />
<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
```

> `depends-on`属性能够指定初始化期间的依赖. 仅在单例bean中, 指定相应的销毁期依赖. 用`depends-on`关系定义的依赖bean将被首先销毁, 优先于它自身修饰的bean. 因此, `depends-on`可以用来控制关闭顺序.

### 1.4.4 延迟加载的bean

默认情况下,`ApplicationContext`实现会立马创建和配置所有单例bean, 作为其初始化步骤的一部分. 通常,预初始化时令人满意的, 因为配置和环境错误可以被及时发现, 而不是经过几小时,几天. 当这种行为不令人满意时, 你可以通过将bean定义为延迟加载而阻止预初始化发生. 一个延迟加载的bean告知IoC容器,这个bean是在第一次请求时创建,而不是容器启动时.

XML中, 通过`<bean/>`元素的`lazy-init`属性控制这种行为. 如下:

```xml
<bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/>
<bean name="not.lazy" class="com.something.AnotherBean"/>
```

当上面的配置被`ApplicationContext`处理时, 其启动时`lazy`bean不会被立即初始化, 而`not.lazy`bean将立即被初始化.

尽管如此, 当一个延迟初始化bean是一个非延迟初始化bean的依赖时, `ApplicationContext`在启动时创建了延迟bean, 因为它必须满足单例的依赖. 延迟初始化bean被注入到非延迟的单例bean中了. 

也可以在容器级别通过`<beans/>`元素的`default-lazy-init`属性控制延迟加载行为. 如下所示:

```xml
<beans default-lazy-init="true">
    <!-- no beans will be pre-instantiated... -->
</beans>
```

### 1.4.5 自动装配

Spring容器能够自动装配协作bean之间的关系. 你可以让容器通过检查`ApplicationContext`中的内容自动解析协作bean. 自动装配有如下好处:

* 自动装配可以显著减少指定属性和构造参数的需要. (对于本章其他地方讨论的bean模板等机制也是有价值的).

* 自动配置可以随着对象发展而更新配置. 例如, 如果需要向类添加依赖,则可以自动满足依赖而不需手工配置. 因此,自动装配在开发阶段很有用, 不会在代码变得更稳定时拒绝切换到显式书写的选项. 

当时用XML配置时(参看依赖注入), 你可以通过`<bean/>`元素的`autowire`属性为一个bean指定自动装配模式. 自动装配功能有四种模式. 你可以任选其一. 下表描述了这四种模式:

Table2. 自动装配模式

| 模式 | 说明|
|------|-----|
|no    |(默认)不使用自动装配. bean的引用必须使用`ref`元素. 对于较大部署不推荐修改这个模式设置. 因为显式指定的协作者提供了各大的控制权和可读性. 某种意义上是一个系统的架构文档.|
|byName|通过属性名称自动装配. Spring通过名称查找需要自动装配的bean. 例如: 如果一个bean定义按名字自动装配, 并且包含了一个`master`属性(也就是同时有`setMaster(..)`方法), Spring会查找名为`master`的bean定义, 并且将其设置到属性.|
|byType|如果容器中有匹配property类型的bean就自动装配. 如果多于一个, 将抛出致命异常, 这表明可能不应该使用`byType`匹配. 如果没有匹配的bean, 则忽略(属性不被赋值)|
|constructor|与`byType`类似但是是提供给构造函数参数的. 如果容器中没有精确类型的bean, 致命错误将发生|

通过`byType`和`constructor`装配模式, 你可以装配数组和泛型集合. 这种情况下, 容器中所有类型匹配的候选对象都将提供以满足依赖. 对于`Map`,如果key的类型是`String`,你就可以自动装配. 一个自动装配的`Map`实例的值是由所有匹配类型的bean组成的, 这个实例的key包含对应bean的名称. 

#### 自动装配的限制和不足

自动装配使用在贯穿整个项目的过程中能工作得很好. 如果不是普遍使用, 而只是使用到一两个bean上时会搞得开发人员头晕. 

参考自动装配的限制和不足:

* `property`和`constructor-arg`设置的显式依赖总是会覆盖自动装配. 不能自动装配简单类型,`String`和`Class`(或者这些类型的数组). 这个限制是专门设计的. 

* 比起显式装配, 自动装配精确度较低. 虽然, 正如前面表格提到的, Spring非常小心地避免在多个期望结果下导致的二义性进行猜测. Spring管理的对象间的关系以及不是显式文档定义的了. 

* 装配信息可能是不可用的, 对于从Spring容器生成的文档的工具而言.

* 容器内多个bean定义可能会匹配到自动装配的setter类型或构造参数类型.对于数组,或者`Map`实例, 这不是一个问题. 然而对于期望单一值的依赖, 这种二义性不能被随意处理, 如果没有唯一bean可用,异常将会抛出.  

对于后面的几种场景, 你可能有如下几个选择:

* 抛弃自动装配, 拥抱显式装配

* 设置bean的`autowire-candidate`为`false`以防止自动装配, 正像下一节描述的.

* 通过设置`<bean/>`元素的`primary`属性为`true`将其定义为优先匹配对象. 

* 使用有更多细粒度控制的注解驱动配置, 如在注解配置中描述的.

#### 从自动配置中排除bean

在单个bean级别, 你可以从自动装配中排除bean.在XML配置中, 可以通过设置bean的`autowire-candidate`为`false`. 容器能使得特定bean排除在自动装配之外(包括注解格式的配置如`@Autowired`).

> `autowire-candidate`属性被设计为仅对基于类型的装配有效. 对于通过name引用的显式引用无效, 即使指定的bean没有被标记为候选也会被解析. 结果就是当名字匹配时, 通过name自动装配仍然会注入bean. 

你可以通过基于bean名称的模式匹配去限制bean的自动装配. 根级别元素`<beans/>`通过属性`default-autowire-candidate`接收一个或多个模式.例如:限制名称以`Repository`结尾的bean的候选状态, 可以使用模式`*Repository`. 可以通过逗号分隔多个模式. bean元素上的`autowire-candidate`属性的值`true`或`false`总是有优先权. 对于这些bean, 模式规则不生效.

这些技术对于从没想要通过自动装配注入的bean是有用的. 这并不意味着被排除的bean自己不能通过自动装配所配置, 而是它本身将不会作为bean的候选装配给其他bean.

### 1.4.6 方法注入

大多数应用场景中, 容器中的很多bean都是单例的. 当一个单例的bean需要与另一个单例bean协作, 或者一个非单例bean需要与另一个非单例bean协作时, 一般需要通过将一个bean作为另一个bean的属性来处理依赖关系. 当bean的生命周期不同时将会发生问题. 假设一个单例bean A需要一个非单例(原型)bean B, 也许每个方法都有调用. 容器只创建A一次, 因此只有一次机会设置它的属性. 一旦有用到, 容器不能总是使用B的新实例提供给A.

一种解决方案就是抛弃依赖注入. 你可以使一个Bean A 通过实现接口`ApplicationContextAware`被容器所感知, 并且a通过`getBean("B")`请求容器每次都获得到b的新实例.下面代码演示了这种方法:

```java
// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean("command", Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
```

上面代码并不令人满意, 因为业务代码与Spring框架耦合在一起了. 方法注入, 是一种Spring容器更为高级的特性, 能够让你更聪明滴处理此类问题. 

> 你可以从[这篇博客](https://spring.io/blog/2004/08/06/method-injection/)中获取到更多方法注入的动机. 

#### 查找方法注入

查找方法注入是重写容器管理的bean并查找另一个容器中的命名bean将其返回的能力. 查找一般是一个原型bean, 就像在前面章节讨论的. Spring框架通过CGLib库的二进制代码动态生成子类重写方法.

* 为了能让动态的子类工作, 需要为其生成子类的bean不能是`final`, 同时需要覆盖的方法也不能是`final`.

* 进行单元测试时, 如果有`abstract`方法的类需要你自己去定义子类并且提供`abstract`方法的桩实现.

* 具体方法也是需要能组件扫描的, 这就需要获取具体类.

* 另一个关键的限制查找方法和工厂方法,特别是与配置类中的`@bean`注解方法不兼容. 这种情况下, 容器不再控制创建实例因此也就不能在运行时创建子类. 

在前面的`CommandManager`类的代码片段中, Spring容器动态覆盖实现了`createCommand()`方法. 类`CommandManager`没有任何Spring依赖, 如下所示;

```java
package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
```

在客户端代码中包含了需要注入的方法, 这个被注入的方法需要如下的格式:

```xml
<public|protected> [abstract] <return-type> theMethodName(no-arguments);
```

如果方法是`abstract`修饰的, 子类将实现这个方法, 否则动态生成的子类将重写定义在源类中的实际方法. 如下所示:

```xml
<!-- a stateful bean deployed as a prototype (non-singleton) -->
<bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype">
    <!-- inject dependencies here as required -->
</bean>

<!-- commandProcessor uses statefulCommandHelper -->
<bean id="commandManager" class="fiona.apple.CommandManager">
    <lookup-method name="createCommand" bean="myCommand"/>
</bean>
```

id定义为`commandManager`的bean调用其`createCommand()`方法, 在其需要`myCommand`实例的时候. 你必须小心地部署bean`myCommand`为原型bean. 如果它是一个单例, 则每次返回的都是相同的实例.

也可以使用组件注解的方式, 你可以通过`@Lookup`注解在方法上, 如下所示:

```java
public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup("myCommand")
    protected abstract Command createCommand();
}
```

或者, 更规范地, 你可以信任目标bean通过返回的类型解析得到目标bean.

```java
public abstract class CommandManager {

    public Object process(Object commandState) {
        MyCommand command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup
    protected abstract MyCommand createCommand();
}
```

注意通常你需要用一个桩实现来声明这种带注释的查找方法, 这样他们才能与Spring组件扫描兼容, 默认情况下, 抽象类会被扫描忽略. 这个限制不适于显式注册或显式导入bean类. 

> 另一个访问不同作用域的方法是使用`ObjectFactory`/`Provider`连接点. 参看: 不同作用域的bean依赖.

> 你可以发现`ServiceLocatorFactoryBean`(在包`org.springframework.beans.factory.config`)是很有用的.

#### 任意方法替换

一种比查找方法注入不那么有用的形式是在一个管理bean中使用另一个方法实现去替换方法. 你可以跳过这节, 直到你需要这种机制再回来看.

使用XML配置的元数据时, 你可以使用`replaced-method`元素替换一个已经存在的方法. 请看下面的类定义, 它有个方法`computeValue`需要被重写:

```Java
public class MyValueCalculator {

    public String computeValue(String input) {
        // some real code...
    }

    // some other methods...
}
```

实现接口`org.springframework.beans.factory.support.MethodReplacer`提供了一个新的方法定义,如下所示:

``` java
/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    }
}
```

需要部署的源bean定义和需要覆盖的方法应该按如下方式组合:

``` xml
<bean id="myValueCalculator" class="x.y.z.MyValueCalculator">
    <!-- arbitrary method replacement -->
    <replaced-method name="computeValue" replacer="replacementComputeValue">
        <arg-type>String</arg-type>
    </replaced-method>
</bean>

<bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/>
```

你可以为元素`<replace-method/>`需要覆盖的方法签名指定一个或多个`<arg-type/>`元素. 只有类中的方法被重载并且有多个的时候才需要参数签名. 为了方便, String类型的参数可以只是一个缩写, 例如,下面的写法都匹配`java.lang.String`

```java
java.lang.String
String
Str
```

因为参数的个数经常能区分出可能的选择, 因此这种缩写能节省大量输入时间, 通过一个短字符串来匹配一个参数类型. 

## 1.5 Bean 作用域

